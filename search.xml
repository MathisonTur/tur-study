<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>报错合集</title>
      <link href="/tur-study/2023/04/05/%E6%8A%A5%E9%94%99%E5%90%88%E9%9B%86/"/>
      <url>/tur-study/2023/04/05/%E6%8A%A5%E9%94%99%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、SpringBoot"><a href="#一、SpringBoot" class="headerlink" title="一、SpringBoot"></a>一、SpringBoot</h2><h2 id="二、SpringCloud"><a href="#二、SpringCloud" class="headerlink" title="二、SpringCloud"></a>二、SpringCloud</h2><h3 id="1-No-spring-config-import-property-has-been-defined"><a href="#1-No-spring-config-import-property-has-been-defined" class="headerlink" title="1. No spring.config.import property has been defined"></a>1. No spring.config.import property has been defined</h3><p>在我们配置spring cloud config的客户端映射时，启动项目之后出现No spring.config.import property has been defined的问题，如图：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052228437.png" alt="image-20230405222859110"></p><p>产生问题的原因是bootstrap.properties比application.properties的优先级要高<br>由于bootstrap.properties是系统级的资源配置文件，是用在程序引导执行时更加早期配置信息读取；<br>而application.properties是用户级的资源配置文件，是用来后续的一些配置所需要的公共参数。<br>但是在SpringCloud 2020.* 版本把bootstrap禁用了，导致在读取文件的时候读取不到而报错，所以我们只要把bootstrap从新导入进来就会生效了。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- bootstrap --&gt;</span>                                          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>                                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-bootstrap<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>                                               <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：若是父工程中没有添加cloud依赖的，此处需要添加版本，有则不需要</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 错误 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos的配置与使用</title>
      <link href="/tur-study/2023/04/05/SpringCloud/Nacos%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/04/05/SpringCloud/Nacos%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介与启动"><a href="#一、简介与启动" class="headerlink" title="一、简介与启动"></a>一、简介与启动</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>Nacos 是 SpringCloudAlibaba 中的一个组件，相比 Eureka 功能更加丰富</p><ul><li>Nacos 官网：<a href="https://nacos.io/zh-cn/">https://nacos.io/zh-cn/</a></li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052242845.png" alt="image-20230405224257780"></p><ul><li>Github 主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></li></ul><blockquote><p>==注意：==下载 nacos 时，要注意<font color="red"> 版本匹配</font>。版本需要与 SpringCloud、SpringBoot 对应，可以查看 github 上 spring-cloud-alibaba 的版本说明。地址：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a></p></blockquote><h3 id="1-2-启动"><a href="#1-2-启动" class="headerlink" title="1.2 启动"></a>1.2 启动</h3><ol><li>进入下载好的 nacos-server 文件夹下 bin 文件下：<code>start.cmd</code>就是 window 下启动的脚本</li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052259834.png" alt="image-20230405225936791"></p><ol start="2"><li>进入 cmd 命令控制台，输入一下命令：<code>start.cmd -m standalone</code> 启动 nacos</li></ol><blockquote><p>==注意：==cmd 需要进入 nacos 的 bin 文件夹，在执行命令</p></blockquote><ol start="3"><li>启动：</li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052301082.png" alt="image-20230405230141041"></p><p>提示信息出现 successfully 表示启动成功，访问<code>localhost:8848</code>，打开 nacos 配置页面</p><blockquote><p>==注意：==由于是在命令控制台中启动 nacos ，所以不能关闭此窗口，否则无法 访问 nacos</p></blockquote><h2 id="二、注册中心"><a href="#二、注册中心" class="headerlink" title="二、注册中心"></a>二、注册中心</h2><h3 id="2-1-注册服务到-nacos"><a href="#2-1-注册服务到-nacos" class="headerlink" title="2.1 注册服务到 nacos"></a>2.1 注册服务到 nacos</h3><p>步骤如下：</p><h4 id="2-1-1-引入依赖"><a href="#2-1-1-引入依赖" class="headerlink" title="2.1.1  引入依赖"></a>2.1.1  引入依赖</h4><h5 id="1-父工程引入-SpringCloudAlibaba-的依赖"><a href="#1-父工程引入-SpringCloudAlibaba-的依赖" class="headerlink" title="1. 父工程引入 SpringCloudAlibaba 的依赖"></a>1. 父工程引入 SpringCloudAlibaba 的依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2021.0.5.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>==注意：==</p><ul><li><code>&lt;type&gt;pom&lt;/type&gt;</code> 与 <code>&lt;scope&gt;import&lt;scope&gt;</code> 必须添加，否则子工程无法引入依赖</li><li>版本需要与 SpringCloud、SpringBoot 对应，可以查看 github 上 spring-cloud-alibaba 的版本说明。地址：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a></li></ul></blockquote><h5 id="2-子工程引入-nacos-discovery-依赖"><a href="#2-子工程引入-nacos-discovery-依赖" class="headerlink" title="2. 子工程引入 nacos-discovery 依赖"></a>2. 子工程引入 nacos-discovery 依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-配置-nacos-地址"><a href="#2-1-2-配置-nacos-地址" class="headerlink" title="2.1.2 配置 nacos 地址"></a>2.1.2 配置 nacos 地址</h4><p>在所需要注册的服务工程的 <code>application.yml</code> 中添加 nacos 地址：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848 # 8848是默认端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>重启服务工程后可以在 nacos 管理页面看到微服务信息：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052257618.png" alt="image-20230405225720564"></p><h3 id="2-2-环境隔离"><a href="#2-2-环境隔离" class="headerlink" title="2.2 环境隔离"></a>2.2 环境隔离</h3><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052304031.png" alt="image-20230405230442932"></p><blockquote><p>创建 namespace ，就不用记录了</p></blockquote><p>下面给微服务配置 namespace</p><p>给微服务配置namespace只能通过修改配置来实现。</p><p>修改 application.yml文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令空间 ID 是在创建 namespace 时，若没有指定则自动生成，可以指定为与 namespace 名一样。</p><p>如：namespace 为 dev</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        namespace: dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、Nacos-配置管理"><a href="#三、Nacos-配置管理" class="headerlink" title="三、Nacos 配置管理"></a>三、Nacos 配置管理</h2><h3 id="3-1-统一配置管理"><a href="#3-1-统一配置管理" class="headerlink" title="3.1 统一配置管理"></a>3.1 统一配置管理</h3><p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052315538.png" alt="image-20230405231526486"></p><h4 id="3-1-1-在-nacos-中添加配置文件"><a href="#3-1-1-在-nacos-中添加配置文件" class="headerlink" title="3.1.1 在 nacos 中添加配置文件"></a>3.1.1 在 nacos 中添加配置文件</h4><p>点击加号：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052316484.png" alt="image-20230405231635432"></p><p>在弹出的表单中，填写配置信息：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052317615.png" alt="image-20230405231721564"></p><blockquote><p>==注意：==项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p></blockquote><h4 id="3-1-2-从-nacos-拉取配置"><a href="#3-1-2-从-nacos-拉取配置" class="headerlink" title="3.1.2 从 nacos 拉取配置"></a>3.1.2 从 nacos 拉取配置</h4><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p><p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p><p>因此spring引入了一种新的配置文件：<code>bootstrap.yml</code>文件，会在<code>application.yml</code>之前被读取，流程如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052318308.png" alt="img"></p><h5 id="1-引入-nacos-config-依赖"><a href="#1-引入-nacos-config-依赖" class="headerlink" title="1. 引入 nacos-config 依赖"></a>1. 引入 nacos-config 依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--nacos配置管理依赖--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-添加-bootstrap-yml"><a href="#2-添加-bootstrap-yml" class="headerlink" title="2. 添加 bootstrap.yml"></a>2. 添加 bootstrap.yml</h5><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  application:    name: userservice # 服务名称  profiles:    active: dev #开发环境，这里是dev   cloud:    nacos:      server-addr: localhost:8848 # Nacos地址      config:        file-extension: yml # 文件后缀名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052320342.png" alt="image-20210714170845901"></p><h5 id="3-读取配置"><a href="#3-读取配置" class="headerlink" title="3. 读取配置"></a>3. 读取配置</h5><p>跟读取 application.yml 中值的读取一样，使用 <code>@Value</code> 注解</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052322094.png" alt="image-20210714170337448"></p><h3 id="3-2-配置热更新"><a href="#3-2-配置热更新" class="headerlink" title="3.2 配置热更新"></a>3.2 配置热更新</h3><h4 id="3-2-1-方式一"><a href="#3-2-1-方式一" class="headerlink" title="3.2.1 方式一"></a>3.2.1 方式一</h4><p>在<code>@Value</code>注入的变量所在类上添加注解<code>@RefreshScope：</code></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052322744.png" alt="image-20210714171036335"></p><h4 id="3-2-2-方式二"><a href="#3-2-2-方式二" class="headerlink" title="3.2.2 方式二"></a>3.2.2 方式二</h4><p>使用<code>@ConfigurationProperties</code>注解代替<code>@Value</code>注解。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@Data@ConfigurationProperties(prefix = "pattern")public class PatternProperties {    private String dateformat;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在UserController中使用这个类代替@Value：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052323568.png" alt="image-20210714171316124"></p><h3 id="3-3-配置共享"><a href="#3-3-配置共享" class="headerlink" title="3.3 配置共享"></a>3.3 配置共享</h3><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p></li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享，故而可以用来配置一些公共配置</p><p><strong>配置共享的优先级：</strong></p><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052324369.png" alt="image-20210714174623557"></p><h3 id="3-4-搭建-Nacos-集群"><a href="#3-4-搭建-Nacos-集群" class="headerlink" title="3.4 搭建 Nacos 集群"></a>3.4 搭建 Nacos 集群</h3>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tur-blog项目文档</title>
      <link href="/tur-study/2023/04/05/tur-blog%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/"/>
      <url>/tur-study/2023/04/05/tur-blog%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>个人博客项目文档</p></blockquote><h2 id="1-依赖版本说明"><a href="#1-依赖版本说明" class="headerlink" title="1. 依赖版本说明"></a>1. 依赖版本说明</h2><table><thead><tr><th>依赖</th><th>版本</th><th>官网</th></tr></thead><tbody><tr><td>SpringBoot</td><td>2.6.13.RELEASE</td><td></td></tr><tr><td>SpringCloud</td><td>2021.0.5</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解@Transactional的用法详解</title>
      <link href="/tur-study/2023/04/04/SpringBoot/%E6%B3%A8%E8%A7%A3-Transactional%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/04/04/SpringBoot/%E6%B3%A8%E8%A7%A3-Transactional%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>@Transactional</code> 注解可以保证方法内多个数据库操作要么同时成功、要么同时失败。但使用 <code>@Transactional</code> 注解需要注意许多细节，不然注解就会失效</p></blockquote><h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><p>事务管理在系统开发中是不可缺少的一部分，Spring 提供了很好的事务管理机制，主要分为：编程式事务和声明式事务</p><h3 id="1-1-编程式事务"><a href="#1-1-编程式事务" class="headerlink" title="1.1 编程式事务"></a>1.1 编程式事务</h3><p>指在代码中手动管理事务的提交、回滚等操作，代码侵入性比较强</p><p>示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void test() {      TransactionDefinition def = new DefaultTransactionDefinition();      TransactionStatus status = transactionManager.getTransaction(def);       try {         // 事务操作         // 事务提交         transactionManager.commit(status);       } catch (DataAccessException e) {         // 事务回滚         transactionManager.rollback(status);         throw e;       }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码，开发者可以通过 API 自己控制事务</p><h3 id="1-2-声明式事务"><a href="#1-2-声明式事务" class="headerlink" title="1.2 声明式事务"></a>1.2 声明式事务</h3><p>声明式事务基于 <code>AOP 面向切面</code>的，将具体业务域事务处理部分解耦，代码侵入性很低，在实际开发中使用较多。</p><p>声明式事务有两种实现方式：</p><ul><li>基于 TX 和 AOP 的 <code>xml 配置文件</code>方式</li><li>基于 <code>@Transactional</code> 注解</li></ul><p>声明式事务对代码没有侵入性，方法内只需要写业务逻辑就可以了，帮助我们节省了很多代码，他会自动帮我们进行事务的开启、提交以及回滚等操作，把程序员从事务管理中解放出来。可以说优点很明显，但是这种方式的缺点也很明显</p><h5 id="1-问题一：声明式事务的粒度问题"><a href="#1-问题一：声明式事务的粒度问题" class="headerlink" title="1. 问题一：声明式事务的粒度问题"></a>1. 问题一：声明式事务的粒度问题</h5><p>声明式事务有一个局限，就是它的最小粒度要作用在方法上。</p><p>也就是说，如果想要给一部分代码增加事务的话，就需要把这部分代码块单独出来作为一个方法。</p><blockquote><p>在大事务耗时过长需要高并发优化的情况下不建议使用声明式事务，建议采用上面提到的编程式事务</p></blockquote><h5 id="2-问题二：声明式事务容易被开发者忽略"><a href="#2-问题二：声明式事务容易被开发者忽略" class="headerlink" title="2. 问题二：声明式事务容易被开发者忽略"></a>2. 问题二：声明式事务容易被开发者忽略</h5><p>而事务一旦被忽略就容易造成很多故障</p><p>首先，如果开发者没有注意到一个方法是被事务嵌套的，那么就可能会再方法中加入一些如RPC远程调用、消息发送、缓存更新、文件写入等操作。</p><p>我们知道，这些操作如果被包在事务中，有两个问题：</p><p>1、这些操作自身是无法回滚的，这就会导致数据的不一致。可能RPC调用成功了，但是本地事务回滚了，可是PRC调用无法回滚了(这里不讨论分布式事务)。</p><p>2、在事务中有远程调用，就会拉长整个事务。那么久会导致本事务的数据库连接一直被占用，那么如果类似操作过多，就会导致数据库连接池耗尽。</p><p>有些时候，即使没有在事务中进行远程操作，但是有些人还是可能会不经意的进行一些内存操作，如运算。或者如果遇到分库分表的情况，有可能不经意间进行跨库操作。</p><h5 id="3-问题三：声明式事务用错，在某些场景下容易失效"><a href="#3-问题三：声明式事务用错，在某些场景下容易失效" class="headerlink" title="3. 问题三：声明式事务用错，在某些场景下容易失效"></a>3. 问题三：声明式事务用错，在某些场景下容易失效</h5><p>后面有详细介绍</p><h2 id="二、-Transactional-介绍"><a href="#二、-Transactional-介绍" class="headerlink" title="二、@Transactional 介绍"></a>二、@Transactional 介绍</h2><h3 id="2-1-Transactional-可以作用在接口、类、类方法上"><a href="#2-1-Transactional-可以作用在接口、类、类方法上" class="headerlink" title="2.1 @Transactional 可以作用在接口、类、类方法上"></a>2.1 @Transactional 可以作用在接口、类、类方法上</h3><ol><li>作用于类：表示该类的所有 public 方法都配置相同的事属性信息</li><li>作用于方法：当类、方法都配置了 @Transactional 时，方法的事务回覆盖类的事务配置信息</li><li>作用于接口：不推荐这种使用方法。因为一旦标注在接口上并且配置了 SpringAOP 使用 CGLib 动态代理，将会导致 @Transactional 失效</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional                                                              @RestController                                                             @RequestMapping                                                             public class MybatisPlusController {                                            @Autowired                                                                  private CityInfoDictMapper cityInfoDictMapper;                                                                                                          @Transactional(rollbackFor = Exception.class)                       @GetMapping("/test")                                                        public String test() throws Exception {                                          CityInfoDict cityInfoDict = new CityInfoDict();                      cityInfoDict.setParentCityId(2);                                     cityInfoDict.setCityName("2");                                       cityInfoDict.setCityLevel("2");                                      cityInfoDict.setCityCode("2");                                       int insert = cityInfoDictMapper.insert(cityInfoDict);                return insert + "";                                              }                                                               }                                                                           <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-Transactional-注解的属性"><a href="#2-2-Transactional-注解的属性" class="headerlink" title="2.2 @Transactional 注解的属性"></a>2.2 @Transactional 注解的属性</h3><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>可选的限定描述符，指定使用的事务管理器</td></tr><tr><td>propagation</td><td>enum: Propagation</td><td>可选的事务传播行为设置</td></tr><tr><td>isolation</td><td>enum: Isolation</td><td>可选的事务隔离级别设置</td></tr><tr><td>readOnly</td><td>boolean</td><td>读写或只读事务，默认读写</td></tr><tr><td>timeout</td><td>int (in seconds granularity)</td><td>事务超时时间设置</td></tr><tr><td>rollbackFor</td><td>Class对象数组，必须继承自Throwable</td><td>导致事务回滚的异常类数组</td></tr><tr><td>rollbackForClassName</td><td>类名数组，必须继承自Throwable</td><td>导致事务回滚的异常类名字数组</td></tr><tr><td>noRollbackFor</td><td>Class对象数组，必须继承自Throwable</td><td>不会导致事务回滚的异常类数组</td></tr><tr><td>noRollbackForClassName</td><td>类名数组，必须继承自Throwable</td><td>不会导致事务回滚的异常类名字数组</td></tr></tbody></table><h5 id="1-propagation-属性"><a href="#1-propagation-属性" class="headerlink" title="1. propagation 属性"></a>1. propagation 属性</h5><p><code>propagation </code>属性代表事务的传播行为，默认值为：<code>Propagation.REQUIRED</code>。其他属性信息如下：</p><table><thead><tr><th>Propagation.REQUIRED</th><th>如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。( 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 ）</th></tr></thead><tbody><tr><td>Propagation.SUPPORTS</td><td>如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</td></tr><tr><td>Propagation.MANDATORY</td><td>如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</td></tr><tr><td>Propagation.REQUIRES_NEW</td><td>重新创建一个新的事务，如果当前存在事务，暂停当前的事务。( 当类A中的 a 方法用默认Propagation.REQUIRED模式，类B中的 b方法加上采用  Propagation.REQUIRES_NEW模式，然后在 a 方法中调用 b方法操作数据库，然而  a方法抛出异常后，b方法并没有进行回滚，因为Propagation.REQUIRES_NEW会暂停 a方法的事务 )</td></tr><tr><td>Propagation.NOT_SUPPORTED</td><td>以非事务的方式运行，如果当前存在事务，暂停当前的事务。</td></tr><tr><td>Propagation.NEVER</td><td>以非事务的方式运行，如果当前存在事务，则抛出异常。</td></tr><tr><td>Propagation.NESTED</td><td>和 Propagation.REQUIRED 效果一样。</td></tr></tbody></table><h5 id="2-isolation-属性"><a href="#2-isolation-属性" class="headerlink" title="2. isolation 属性"></a>2. isolation 属性</h5><p><code>isolation </code>属性：事务的隔离级别，默认值为<code> Isolation.DEFAULT</code></p><ul><li><code>Isolation.DEFAULT</code>：使用底层数据库默认的隔离级别。</li><li><code>Isolation.READ_UNCOMMITTED</code></li><li><code>Isolation.READ_COMMITTED</code></li><li><code>Isolation.REPEATABLE_READ</code></li><li><code>Isolation.SERIALIZABLE</code></li></ul><h5 id="3-timeout-属性"><a href="#3-timeout-属性" class="headerlink" title="3. timeout 属性"></a>3. timeout 属性</h5><p><code>timeout </code>：事务的超时时间，默认值为 -1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</p><blockquote><p>事务超时，就会报错 TransactionTimedOutException:</p></blockquote><h5 id="4-readOnly-属性"><a href="#4-readOnly-属性" class="headerlink" title="4. readOnly 属性"></a>4. readOnly 属性</h5><p><code>readOnly </code>：指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</p><h5 id="5-rollbackFor-属性"><a href="#5-rollbackFor-属性" class="headerlink" title="5. rollbackFor 属性"></a>5. rollbackFor 属性</h5><p><code>rollbackFor </code>：用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</p><h5 id="6-noRollbackFor属性"><a href="#6-noRollbackFor属性" class="headerlink" title="6. noRollbackFor属性"></a>6. noRollbackFor属性</h5><p><code>noRollbackFor</code>：抛出指定的异常类型，不回滚事务，也可以指定多个异常类型</p><h2 id="三、-Transactional-失效场景"><a href="#三、-Transactional-失效场景" class="headerlink" title="三、@Transactional 失效场景"></a>三、@Transactional 失效场景</h2><h3 id="3-1-Transactional-应用在非-public修饰的方法上"><a href="#3-1-Transactional-应用在非-public修饰的方法上" class="headerlink" title="3.1 @Transactional 应用在非 public修饰的方法上"></a>3.1 @Transactional 应用在非 public修饰的方法上</h3><p>如果Transactional注解应用在非public 修饰的方法上，Transactional将会失效</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304040830528.png" alt="image-20230404083047229"></p><p>之所以会失效是因为在Spring AOP 代理时，如上图所示 TransactionInterceptor  （事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的  intercept 方法或 JdkDynamicAopProxy 的 invoke 方法会间接调用  AbstractFallbackTransactionAttributeSource的 computeTransactionAttribute  方法，获取Transactional 注解的事务配置信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected TransactionAttribute computeTransactionAttribute(Method method,    Class&lt;?&gt; targetClass) {        // Don't allow no-public methods as required.        if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {    return null;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。</p><blockquote><p>==注意：==protected、private 修饰的方法上使用 @Transactional 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。</p></blockquote><h3 id="3-2-transactional-注解属性-propagation-设置错误"><a href="#3-2-transactional-注解属性-propagation-设置错误" class="headerlink" title="3.2 @transactional 注解属性 propagation 设置错误"></a>3.2 @transactional 注解属性 propagation 设置错误</h3><p>这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。</p><ol><li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li></ol><h3 id="3-3-Transactional-注解属性-rollbackFor-设置错误"><a href="#3-3-Transactional-注解属性-rollbackFor-设置错误" class="headerlink" title="3.3 @Transactional 注解属性 rollbackFor 设置错误"></a>3.3 @Transactional 注解属性 rollbackFor 设置错误</h3><p>rollbackFor 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查unchecked异常（继承自  RuntimeException的异常）或者 Error才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望  Spring 能够回滚事务，就需要指定 rollbackFor属性。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304040833490.png" alt="image-20230404083312436"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 希望自定义的异常可以进行回滚 @Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。Spring源码如下：</p><pre class="line-numbers language-none"><code class="language-none">private int getDepth(Class&lt;?&gt; exceptionClass, int depth) {       if (exceptionClass.getName().contains(this.exceptionName)) {           // Found it!            return depth;       }       // If we've gone as far as we can go and haven't found it...       if (exceptionClass == Throwable.class) {            return -1;       }       return getDepth(exceptionClass.getSuperclass(), depth + 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-同一个类中方法调用，导致-Transactional失效"><a href="#3-4-同一个类中方法调用，导致-Transactional失效" class="headerlink" title="3.4 同一个类中方法调用，导致@Transactional失效"></a>3.4 同一个类中方法调用，导致@Transactional失效</h3><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。</p><p>那为啥会出现这种情况？其实这还是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//@Transactional                                                 @GetMapping("/test")                                         private Integer A() throws Exception {                           CityInfoDict cityInfoDict = new CityInfoDict();              cityInfoDict.setCityName("2");                               /**                                                           * B 插入字段为 3的数据                                               */                                                          this.insertB();                                              /**                                                           * A 插入字段为 2的数据                                               */                                                          int insert = cityInfoDictMapper.insert(cityInfoDict);                                                                     return insert;                                           }                                                                                                                         @Transactional()                                             public Integer insertB() throws Exception {                      CityInfoDict cityInfoDict = new CityInfoDict();              cityInfoDict.setCityName("3");                               cityInfoDict.setParentCityId(3);                                                                                          return cityInfoDictMapper.insert(cityInfoDict);          }                                                        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-异常被你的-catch“吃了”导致-Transactional失效"><a href="#3-5-异常被你的-catch“吃了”导致-Transactional失效" class="headerlink" title="3.5 异常被你的 catch“吃了”导致@Transactional失效"></a>3.5 异常被你的 catch“吃了”导致@Transactional失效</h3><p>这种情况是最常见的一种@Transactional注解失效场景</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional                                             private Integer A() throws Exception {                         int insert = 0;                                            try {                                                          CityInfoDict cityInfoDict = new CityInfoDict();            cityInfoDict.setCityName("2");                             cityInfoDict.setParentCityId(2);                           /**                                                         * A 插入字段为 2的数据                                             */                                                        insert = cityInfoDictMapper.insert(cityInfoDict);          /**                                                         * B 插入字段为 3的数据                                             */                                                        b.insertB();                                           } catch (Exception e) {                                        e.printStackTrace();                                   }                                                      }                                                          <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务还能正常回滚吗？</p><p>答案：不能！</p><p>会抛出异常：</p><p>1org.springframework.transaction.UnexpectedRollbackException:  Transaction rolled back because it has been marked as rollback-only<br>  　因为当ServiceB中抛出了一个异常以后，ServiceB标识当前事务需要rollback。但是ServiceA中由于你手动的捕获这个异常并进行处理，ServiceA认为当前事务应该正常commit。此时就出现了前后不一致，也就是因为这样，抛出了前面的UnexpectedRollbackException异常。</p><p>spring的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行commit or rollback，事务是否执行取决于是否抛出runtime异常。如果抛出runtime exception 并在你的业务方法中没有catch到的话，事务会回滚。</p><p>在业务方法中一般不需要catch异常，如果非要catch一定要手动抛出throw new RuntimeException()，否则会导致事务失效，数据commit造成数据不一致，所以有些时候try catch反倒会画蛇添足。</p><h3 id="3-6-数据库引擎不支持事务"><a href="#3-6-数据库引擎不支持事务" class="headerlink" title="3.6 数据库引擎不支持事务"></a>3.6 数据库引擎不支持事务</h3><p> 这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的MySQL数据库默认使用支持事务的innodb引擎。一旦数据库引擎切换成不支持事务的myisam，那事务就从根本上失效了。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO系列 BufferedReader</title>
      <link href="/tur-study/2023/04/03/Java/IO%E7%B3%BB%E5%88%97-BufferedReader/"/>
      <url>/tur-study/2023/04/03/Java/IO%E7%B3%BB%E5%88%97-BufferedReader/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304030916034.png" alt="image-20230403091636971"></p><p><code>BufferedReader</code>：缓冲输入流，继承与 <code>Reader</code></p><ul><li>从字符输入流读取文本，缓冲字符，已提供字符、数组和行的高效读取</li><li>可以指定缓冲区大小，或者使用默认大小。默认值足够大，可用于大部分用途</li></ul><p>通常创建 <code>BufferedReader </code>的基本语法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">BufferedReader br = new BufferedReader(new InputStreamReader(System.in))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>语法解析：</p><ol><li>System.in：字节输入流</li><li>new InputStreamReader：将字节流转换为字符流</li><li>new BufferedReader：将字符流放入字符流缓冲区之中</li></ol><h3 id="2-BufferedReader-方法列表"><a href="#2-BufferedReader-方法列表" class="headerlink" title="2. BufferedReader 方法列表"></a>2. BufferedReader 方法列表</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">BufferedReader(Reader in)BufferedReader(Reader in, int size)void     close()void     mark(int markLimit)boolean  markSupported()int      read()int      read(char[] buffer, int offset, int length)String   readLine()boolean  ready()void     reset()long     skip(long charCount)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要使用的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">BufferedReader br = new BufferedReader(new InputStreamReader(System.in));String str= br.readLine() ;char c = br.read() ;// BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>==注意：==</p><ol><li>StringBuffer类的readLine()从每次读取的一行内容，直至读取的为null为止。然后进行输出。</li><li>StringBuffer类的read()方法读取到的每一个字符转换的数字，然后进行输出。</li></ol><h3 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h3><h4 id="3-1-从控制台读取多字符输入"><a href="#3-1-从控制台读取多字符输入" class="headerlink" title="3.1  从控制台读取多字符输入"></a>3.1  从控制台读取多字符输入</h4><p>从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下：</p><pre><code>int read( ) throws IOException</code></pre><p>每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。</p><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//使用 BufferedReader 在控制台读取字符import java.io.*; public class BRRead {    public static void main(String[] args) throws IOException {        char c;        // 使用 System.in 创建 BufferedReader        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        System.out.println("输入字符, 按下 'q' 键退出。");        // 读取字符        do {            c = (char) br.read();            System.out.println(c);        } while (c != 'q');    }}以上实例编译运行结果如下:输入字符, 按下 'q' 键退出。runoobrunoobqq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-从控制台读取字符串"><a href="#3-2-从控制台读取字符串" class="headerlink" title="3.2 从控制台读取字符串"></a>3.2 从控制台读取字符串</h4><p>从标准输入读取一个字符串需要使用 <strong>BufferedReader 的 readLine() 方法</strong>。</p><p>它的一般格式是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String readLine( ) throws IOException<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">BRReadLines.java 文件代码：//使用 BufferedReader 在控制台读取字符import java.io.*; public class BRReadLines {    public static void main(String[] args) throws IOException {        // 使用 System.in 创建 BufferedReader        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        String str;        System.out.println("Enter lines of text.");        System.out.println("Enter 'end' to quit.");        do {            str = br.readLine();            System.out.println(str);        } while (!str.equals("end"));    }}以上实例编译运行结果如下:Enter lines of text.Enter 'end' to quit.This is line oneThis is line oneThis is line twoThis is line twoendend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String,StringBuffer,StringBuilder类的区别</title>
      <link href="/tur-study/2023/04/03/Java/String-StringBuffer-StringBuilder%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/tur-study/2023/04/03/Java/String-StringBuffer-StringBuilder%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="1-简述"><a href="#1-简述" class="headerlink" title="1. 简述"></a>1. 简述</h3><h4 id="1-1-String-类"><a href="#1-1-String-类" class="headerlink" title="1.1 String 类"></a>1.1 String 类</h4><p>Java 中 字符串属于对象，Java 提供了 String 类来创建和操作字符串。String 类是不可变类，即一旦一个 String 对象被创建以后，包含在这个对象中的字符序列是不可变的，直到这个对象被销毁</p><h4 id="1-2-StringBuilder-和-StringBuffer-类"><a href="#1-2-StringBuilder-和-StringBuffer-类" class="headerlink" title="1.2 StringBuilder 和 StringBuffer 类"></a>1.2 StringBuilder 和 StringBuffer 类</h4><p>StringBuffer、StringBuilder 是 Java 的两个可变字符串类，中文意译为“字符串缓冲区”。</p><p>StringBuffer 和 StringBuilder 功能基本相似，方法也差不多。</p><p>不同之处：StringBuffer 是<code>线程安全</code>的，而 StringBuilder <code>没有实现线程安全</code>，所以 StringBuilder 的性能略高。因此在通常情况下，需要创建一个内容可变的字符串对象时，<font color="red">优先考虑使用 StringBuilder 类</font></p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><p>StringBuffer、StringBuilder、String 都实现了 <code>CharSequence </code>接口</p><blockquote><p>CharSequence 是一个定义字符串操作的接口，只包括 length()、charAt(int index)、subSequence(int start, int end) 这几个API</p></blockquote><p>三者对 CharSequence 接口的实现过程不一样：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304030911053.png" alt="image-20230403091157842"></p><p>可见，String 直接实现了 CharSequence 接口，StringBuilder 和 StringBuffer 都是可变的字符序列，它们都继承于 AbstractStringBuilder，实现了 CharSequence 接口。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>String 是 Java 中基础且重要的类，被声明为<code> final class</code>，是不可变字符串。因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。</p><p> StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列。</p><p> 在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。</p><p><strong>线程安全：</strong></p><ul><li>StringBuffer：线程安全</li><li>StringBuilder：线程不安全</li></ul><p><strong>速度：</strong></p><p>一般情况下，速度从快到慢为 <code>StringBuilder &gt; StringBuffer &gt; String</code>，当然这是相对的，不是绝对的。</p><p><strong>使用环境：</strong></p><ul><li>操作少量的数据使用 String。</li><li>单线程操作大量数据使用 StringBuilder。</li><li>多线程操作大量数据使用 StringBuffer。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的加密工具类--DigestUtils</title>
      <link href="/tur-study/2023/04/02/Spring/Spring%E7%9A%84%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7%E7%B1%BB-DigestUtils/"/>
      <url>/tur-study/2023/04/02/Spring/Spring%E7%9A%84%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7%E7%B1%BB-DigestUtils/</url>
      
        <content type="html"><![CDATA[<h2 id="一、加密算法简介"><a href="#一、加密算法简介" class="headerlink" title="一、加密算法简介"></a>一、加密算法简介</h2><p>常见的加密算法可以分成三类：</p><ul><li>对称加密算法</li><li>非对称加密算法</li><li>Hash算法</li></ul><h3 id="1-1-对称加密"><a href="#1-1-对称加密" class="headerlink" title="1.1 对称加密"></a>1.1 对称加密</h3><p>指加密和解密使用相同密钥的加密算法。对称加密算法的优点在于加解密的高速度和使用长密钥时的难破解性。</p><p>假设两个用户需要使用对称加密方法加密然后交换数据，则用户最少需要2个密钥并交换使用，如果企业内用户有n个，则整个企业共需要n×(n-1) 个密钥，密钥的生成和分发将成为企业信息部门的恶梦。对称加密算法的安全性取决于加密密钥的保存情况，但要求企业中每一个持有密钥的人都保守秘密是不可能的，他们通常会有意无意的把密钥泄漏出去——如果一个用户使用的密钥被入侵者所获得，入侵者便可以读取该用户密钥加密的所有文档，如果整个企业共用一个加密密钥，那整个企业文档的保密性便无从谈起</p><p>常见的对称加密算法：DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES</p><h3 id="1-2-非对称加密"><a href="#1-2-非对称加密" class="headerlink" title="1.2 非对称加密"></a>1.2 非对称加密</h3><p>指加密和解密使用不同密钥的加密算法，也称为公私钥加密。假设两个用户要加密交换数据，双方交换公钥，使用时一方用对方的公钥加密，另一方即可用自己的私钥解密。</p><p>如果企业中有n个用户，企业需要生成n对密钥，并分发n个公钥。由于公钥是可以公开的，用户只要保管好自己的私钥即可，因此加密密钥的分发将变得十分简单。同时，由于每个用户的私钥是唯一的，其他用户除了可以可以通过信息发送者的公钥来验证信息的来源是否真实，还可以确保发送者无法否认曾发送过该信息。非对称加密的缺点是加解密速度要远远慢于对称加密，在某些极端情况下，甚至能比非对称加密慢上1000倍。</p><p>常见的非对称加密算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）</p><h3 id="1-3-Hash算法"><a href="#1-3-Hash算法" class="headerlink" title="1.3 Hash算法"></a>1.3 Hash算法</h3><p>Hash算法特别的地方在于它是一种单向算法，用户可以通过Hash算法对目标信息生成一段特定长度的唯一的Hash值，却不能通过这个Hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。</p><p>常见的Hash算法：MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1</p><blockquote><p>加密算法的效能通常可以按照算法本身的复杂程度、密钥长度（密钥越长越安全）、加解密速度等来衡量。上述的算法中，除了DES密钥长度不够、MD2速度较慢已逐渐被淘汰外，其他算法仍在目前的加密系统产品中使用。</p></blockquote><h3 id="1-4-加密算法的选择"><a href="#1-4-加密算法的选择" class="headerlink" title="1.4 加密算法的选择"></a>1.4 加密算法的选择</h3><p>我们应该根据自己的使用特点来确定，由于非对称加密算法的运行速度比对称加密算法的速度慢很多，当我们需要加密大量的数据时，建议采用对称加密算法，提高加解密速度。</p><p>对称加密算法不能实现签名，因此签名只能非对称算法。</p><p>由于对称加密算法的密钥管理是一个复杂的过程，密钥的管理直接决定着他的安全性，因此当数据量很小时，我们可以考虑采用非对称加密算法。</p><p>在实际的操作过程中，我们通常采用的方式是：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。</p><p>如果在选定了加密算法后，那采用多少位的密钥呢？一般来说，密钥越长，运行的速度就越慢，应该根据的我们实际需要的安全级别来选择，一般来说，RSA建议采用1024位的数字，ECC建议采用160位，AES采用128为即可。</p><h2 id="二、DigestUtils-的使用"><a href="#二、DigestUtils-的使用" class="headerlink" title="二、DigestUtils 的使用"></a>二、DigestUtils 的使用</h2><h3 id="2-1-SHA256加密"><a href="#2-1-SHA256加密" class="headerlink" title="2.1 SHA256加密"></a>2.1 SHA256加密</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">String encodekey = DigestUtils.sha256Hex("测试SHA256");System.out.println(encodekey);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">6c6c0785899852543f360d1270d400f709179fc03b62bada26aa0f69a8ec7dea<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**    * Calculates the SHA-256 digest and returns the value as a hex string.    * &lt;p&gt;    * Throws a &lt;code&gt;RuntimeException&lt;/code&gt; on JRE versions prior to 1.4.0.    * &lt;/p&gt;    *     * @param data    *            Data to digest    * @return SHA-256 digest as a hex string    * @since 1.4    */   public static String sha256Hex(String data) {       return Hex.encodeHexString(sha256(data));   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-md5加密"><a href="#2-2-md5加密" class="headerlink" title="2.2 md5加密"></a>2.2 md5加密</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">String encodekey = DigestUtils.md5Hex("测试MD5");System.out.println(encodekey);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">c2dbb895a66c3ca924ccdbea49fa6884<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**     * Calculates the MD5 digest and returns the value as a 16 element &lt;code&gt;byte[]&lt;/code&gt;.     *      * @param data     *            Data to digest     * @return MD5 digest     */    public static byte[] md5(String data) {        return md5(getBytesUtf8(data));    } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该类同时提供了上述两个方法的重载方法传入的不同参数,支持的加密算法如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">   private static MessageDigest getMd5Digest() {return getDigest("MD5");}private static MessageDigest getSha256Digest() {return getDigest("SHA-256");}private static MessageDigest getSha384Digest() {return getDigest("SHA-384");}private static MessageDigest getSha512Digest() {return getDigest("SHA-512");}private static MessageDigest getShaDigest() {return getDigest("SHA");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器解析工具-UserAgentUtils</title>
      <link href="/tur-study/2023/04/02/SpringBoot/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7-UserAgentUtils/"/>
      <url>/tur-study/2023/04/02/SpringBoot/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7-UserAgentUtils/</url>
      
        <content type="html"><![CDATA[<h3 id="1-UserAgentUtils简介"><a href="#1-UserAgentUtils简介" class="headerlink" title="1. UserAgentUtils简介"></a>1. UserAgentUtils简介</h3><p>UserAgentUtils 是一个用来解析 User-Agent 字符串的 Java 类库</p><p>能够识别的内容包括：</p><ul><li>超过150种不同的浏览器；</li><li>7种不同的浏览器类型；</li><li>超过60种不同的操作系统；</li><li>6种不同的设备类型；</li><li>9种不同的渲染引擎；</li><li>9种不同的Web应用，如HttpClient、Bot。</li></ul><blockquote><p>Github主页：<a href="https://github.com/HaraldWalker/user-agent-utils">https://github.com/HaraldWalker/user-agent-utils</a></p></blockquote><h3 id="2-Maven-依赖"><a href="#2-Maven-依赖" class="headerlink" title="2. Maven 依赖"></a>2. Maven 依赖</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>eu.bitwalker<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>UserAgentUtils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.21<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">String agent=request.getHeader("User-Agent");//"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.81 Safari/537.36"//解析agent字符串UserAgent userAgent = UserAgent.parseUserAgentString(agent);//获取浏览器对象Browser browser = userAgent.getBrowser();//获取操作系统对象OperatingSystem operatingSystem = userAgent.getOperatingSystem();System.out.println("浏览器名:"+browser.getName());System.out.println("浏览器类型:"+browser.getBrowserType());System.out.println("浏览器家族:"+browser.getGroup());System.out.println("浏览器生产厂商:"+browser.getManufacturer());System.out.println("浏览器使用的渲染引擎:"+browser.getRenderingEngine());System.out.println("浏览器版本:"+userAgent.getBrowserVersion());        System.out.println("操作系统名:"+operatingSystem.getName());System.out.println("访问设备类型:"+operatingSystem.getDeviceType());System.out.println("操作系统家族:"+operatingSystem.getGroup());System.out.println("操作系统生产厂商:"+operatingSystem.getManufacturer());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出内容：</p><pre class="line-numbers language-none"><code class="language-none">浏览器名:Chrome 43浏览器类型:WEB_BROWSER浏览器家族:CHROME浏览器生产厂商:GOOGLE浏览器使用的渲染引擎:WEBKIT浏览器版本:43.0.2357.81操作系统名:Mac OS X访问设备类型:COMPUTER操作系统家族:MAC_OS_X操作系统生产厂商:APPLE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现获取客户端IP地址</title>
      <link href="/tur-study/2023/04/02/Java/Java%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AFIP%E5%9C%B0%E5%9D%80/"/>
      <url>/tur-study/2023/04/02/Java/Java%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AFIP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p> 项目开发中，在日常处理操作日志时，基本都会通过aop<a href="https://so.csdn.net/so/search?q=%E5%88%87%E9%9D%A2&amp;spm=1001.2101.3001.7020">切面</a>来实现用户操作日志的记录，但涉及到记录操作日志，想必肯定会有一项是基本都会参考记录的，那就是操作人的客户端ip地址，日后查”脏”也方便。</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><ol><li>定义一个工具类，专门用来封装 ip 相关的方法类</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IpUtils { }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>获取ip</li></ol><p>通常获取客户端的IP地址都是通过 <code>request.getRemoteAddr()</code> ，但如今基本系统都会进行域名代理等，比如通过 Apache,Squid 等反向代理软件，使用<code>getRemoteAddr() </code>根本无法再获取到客户端的真实 IP 地址了。</p><p>​    为什么加了代理就获取不到了呢？这是因为在客户端和服务之间增加了中间代理，因此服务器是无法直接拿到客户端的 IP地址，服务器端应用也无法直接通过转发请求的地址返回给客户端，基本这种获取方式就直接被pass掉了。</p><p>下面是具体获取客户端ip的方法类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** * 获取客户端ip地址 * @param request */public static String getIP(final HttpServletRequest request) throws Exception {    if (request == null) {        throw (new Exception("getIpAddr method HttpServletRequest Object is null"));    }    String ipStr = request.getHeader("x-forwarded-for");    if (StringUtils.isBlank(ipStr) || "unknown".equalsIgnoreCase(ipStr)) {        ipStr = request.getHeader("Proxy-Client-IP");    }    if (StringUtils.isBlank(ipStr) || "unknown".equalsIgnoreCase(ipStr)) {        ipStr = request.getHeader("WL-Proxy-Client-IP");    }    if (StringUtils.isBlank(ipStr) || "unknown".equalsIgnoreCase(ipStr)) {        ipStr = request.getRemoteAddr();    }     // 多个路由时，取第一个非unknown的ip    final String[] arr = ipStr.split(",");    for (final String str : arr) {        if (!"unknown".equalsIgnoreCase(str)) {            ipStr = str;            break;        }    }    //目的是将localhost访问对应的ip 0:0:0:0:0:0:0:1 转成 127.0.0.1。    return ipStr.equals("0:0:0:0:0:0:0:1") ? "127.0.0.1" : ipStr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code> 0:0:0:0:0:0:0:1</code> 是<code>[ ipv6 ]</code>的表现形式，对应<code>[ ipv4 ]</code>来说相当于<code>127.0.0.1</code>，也就是本机</p></blockquote><p>上述方法是获取客户端公网IP的方法，通过 ipconfig 本地查询到的 ipv 是内网 ip。</p><blockquote><p>公网ip的查询网站如下：<a href="https://ip.cn/">https://ip.cn/</a> 或者<a href="https://ifconfig.me/">https://ifconfig.me/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP完成系统操作日志记录</title>
      <link href="/tur-study/2023/04/02/Spring/AOP%E5%AE%8C%E6%88%90%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
      <url>/tur-study/2023/04/02/Spring/AOP%E5%AE%8C%E6%88%90%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sa-Token-SSO单点登录</title>
      <link href="/tur-study/2023/04/01/SpringBoot/Sa-Token-SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>/tur-study/2023/04/01/SpringBoot/Sa-Token-SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、单点登录简述"><a href="#一、单点登录简述" class="headerlink" title="一、单点登录简述"></a>一、单点登录简述</h2><blockquote><p>单点登录是搭建统一认证中心的关键</p></blockquote><h3 id="1-1-单点登录"><a href="#1-1-单点登录" class="headerlink" title="1.1 单点登录"></a>1.1 单点登录</h3><p>单点登录可以将一个系统的各个模块的认证授权互通共享，即用户在一个系统模块登陆之后，便可以畅通无阻的访问其他模块。简而言之，单点登录可以做到：<code>在多个互相信任的系统中，用户只需登陆一次，就可以访问所有系统</code></p><h3 id="1-2-架构选型"><a href="#1-2-架构选型" class="headerlink" title="1.2 架构选型"></a>1.2 架构选型</h3><p>Sa-Token-SSO 由简入难划分为三种模式，解决不同架构下的 SSO 接入问题：</p><table><thead><tr><th>系统架构</th><th>采用模式</th><th>简介</th><th>文档链接</th></tr></thead><tbody><tr><td>前端同域 + 后端同 Redis</td><td>模式一</td><td>共享 Cookie 同步会话</td><td><a href="https://sa-token.cc/doc.html#/sso/sso-type1">文档</a>、<a href="https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-sso1-client">示例</a></td></tr><tr><td>前端不同域 + 后端同 Redis</td><td>模式二</td><td>URL重定向传播会话</td><td><a href="https://sa-token.cc/doc.html#/sso/sso-type2">文档</a>、<a href="https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-sso2-client">示例</a></td></tr><tr><td>前端不同域 + 后端不同 Redis</td><td>模式三</td><td>Http请求获取会话</td><td><a href="https://sa-token.cc/doc.html#/sso/sso-type3">文档</a>、<a href="https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-sso3-client">示例</a></td></tr></tbody></table><ol><li>前端同域：就是指多个系统可以部署在同一个主域名之下，比如：<code>c1.domain.com</code>、<code>c2.domain.com</code>、<code>c3.domain.com</code>。</li><li>后端同Redis：就是指多个系统可以连接同一个Redis。PS：这里并不需要把所有项目的数据都放在同一个Redis中，Sa-Token提供了 <strong><code>[权限缓存与业务缓存分离]</code></strong> 的解决方案，详情戳： <a href="https://sa-token.cc/doc.html#/plugin/alone-redis">Alone独立Redis插件</a>。</li><li>如果既无法做到前端同域，也无法做到后端同Redis，那么只能走模式三，Http请求获取会话（Sa-Token对SSO提供了完整的封装，只需要按照示例从文档上复制几段代码便可以轻松集成）。</li></ol><h3 id="1-3-Sa-Token-SSO-特性"><a href="#1-3-Sa-Token-SSO-特性" class="headerlink" title="1.3 Sa-Token-SSO 特性"></a>1.3 Sa-Token-SSO 特性</h3><ol><li>API 简单易用，文档介绍详细，且提供直接可用的集成示例。</li><li>支持三种模式，不论是否跨域、是否共享Redis、是否前后端分离，都可以完美解决。</li><li>安全性高：内置域名校验、Ticket校验、秘钥校验等，杜绝<code>Ticket劫持</code>、<code>Token窃取</code>等常见攻击手段</li><li>不丢参数：Sa-Token-SSO内有专门的算法保证了参数不丢失，登录成功之后原路返回页面。</li><li>无缝集成：由于Sa-Token本身就是一个权限认证框架，因此可以只用一个框架同时解决<code>权限认证</code> + <code>单点登录</code>问题，让你不再到处搜索：xxx单点登录与xxx权限认证如何整合……</li><li>高可定制：Sa-Token-SSO模块对代码架构侵入性极低，结合Sa-Token本身的路由拦截特性，可以非常轻松的定制化开发。</li></ol><p>下面记录 SSO 单点登录相关步骤：</p><h2 id="二、搭建统一认证中心-SSO-Server"><a href="#二、搭建统一认证中心-SSO-Server" class="headerlink" title="二、搭建统一认证中心 SSO-Server"></a>二、搭建统一认证中心 SSO-Server</h2><p>开始 SSO 对接之前，需要先搭建一个 SSO-Server 认证中</p><p>步骤如下：</p><h3 id="2-1-添加依赖"><a href="#2-1-添加依赖" class="headerlink" title="2.1 添加依赖"></a>2.1 添加依赖</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 权限认证，在线文档：https://sa-token.cc --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token 插件：整合SSO --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-sso<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token 整合 Redis (使用 jackson 序列化方式) --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-dao-redis-jackson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 线程池  --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 视图引擎（在前后端不分离模式下提供视图支持） --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-thymeleaf<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Http请求工具（在模式三的单点注销功能下用到，如不需要可以注释掉） --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.dtflys.forest<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>forest-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.5.26<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-开放认证接口"><a href="#2-2-开放认证接口" class="headerlink" title="2.2 开放认证接口"></a>2.2 开放认证接口</h3><p>开放认证接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Sa-Token-SSO Server端 Controller  */@RestControllerpublic class SsoServerController {    /*     * SSO-Server端：处理所有SSO相关请求 (下面的章节我们会详细列出开放的接口)      */    @RequestMapping("/sso/*")    public Object ssoRequest() {        return SaSsoProcessor.instance.serverDister();    }    /**     * 配置SSO相关参数      */    @Autowired    private void configSso(SaSsoConfig sso) {        // 配置：未登录时返回的View         sso.setNotLoginView(() -&gt; {            String msg = "当前会话在SSO-Server端尚未登录，请先访问"                    + "&lt;a href='/sso/doLogin?name=sa&amp;pwd=123456' target='_blank'&gt; doLogin登录 &lt;/a&gt;"                    + "进行登录之后，刷新页面开始授权";            return msg;        });        // 配置：登录处理函数         sso.setDoLoginHandle((name, pwd) -&gt; {            // 此处仅做模拟登录，真实环境应该查询数据进行登录             if("sa".equals(name) &amp;&amp; "123456".equals(pwd)) {                StpUtil.login(10001);                return SaResult.ok("登录成功！").setData(StpUtil.getTokenValue());            }            return SaResult.error("登录失败！");        });        // 配置 Http 请求处理器 （在模式三的单点注销功能下用到，如不需要可以注释掉）         sso.setSendHttp(url -&gt; {            try {                // 发起 http 请求                 System.out.println("------ 发起请求：" + url);                return Forest.get(url).executeAsString();            } catch (Exception e) {                e.printStackTrace();                return null;            }        });    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==注意：==</p><ul><li>在<code>setDoLoginHandle</code>函数里如果要获取name, pwd以外的参数，可通过<code>SaHolder.getRequest().getParam("xxx")</code>来获取 </li><li>在 <code>setSendHttp</code> 函数中，使用 <code>try-catch</code> 是为了提高整个注销流程的容错性，避免在一些极端情况下注销失败（例如：某个 Client 端上线之后又下线，导致 http 请求无法调用成功，从而阻断了整个注销流程）</li></ul><p>全局异常处理：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestControllerAdvicepublic class GlobalExceptionHandler {    // 全局异常拦截     @ExceptionHandler    public SaResult handlerException(Exception e) {        e.printStackTrace();         return SaResult.error(e.getMessage());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-application-yml-配置"><a href="#2-3-application-yml-配置" class="headerlink" title="2.3 application.yml 配置"></a>2.3 application.yml 配置</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 端口server:    port: 8800# Sa-Token 配置sa-token:     # ------- SSO-模式一相关配置  (非模式一不需要配置)     # cookie:         # 配置 Cookie 作用域         # domain: stp.com     # ------- SSO-模式二相关配置     sso:         # Ticket有效期 (单位: 秒)，默认五分钟         ticket-timeout: 300        # 所有允许的授权回调地址        allow-url: "*"        # 是否打开单点注销功能        is-slo: true        # ------- SSO-模式三相关配置 （下面的配置在SSO模式三并且 is-slo=true 时打开）        # 是否打开模式三         isHttp: true        # 接口调用秘钥（用于SSO模式三的单点注销功能）        secretkey: kQwIOrYvnXmSDkwEiFngrKidMcdrgKor        # ---- 除了以上配置项，你还需要为 Sa-Token 配置http请求处理器（文档有步骤说明） spring:     # Redis配置 （SSO模式一和模式二使用Redis来同步会话）    redis:        # Redis数据库索引（默认为0）        database: 1        # Redis服务器地址        host: 127.0.0.1        # Redis服务器连接端口        port: 6379        # Redis服务器连接密码（默认为空）        password: forest:     # 关闭 forest 请求日志打印    log-enabled: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>==注意：==</p><p><code>sa-token.sso.allow-url</code>为了方便测试配置为<code>*</code>，线上生产环境一定要配置为详细URL地址 </p></blockquote><h3 id="2-4-启动类"><a href="#2-4-启动类" class="headerlink" title="2.4 启动类"></a>2.4 启动类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@SpringBootApplication@MapperScan("com.blog.mapper")public class WebApplication {    public static void main(String[] args) {        SpringApplication.run(WebApplication.class, args);        log.info("\n---------Sa-Token-SSO认证中心启动成功");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动项目后：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020759417.png" alt="image-20230402075945152"></p><p>访问统一授权地址：（具体访问路径依据实际情况自己设定）</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020800521.png" alt="image-20230402080039458"></p><h2 id="三、SSO模式一：共享Cookie同步会话"><a href="#三、SSO模式一：共享Cookie同步会话" class="headerlink" title="三、SSO模式一：共享Cookie同步会话"></a>三、SSO模式一：共享Cookie同步会话</h2><blockquote><p>如果多个系统可以做到：前端同域，后端同Redis，便可以用 <code>共享Cookie同步会话</code> 的方式做到单点登录</p></blockquote><h3 id="3-1-解决思路"><a href="#3-1-解决思路" class="headerlink" title="3.1 解决思路"></a>3.1 解决思路</h3><p>多个系统之间为什么无法同步登录状态？</p><ol><li>前端的 <code>Token </code>无法在多个系统下共享</li><li>后端的 <code>Session </code>无法在多个系统间共享</li></ol><p>对于上述原因，单点登录有如下方法解决：</p><ol><li>使用 <code>共享Cookie</code> 来解决  Token 共享问题</li><li>使用 <code>Redis </code>来解决Session 共享问题</li></ol><p><strong>共享Cookie</strong></p><p>共享Cookie就是主域名Cookie在二级域名下的共享</p><p>示例：写在父域名<code>stp.com</code>下的Cookie，在<code>s1.stp.com</code>、<code>s2.stp.com</code>等子域名都是可以共享访问的。</p><p><strong>共享Redis</strong></p><p>共享Redis，并不需要我们把所有项目的数据都放在同一个Redis中，Sa-Token提供了 <strong>[权限缓存与业务缓存分离]</strong> 的解决方案</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020816900.png" alt="image-20230402081618844"></p><h3 id="3-2-准备工作"><a href="#3-2-准备工作" class="headerlink" title="3.2 准备工作"></a>3.2 准备工作</h3><p>修改hosts 文件<code>(C:\windows\system32\drivers\etc\hosts)</code>，添加以下IP映射，方便测试</p><pre class="line-numbers language-uri" data-language="uri"><code class="language-uri">127.0.0.1 sso.stp.com127.0.0.1 s1.stp.com127.0.0.1 s2.stp.com127.0.0.1 s3.stp.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中：<code>sso.stp.com</code>为统一认证中心地址，当用户在其它 Client 端发起登录请求时，均将其重定向至认证中心，待到登录成功之后再原路返回到 Client 端</p><h3 id="3-3-指定-Cookie-的作用域"><a href="#3-3-指定-Cookie-的作用域" class="headerlink" title="3.3 指定 Cookie 的作用域"></a>3.3 指定 Cookie 的作用域</h3><p>在<code>sso.stp.com</code>访问服务器，其Cookie也只能写入到<code>sso.stp.com</code>下，为了将Cookie写入到其父级域名<code>stp.com</code>下，我们需要更改 SSO-Server 端的 yml 配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">sa-token:     cookie:         # 配置 Cookie 作用域         domain: stp.com <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-搭建-Client-端项目"><a href="#3-4-搭建-Client-端项目" class="headerlink" title="3.4 搭建 Client 端项目"></a>3.4 搭建 Client 端项目</h3><h5 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 权限认证, 在线文档：https://sa-token.cc --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token 插件：整合SSO --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-sso<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token 整合redis (使用jackson序列化方式) --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-dao-redis-jackson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token插件：权限缓存与业务缓存分离 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-alone-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-新建-Controller-控制器"><a href="#2-新建-Controller-控制器" class="headerlink" title="2. 新建 Controller 控制器"></a>2. 新建 Controller 控制器</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Sa-Token-SSO Client端 Controller  * @author kong */@RestControllerpublic class SsoClientController {    // SSO-Client端：首页     @RequestMapping("/")    public String index() {        String authUrl = SaSsoManager.getConfig().splicingAuthUrl();        String solUrl = SaSsoManager.getConfig().splicingSloUrl();        String str = "&lt;h2&gt;Sa-Token SSO-Client 应用端&lt;/h2&gt;" +                     "&lt;p&gt;当前会话是否登录：" + StpUtil.isLogin() + "&lt;/p&gt;" +                     "&lt;p&gt;&lt;a href=\"javascript:location.href='" + authUrl + "?mode=simple&amp;redirect=' + encodeURIComponent(location.href);\"&gt;登录&lt;/a&gt; " +                     "&lt;a href=\"javascript:location.href='" + solUrl + "?back=' + encodeURIComponent(location.href);\"&gt;注销&lt;/a&gt; &lt;/p&gt;";        return str;    }    // 全局异常拦截     @ExceptionHandler    public SaResult handlerException(Exception e) {        e.printStackTrace();         return SaResult.error(e.getMessage());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-application-yml-配置"><a href="#3-application-yml-配置" class="headerlink" title="3. application.yml 配置"></a>3. application.yml 配置</h5><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 端口server:    port: 9001# Sa-Token 配置 sa-token:     # SSO-相关配置    sso:         # SSO-Server端-单点登录授权地址         auth-url: http://sso.stp.com:9000/sso/auth        # SSO-Server端-单点注销地址        slo-url: http://sso.stp.com:9000/sso/signout    # 配置 Sa-Token 单独使用的Redis连接 （此处需要和SSO-Server端连接同一个Redis）    alone-redis:         # Redis数据库索引        database: 1        # Redis服务器地址        host: 127.0.0.1        # Redis服务器连接端口        port: 6379        # Redis服务器连接密码（默认为空）        password:         # 连接超时时间        timeout: 10s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-启动类"><a href="#4-启动类" class="headerlink" title="4. 启动类"></a>4. 启动类</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * SSO模式一，Client端 Demo  */@SpringBootApplicationpublic class SaSso1ClientApplication {    public static void main(String[] args) {        SpringApplication.run(SaSso1ClientApplication.class, args);        System.out.println("\nSa-Token SSO模式一 Client端启动成功");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-访问测试"><a href="#5-访问测试" class="headerlink" title="5. 访问测试"></a>5. 访问测试</h5><p>启动client端和server端，访问 <code>http://s1.stp.com:9001</code></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020851161.png" alt="image-20230402085133074"></p><p>点击登录，重定向至认证中心：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020852328.png" alt="image-20230402085201271"></p><p>点击登录后再刷新页面：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020853616.png" alt="image-20230402085306565"></p><p>刷新另外两个Client端，均显示已登录 </p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020853412.png" alt="sso1-login-ok2.png"></p><p>测试完成 </p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Sa-Token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java正则</title>
      <link href="/tur-study/2023/04/01/Java/Java%E6%AD%A3%E5%88%99/"/>
      <url>/tur-study/2023/04/01/Java/Java%E6%AD%A3%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="一、正则表达式"><a href="#一、正则表达式" class="headerlink" title="一、正则表达式"></a>一、正则表达式</h2><h3 id="1-1-特殊字符"><a href="#1-1-特殊字符" class="headerlink" title="1.1 特殊字符"></a>1.1 特殊字符</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011503699.png" alt="image-20230401150341463"></p><h3 id="1-2-限定符"><a href="#1-2-限定符" class="headerlink" title="1.2 限定符"></a>1.2 限定符</h3><p>限定符用来指针正则表达式的一个给定组件必须要出现次才能满足适配，有 <code>*、+、?、{n}、{n,}、{n, m}</code>共六种</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011505216.png" alt="image-20230401150555170"></p><p>示例：以下正则表达式匹配一个正整数，<code>[1-9]</code>设置第一个数字不是0，<code>[0-9]* </code>表示任意多个数字：</p><pre class="line-numbers language-none"><code class="language-none">/[1-9][0-9]*/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二、Pattern-类和-Matcher-类"><a href="#二、Pattern-类和-Matcher-类" class="headerlink" title="二、Pattern 类和 Matcher 类"></a>二、Pattern 类和 Matcher 类</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>Pattern 对象是正则表达式编译后再内存中的表现形式。即正则表达式字符串必须先被编译为 Pattern 对象，然后再利用该 Pattern 对象创建对应的 Matcher 对象</p><p>Matcher 对象保留匹配的结果，多个 Matcher 对象可共享同一个 Pattern 对象</p><h3 id="2-Pattern-类常用方法"><a href="#2-Pattern-类常用方法" class="headerlink" title="2. Pattern 类常用方法"></a>2. Pattern 类常用方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 将一个字符串编译成 Pattern 对象Pattern pattern = Pattern.compile("a*c");// 使用 Pattern 对象创建 Matcher 对象Matcher matcher = pattern.matcher("abc");// 返回 trueboolean result = matcher.matches();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面定义的 Pattern 对象可以多次重复使用。如果某个正则表达式仅需一次使用，则可直接使用 Pattern 类的静态 <code>matches()</code>方法，此方法自动把指定字符串编译成匿名的 Pattern 对象，并执行匹配，代码如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 返回 trueboolean result = Pattern.matches ("a*c","abc");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-Matcher-类常用方法"><a href="#3-Matcher-类常用方法" class="headerlink" title="3. Matcher 类常用方法"></a>3. Matcher 类常用方法</h3><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">find()</td><td align="center">返回目标字符串中是否包含与 Pattern 匹配的子串</td></tr><tr><td align="center">group()</td><td align="center">返回上一次与 Pattern 匹配的子串</td></tr><tr><td align="center">start()</td><td align="center">返回上一次与 Pattern 匹配的子串在目标字符串中的开始位置</td></tr><tr><td align="center">end()</td><td align="center">返回上一次与 Pattern 匹配的子串在目标字符串中的结束位置加 1</td></tr><tr><td align="center">lookingAt()</td><td align="center">返回目标字符串前面部分与 Pattern 是否匹配</td></tr><tr><td align="center">matches()</td><td align="center">返回整个目标字符串与 Pattern 是否匹配</td></tr><tr><td align="center">reset()</td><td align="center">将现有的 Matcher 对象应用于一个新的字符序列。</td></tr></tbody></table><h4 id="3-1-find-和-group-方法"><a href="#3-1-find-和-group-方法" class="headerlink" title="3.1 find() 和 group() 方法"></a>3.1 find() 和 group() 方法</h4><p>通过 Matcher 类的 <code>find()</code> 和 <code>group()</code> 方法可以从目标字符串中依次取出特定子串（匹配正则表达式的子串），例如互联网的网络爬虫，它们可以自动从网页中识别出所有的电话号码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test{    public static void main(String[] args)    {        // 使用字符串模拟从网络上得到的网页源码        String str = "出售JAVA教程，联系电话：13600000001" + "毕业代做，联系电话：13600000002" + "出售二手电脑，联系电话：15800000001";        // 创建一个Pattern对象，并用它建立一个Matcher对象        // 该正则表达式只抓取13X和15X段的手机号        // 实际要抓取哪些电话号码，只要修改正则表达式即可        Matcher m = Pattern.compile("((13\\d)|(15\\d))\\d{8}").matcher(str);        // 将所有符合正则表达式的子串（电话号码）全部输出        while (m.find())        {            System.out.println(m.group());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面运行结果可以看出，<code>find()</code> 方法依次查找字符串中与 Pattern 匹配的子串，一旦找到对应的子串，下次调用 <code>find()</code> 方法时将接着向下查找。</p><h4 id="3-2-start-和-end-方法"><a href="#3-2-start-和-end-方法" class="headerlink" title="3.2 start() 和 end() 方法"></a>3.2 start() 和 end() 方法</h4><p><code>find()</code> 方法还可以传入一个 int 类型的参数，带 int 参数的 <code>find()</code> 方法将从该 int 索引处向下搜索。<code>start()</code> 和 <code>end() </code>方法主要用于确定子串在目标字符串中的位置，如下程序所示。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test2{    public static void main(String[] args)    {        // 创建一个Pattern对象，并用它建立一个Matcher对象        String regStr = "Java is very easy!";        System.out.println("目标字符串是：" + regStr);        Matcher m = Pattern.compile("\\w+").matcher(regStr);        while (m.find())        {            System.out.println(m.group() + "子串的起始位置：" + m.start() + "，其结束位置：" + m.end());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面程序使用 <code>find()</code>、<code>group()</code> 方法逐项取出目标字符串中与指定正则表达式匹配的子串，并使用<code>start()</code>、<code>end()</code> 方法返回子串在目标字符串中的位置。运行上面程序，看到如下运行结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">目标字符串是：Java is very easy!Java子串的起始位置：0，其结束位置：4is子串的起始位置：5，其结束位置：7very子串的起始位置：8，其结束位置：12easy子串的起始位置：13，其结束位置：17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-matches-和-LookingAt-方法"><a href="#3-3-matches-和-LookingAt-方法" class="headerlink" title="3.3 matches() 和 LookingAt() 方法"></a>3.3 matches() 和 LookingAt() 方法</h4><p><code>matches()</code> 和 <code>lookingAt()</code> 方法有点相似，只是 <code>matches()</code> 方法要求整个字符串和 Pattern 完全匹配时才返回 <code>true</code>，而 <code>lookingAt()</code> 只要字符串以 Pattern 开头就会返回 <code>true</code>。<code>reset()</code> 方法可将现有的 Matcher 对象应用于新的字符序列：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test3{    public static void main(String[] args)    {        String[] mails =        { "mymail@163.com", "mymail@gmail.com", "mymail@myweb.org", "mymail@abc.xx" };        String mailRegEx = "\\w{3,20}@\\w+\\.(com|org|cn|net|gov)";        Pattern mailPattern = Pattern.compile(mailRegEx);        Matcher matcher = null;        for (String mail : mails)        {            if (matcher == null)            {                matcher = mailPattern.matcher(mail);            }            else            {                matcher.reset(mail);            }            String result = mail + (matcher.matches() ? "是" : "不是") + "一个有效的邮件地址！";            System.out.println(result);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面程序创建了一个邮件地址的 Pattern，接着用这个 Pattern 与多个邮件地址进行匹配。当程序中的 Matcher 为 <code>null</code> 时，程序调用 <code>matcher()</code> 方法来创建一个 Matcher 对象，一旦 Matcher 对象被创建，程序就调用 Matcher 的 <code>reset()</code> 方法将该 Matcher 应用于新的字符序列。</p><p>从某个角度来看，Matcher 的 <code>matches()</code>、<code>lookingAt()</code> 和 String 类的 <code>equals()</code> 有点相似。区别是 String 类的 <code>equals()</code> 都是与字符串进行比较，而 Matcher 的 <code>matches()</code> 和 <code>lookingAt()</code> 则是与正则表达式进行匹配。</p><p>事实上，String 类里也提供了 <code>matches()</code> 方法，该方法返回该字符串是否匹配指定的正则表达式。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">"mymail@163.com".matches("\\w{3,20}@\\w+\\.(com|org|cn|net|gov)"); // 返回 true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><h3 id="3-1-匹配数字"><a href="#3-1-匹配数字" class="headerlink" title="3.1 匹配数字"></a>3.1 匹配数字</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * \d 的含义是 [0-9] * \D 的含义是 [^0-9] * {n} 匹配确定 n 次 */public static void matchNumber() {        Pattern p = Pattern.compile("summary_day\\.\\d+[0-9]\\.\\d{17}");        Matcher m = p.matcher("ipva.summary_day.20210621.20210622000205860.B20C41AB-0A17-46DB-9177-817533B8E551.1624291336921.txt");        System.out.println(m.pattern()); //myArray\[\d\]        while (m.find()){            System.out.println(m.group());        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011519329.png" alt="image-20230401151914278"></p><h3 id="3-2-匹配字母"><a href="#3-2-匹配字母" class="headerlink" title="3.2 匹配字母"></a>3.2 匹配字母</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * \w 任何一个字母数字字符（大小写均可）或下划线，等价于 [A-Za-z0-9_] * \W 表示[^A-Za-z0-9_] * + 匹配前面的子表达式或一次或多次 */public static void matchAlphanum() {        Pattern pattern = Pattern.compile("^ipva\\.\\w+");        Matcher matcher = pattern.matcher("ipva.summary_day.20210621.20210622000205860.B20C41AB-0A17-46DB-9177-817533B8E551.1624291336921.txt");        while (matcher.find()) {            System.out.println(matcher.group(0));        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011520210.png" alt="image-20230401152003168"></p><h3 id="3-3-特殊字符一"><a href="#3-3-特殊字符一" class="headerlink" title="3.3 特殊字符一"></a>3.3 特殊字符一</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * "*" 表示含有零个或者多个 * "+" 匹配前面的子表达式或一次或多次 */public static void matchRepeat() {    Pattern pattern = Pattern.compile("\\w+[\\w\\.]*@[\\d]+\\.\\w+");    Matcher matcher = pattern.matcher("Hello .kangll@163.com is my email address.");    while (matcher.find()) {        System.out.println(matcher.group(0));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011521053.png" alt="image-20230401152153010"></p><h3 id="3-4-特殊字符二"><a href="#3-4-特殊字符二" class="headerlink" title="3.4 特殊字符二"></a>3.4 特殊字符二</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * "*" 表示含有零个或者多个 * "+" 表示匹配前面的子表达式或一次或多次 * "?" 表示匹配零个或者一个字符 */public static void matchRepeat02() {    Pattern pattern = Pattern.compile("http[s]?://[\\w\\.]+");    Matcher matcher = pattern.matcher("The URL is http://www.kangll.com/");    while (matcher.find()) {        System.out.println(matcher.group(0));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011522577.png" alt="image-20230401152240532"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolTaskExecutor的使用</title>
      <link href="/tur-study/2023/04/01/SpringBoot/ThreadPoolTaskExecutor%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/04/01/SpringBoot/ThreadPoolTaskExecutor%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、线程池简介"><a href="#一、线程池简介" class="headerlink" title="一、线程池简介"></a>一、线程池简介</h2><h3 id="1-1-为什么使用线程池"><a href="#1-1-为什么使用线程池" class="headerlink" title="1.1 为什么使用线程池"></a>1.1 为什么使用线程池</h3><ul><li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗</li><li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建，便能立即执行</li><li>方便线程并发数的管控，因为线程若是无限制的创建，可能会导致内存占用过多而产生 <code>OOM</code>，并且会造成 <code>cpu </code>过度切换</li></ul><blockquote><ul><li><p><code>OOM</code>：Out of Memory，内存溢出，即内存不够了。详细见：<a href="https://blog.csdn.net/lovedingd/article/details/104650249/">https://blog.csdn.net/lovedingd/article/details/104650249/</a></p></li><li><p>cpu切换线程有时间成本，需要保持当前执行线程的现场，并恢复要执行线程的现场</p></li></ul></blockquote><ul><li>提供更强大的功能，延时定时线程池</li></ul><h3 id="1-2-线程池需要使用队列的原因"><a href="#1-2-线程池需要使用队列的原因" class="headerlink" title="1.2 线程池需要使用队列的原因"></a>1.2 线程池需要使用队列的原因</h3><p>线程若是无限制创建，可能会导致<code>内存</code>占用过多而产生 <code>OOM</code>，并且会造成<code>cpu</code>过度切换，创建线程池的消耗较高或者线程池创建线程需要获取 <code>mainlock </code>这个全局锁，影响并发效率，阻塞队列可以很好的缓冲</p><h3 id="1-3-线程池使用阻塞队列的原因"><a href="#1-3-线程池使用阻塞队列的原因" class="headerlink" title="1.3 线程池使用阻塞队列的原因"></a>1.3 线程池使用阻塞队列的原因</h3><p><code>阻塞队列</code>可以保证任务队列中没有任务时阻塞获取任务的线程，是的线程进入 <code>wait</code> 状态，释放 <code>cpu </code>资源，当队列中有任务时才唤醒对应线程，从队列中取出消息进行执行，使得线程不至于一直占用 <code>cpu </code>资源</p><blockquote><p>线程执行完任务后通过循环再次从任务队列中取出任务进行执行，代码片段如：<code>while(task != null || (task = getTask()) != null){}</code></p></blockquote><p>不用阻塞队列也是可以的，不过实现起来比较麻烦。</p><h3 id="1-4-线程池的配置"><a href="#1-4-线程池的配置" class="headerlink" title="1.4 线程池的配置"></a>1.4 线程池的配置</h3><h5 id="1-CPU密集型任务"><a href="#1-CPU密集型任务" class="headerlink" title="1. CPU密集型任务"></a>1. CPU密集型任务</h5><p>尽量使用较小的线程池，一般为 <code>CPU </code>核心数 <code>+1</code>，因为 <code>CPU </code>密集型任务使得 <code>CPU </code>使用率较高，若是开过多的线程数，会造成 <code>CPU </code>付过度切换</p><h5 id="2-IO-密集型任务"><a href="#2-IO-密集型任务" class="headerlink" title="2. IO 密集型任务"></a>2. IO 密集型任务</h5><p>可以使用稍大的线程池，一般为 <code>2*CPU</code> 核心数。<code>IO </code>密集型任务 <code>CPU </code>使用率并不高，因此可以让 <code>CPU </code>在等待 <code>IO </code>的时候有其他线程去处理别的任务，充分利用 <code>CPU </code>时间</p><h5 id="3-混合型任务"><a href="#3-混合型任务" class="headerlink" title="3. 混合型任务"></a>3. 混合型任务</h5><p>可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效<br>因为如果划分之后两个任务执行时间有数据级的差距，那么拆分没有意义。<br>因为先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失</p><h3 id="1-5-execute-和-submit-方法"><a href="#1-5-execute-和-submit-方法" class="headerlink" title="1.5 execute() 和 submit() 方法"></a>1.5 execute() 和 submit() 方法</h3><ul><li><code>execute()</code>：执行一个任务，没有返回值</li><li><code>submit()</code>，提交一个线程任务，有返回值</li></ul><p>submit(Callable<t> task)能获取到它的返回值，通过future.get()获取（阻塞直到任务执行完）。一般使用FutureTask+Callable配合使用<br>submit(Runnable task, T result)能通过传入的载体result间接获得线程的返回值。<br>submit(Runnable task)则是没有返回值的，就算获取它的返回值也是null</t></p><p>Future.get()方法会使取结果的线程进入阻塞状态，直到线程执行完成之后，唤醒取结果的线程，然后返回结果</p><h2 id="二、Spring-线程池"><a href="#二、Spring-线程池" class="headerlink" title="二、Spring 线程池"></a>二、Spring 线程池</h2><h3 id="2-1-Spring-线程池种类"><a href="#2-1-Spring-线程池种类" class="headerlink" title="2.1 Spring 线程池种类"></a>2.1 Spring 线程池种类</h3><h4 id="1-Spring-线程池的使用"><a href="#1-Spring-线程池的使用" class="headerlink" title="1. Spring 线程池的使用"></a>1. Spring 线程池的使用</h4><ul><li>Spring 通过任务执行器<code>TaskExecutor</code> 来实现多线程和并发</li><li>使用 <code>ThreadPoolTaskExecutor</code> 实现一个基于线程池的 <code>TaskExecutor</code></li><li>使用 <code>@EnableAsync</code> 开启异步，并通过在需要异步的方法上使用注解 <code>@Async</code> 声明是一个异步任务</li></ul><h4 id="2-Spring-已经实现的异常线程池："><a href="#2-Spring-已经实现的异常线程池：" class="headerlink" title="2. Spring 已经实现的异常线程池："></a>2. Spring 已经实现的异常线程池：</h4><ul><li><code>SimpleAsyncTaskExecutor</code>：不是真的线程池，这个类不重用线程，每次调用都会创建一个新的线程。</li><li><code>SyncTaskExecutor</code>：这个类没有实现异步调用，只是一个同步操作。只适用于不需要多线程的地方</li><li><code>ConcurrentTaskExecutor</code>：<code>Executor</code>的适配类，不推荐使用。如果<code>ThreadPoolTaskExecutor</code>不满足要求时，才用考虑使用这个类</li><li><code>SimpleThreadPoolTaskExecutor</code>：是<code>Quartz</code>的<code>SimpleThreadPool</code>的类。线程池同时被<code>quartz</code>和<code>非quartz</code>使用，才需要使用此类</li><li><code>ThreadPoolTaskExecutor </code>：最常使用，推荐。 其实质是对<code>java.util.concurrent.ThreadPoolExecutor</code>的包装</li></ul><h3 id="2-2-ThreadPoolTaskExecutor的使用"><a href="#2-2-ThreadPoolTaskExecutor的使用" class="headerlink" title="2.2 ThreadPoolTaskExecutor的使用"></a>2.2 ThreadPoolTaskExecutor的使用</h3><h4 id="1-线程池配置类"><a href="#1-线程池配置类" class="headerlink" title="1. 线程池配置类"></a>1. 线程池配置类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@EnableAsync # 开启异步public class TaskExecuteConfig {    @Value("task.executor.core_pool_size")    private int corePoolSize;    @Value("task.executor.max_pool_size")    private int maxPoolSize;    @Value("task.executor.queue_capacity")    private int queueCapacity;    @Value("task.executor.keep_alive_seconds")    private long keepAliveSeconds;    @Bean(name = "threadPoolTaskExecutor")    public ThreadPoolTaskExecutor SendTaskExecutor(){        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();        // 配置核心线程数        executor.setCorePoolSize(corePoolSize);        //最大线程数        executor.setMaxPoolSize(maxPoolSize);        // 队列大小        executor.setQueueCapacity(queueCapacity);        // 线程池维护线程所允许的空闲时间，单位秒，超过则销毁        // 线程池线程数量大于corePoolSize时，多出来的空闲线程，多长时间会被销毁        executor.setKeepAliveSeconds(keepAliveSeconds);        // 配置线程池中的线程名称前缀        executor.setThreadNamePrefix("pool-send-task-executor");        // 线程池拒绝策略        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());        executor.initialize();        return executor;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置类中方法说明：</p><ul><li><code>corePoolSize</code>:线程池维护线程的最小数量</li><li><code>maxPoolSize</code>:线程池维护线程的最大数量，线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值。如果队列中任务已满，并且当前线程个数小于maxPoolSize，那么会创建新的线程来执行任务。</li><li><code>keepAliveSeconds</code>:空闲线程的存活时间，单位秒</li><li><code>queueCapacity</code>：持有等待执行的任务队列，一个阻塞队列，用来存储等待执行的任务，当线程池中的线程数超过它的<code>corePoolSize</code>的时候，线程会进入阻塞队列进行阻塞等待</li><li><code>RejectedExecutionHandler handler</code>： 线程池的拒绝策略，是指当任务添加到线程池中被拒绝，而采取的处理措施。<br>当任务添加到线程池中之所以被拒绝，可能是由于：第一，线程池异常关闭。第二，任务数量超过线程池的最大限制。</li></ul><blockquote><p>Reject 策略预定义有如下四种：</p><ol><li><code>ThreadPoolExecutor.AbortPolicy</code>策略，是默认的策略,处理程序遭到拒绝将抛出运行时 RejectedExecutionException</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>策略 ,调用者的线程会执行该任务,如果执行器已关闭,则丢弃.</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>策略，不能执行的任务将被丢弃.</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>策略，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）</li><li>自定义策略：当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务</li></ol></blockquote><h4 id="2-异步方法"><a href="#2-异步方法" class="headerlink" title="2. 异步方法"></a>2. 异步方法</h4><p><code>@Async</code>注解可以用在方法上，表示该方法是个异步方法，也可以用在类上，那么表示此类的所有方法都是异步方法2 异步方法会自动注入使用<code>ThreadPoolTaskExecutor</code>作为<code>TaskExecutor</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class AsyncTaskService {    @Async    public void executeAsync(Integer i) throws Exception{        System.out.println("线程ID：" + Thread.currentThread().getId() + "线程名字：" +Thread.currentThread().getName()+"执行异步任务:" + i);    }    @Async    public Future&lt;String&gt; executeAsyncPlus(Integer i) throws Exception {        System.out.println("线程ID：" + Thread.currentThread().getId() +"线程名字：" +Thread.currentThread().getName()+ "执行异步有返回的任务:" + i);        return new AsyncResult&lt;&gt;("success:"+i);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Redis</title>
      <link href="/tur-study/2023/03/31/Redis/SpringBoot%E6%95%B4%E5%90%88Redis/"/>
      <url>/tur-study/2023/03/31/Redis/SpringBoot%E6%95%B4%E5%90%88Redis/</url>
      
        <content type="html"><![CDATA[<p><code>SpringBoot </code>中对 <code>Redis </code>的集成模块为 <code>SpringDataRedis</code>。官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li><p>提供了对不同Redis客户端的整合（<code>Lettuce</code>和<code>Jedis</code>）</p></li><li><p>提供了<code>RedisTemplate</code>统一API来操作Redis</p></li><li><p>支持Redis的发布订阅模型</p></li><li><p>支持Redis哨兵和Redis集群</p></li><li><p>支持基于<code>Lettuce</code>的响应式编程</p></li><li><p>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</p></li><li><p>支持基于Redis的<code>JDKCollection</code>实现</p></li></ul><h3 id="1-SpringDataRedis-的基本使用"><a href="#1-SpringDataRedis-的基本使用" class="headerlink" title="1. SpringDataRedis 的基本使用"></a>1. SpringDataRedis 的基本使用</h3><p><code>SpringDataRedis </code>中提供了 <code>RedisTemplate </code>工具类，其中封装了各种对 Redis 的操作，并且将不同数据类型的操作 API 封装到了不同的类型中</p><table><thead><tr><th align="center">API</th><th align="center">返回值类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">redisTemplate.opsForValue()</td><td align="center">ValueOperations</td><td align="center">操作 String 类型数据</td></tr><tr><td align="center">redisTemplate.opsForHash()</td><td align="center">HashOperations</td><td align="center">操作 Hash 类型数据</td></tr><tr><td align="center">redisTemplate.opsForList()</td><td align="center">ListOperations</td><td align="center">操作 List 类型数据</td></tr><tr><td align="center">redisTemplate.opsForSet()</td><td align="center">SetOperations</td><td align="center">操作 Set 类型数据</td></tr><tr><td align="center">redisTemplate.opsForZSet()</td><td align="center">ZSetOperations</td><td align="center">操作 ZSet 类型数据</td></tr><tr><td align="center">redisTemplate</td><td align="center"></td><td align="center">通用命令</td></tr></tbody></table><p>SpringDataRedis 的使用步骤如下：</p><ul><li>引入 <code>spring-boot-starter-data-redis</code> 依赖</li><li>在 <code>application.yml</code> 中配置 Redis 信息</li><li>注入 <code>RedisTemplate </code></li></ul><h5 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Redis依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 连接池依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-对-Redis-进行配置"><a href="#2-对-Redis-进行配置" class="headerlink" title="2. 对 Redis 进行配置"></a>2. 对 Redis 进行配置</h5><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  redis:    port: 6379 # 端口    host: 172.25.248.60 # 虚拟机地址    password: 123456 # 密码    lettuce:      pool:        max-wait: 200  # 等待时间        max-active: 8  # 最大连接数        max-idle: 8    # 最大空闲连接        min-idle: 0    # 最小空闲连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-注入-RedisTemplate"><a href="#3-注入-RedisTemplate" class="headerlink" title="3. 注入 RedisTemplate"></a>3. 注入 RedisTemplate</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Resourceprivate RedisTemplate redisTemplate;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestpublic class SpringDataRedisTest {        @Resource    private RedisTemplate redisTemplate;    @Test    void testString(){        // 插入数据        redisTemplate.opsForValue().set("name","李四");        // 读取数据        Object name = redisTemplate.opsForValue().get("name");        System.out.println("name = " + name);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-SpringDataRedis-的序列化形式"><a href="#2-SpringDataRedis-的序列化形式" class="headerlink" title="2. SpringDataRedis 的序列化形式"></a>2. SpringDataRedis 的序列化形式</h3><p><code>RedisTemplate </code>可以接收任意 <code>Object </code>作为值写入 <code>Redis</code>，只不过写入前会把 <code>Object </code>序列化为 字节形式，默认是采用 <font color="red">JDK 序列化</font></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312040360.png" alt="image-20221201161846388"></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>解决方法：<font color="red">自定义 RedisTemplate 序列化方式</font></p><ol><li>自定义 RedisTemplate</li><li>修改 RedisTemplate 的序列化器为 GenericJackson2JsonRedisSerializer</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**    * 自定义序列化方式    * */   @Bean   public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factoryon){       // 创建 Template       RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();       // 设置连接工厂       redisTemplate.setConnectionFactory(factoryon);       // 设置序列化工具       GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();       // key 和 hash key 采用 string 序列化       redisTemplate.setKeySerializer(RedisSerializer.string());       redisTemplate.setHashKeySerializer(RedisSerializer.string());       // value 和 hashValue 采用 JSON 序列化       redisTemplate.setValueSerializer(jsonRedisSerializer);       redisTemplate.setHashValueSerializer(jsonRedisSerializer);       return redisTemplate;   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@AllArgsConstructor@NoArgsConstructorpublic class User {    private String name;    private int age;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestpublic class SpringDataRedisTest {    @Autowired    private RedisTemplate redisTemplate;    @Test    void testUser(){        User user = new User("张三", 20);        //        redisTemplate.opsForValue().set("user:101", user);        //        Object object = redisTemplate.opsForValue().get("user:101");        System.out.println(object);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试效果：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312041243.png" alt="image-20221201163630093"></p><h4 id="3-2-3-StringRedisTemplate"><a href="#3-2-3-StringRedisTemplate" class="headerlink" title="3.2.3 StringRedisTemplate"></a>3.2.3 StringRedisTemplate</h4><p>上述自定义序列化方式中使用的 JSON 序列化方式，虽然可以满足需求，但仍存在一些问题：为了在反序列化时知道对象的类型，JSON 序列化器会将类的 class 类型写入 json 结果中，存入 Redis，会带来<font color="red">额外的内存开销</font></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312042279.png" alt="image-20221201164227016"></p><p>为了节省内存空间，不使用 JSON 序列化器来处理 value，而是统一使用 String 序列化器，要求只能存储 String 类型的 key 和 value。当需要存储 Java 对象时，手动完成对象的序列化和反序列化</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312042345.png" alt="image-20221201165453196"></p><p>Spring 默认提供了一个 StringRedisTemplate 类，其 key 和 value 的序列化方式默认就是 String 方式</p><p>使用步骤如下：</p><ol><li>使用 StringRedisTemplate</li><li>写入 Redis时，手动把对象序列化为 JSON</li><li>读取 Redis 时，手动把读取到的 JSON 反序列化为对象</li></ol><p>示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestpublic class StringRedisTemplateTest {    @Autowired    private StringRedisTemplate stringRedisTemplate;    // JSON 工具    private static final ObjectMapper objectMapper = new ObjectMapper();    @Test    void testStringTemplate() throws JsonProcessingException {        // 准备对象        User user = new User("张三", 20);        // 手动序列化        String json = objectMapper.writeValueAsString(user);        // 写入一条数据到 redis        stringRedisTemplate.opsForValue().set("user:200", json);        // 读取数据        String value = stringRedisTemplate.opsForValue().get("user:200");        // 反序列化        User user1 = objectMapper.readValue(value, User.class);        System.out.println("user1 = " + user1);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312043076.png" alt="image-20221201171224124"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312042750.png" alt="image-20221201171209566"></p><blockquote><p> 可见内存大大减少了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/tur-study/2023/03/31/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/tur-study/2023/03/31/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="防火墙相关命令"><a href="#防火墙相关命令" class="headerlink" title="防火墙相关命令"></a>防火墙相关命令</h3><h4 id="1-查看防火墙状态"><a href="#1-查看防火墙状态" class="headerlink" title="1. 查看防火墙状态"></a>1. 查看防火墙状态</h4><pre class="line-numbers language-none"><code class="language-none">systemctl status firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>inactive(dead)：未启动</li><li>active（running）：已启动。字体呈现绿色</li></ul><h4 id="2-开启防火墙"><a href="#2-开启防火墙" class="headerlink" title="2. 开启防火墙"></a>2. 开启防火墙</h4><ul><li>开启防火墙</li></ul><pre class="line-numbers language-none"><code class="language-none">systemctl start firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>设置开机自启动</li></ul><pre class="line-numbers language-none"><code class="language-none">systemctl enable firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-开放或限制端口"><a href="#3-开放或限制端口" class="headerlink" title="3. 开放或限制端口"></a>3. 开放或限制端口</h4><h5 id="3-1-开放端口"><a href="#3-1-开放端口" class="headerlink" title="3.1 开放端口"></a>3.1 开放端口</h5><ol><li>开启指定端口</li></ol><pre class="line-numbers language-none"><code class="language-none">firewalld-cmd --zone=public --add-port=6379/tcp --permanent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>--permanent</code>：声明该设置永久有效。不加的话机器重启之后就失效了</p></blockquote><ol start="2"><li>重新载入防火墙设置，使设置生效</li></ol><pre class="line-numbers language-none"><code class="language-none">firewalld-cmd --reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>查看是否生效</li></ol><pre class="line-numbers language-none"><code class="language-none">fiewwalld-cmd --zone=publi --query-port=6379/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>输出yes：表示开启</li><li>输出no：表示未开启</li></ul><ol start="4"><li>查看当前系统打开的所有端口</li></ol><pre class="line-numbers language-none"><code class="language-none">firewalld-cmd --zone=public --list-ports<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>需要查询详细信息的的话，可以输入：<code>firewalld-cmd --list-all</code></p></blockquote><h5 id="3-2-限制端口"><a href="#3-2-限制端口" class="headerlink" title="3.2 限制端口"></a>3.2 限制端口</h5><ol><li>限制指定端口，将开放的命令的 add 更改为 remove</li></ol><pre class="line-numbers language-none"><code class="language-none">firewalld-cmd --zone=public --remove-port=6379/tcp --permanent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>设置之后，记得重载，不然设置是没有效果的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 整合 Sa-Token 基础</title>
      <link href="/tur-study/2023/03/31/SpringBoot/Sa-Token%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/"/>
      <url>/tur-study/2023/03/31/SpringBoot/Sa-Token%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="一、SpringBoot-集成-Sa-Token-示例"><a href="#一、SpringBoot-集成-Sa-Token-示例" class="headerlink" title="一、SpringBoot 集成 Sa-Token 示例"></a>一、SpringBoot 集成 Sa-Token 示例</h2><ol><li>添加依赖</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 权限认证，在线文档：https://sa-token.cc --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>设置配置文件</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">#=================== Sa-Token 配置 ========================sa-token:  # token名称，同时也是cookie名称  token-name: satoken  # token有效期，单位s，默认30天。-1代表永不过期  timeout: 2592000   # token临时有效期，指定时间内无操作就视为token过期，单位s  activity-timeout: -1  # 是否允许同一账号并发登录，true：允许一起登录。false：新登录挤掉旧登陆  is-concurrent: true  # 在多人登录同一账号时，是否共用一个token。true：所有登录共用一个token  is-share: true  # token风格  token-style: uuid  # 是否输出操作日志  is-log: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>创建测试 Controller</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping("/user/")public class UserController {    // 测试登录    @RequestMapping("doLogin")    public String doLogin(String username, String password) {        // 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对         if("zhang".equals(username) &amp;&amp; "123456".equals(password)) {            // 10001，仅代表用户id，需要以实际情况而定            StpUtil.login(10001);            return "登录成功";        }        return "登录失败";    }    // 查询登录状态    @RequestMapping("isLogin")    public String isLogin() {        return "当前会话是否登录：" + StpUtil.isLogin();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>测试：</li></ol><p>从浏览器一次访问上述测试接口：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303311524572.png"></p><hr><h2 id="二、登录认证"><a href="#二、登录认证" class="headerlink" title="二、登录认证"></a>二、登录认证</h2><h3 id="2-1-设计思路"><a href="#2-1-设计思路" class="headerlink" title="2.1 设计思路"></a>2.1 设计思路</h3><p>对于一些登陆之后才能访问的接口，如查询我的账号资料。通常的做法事增加一层接口校验</p><ul><li>如果校验通过，则：正常返回数据</li><li>若校验未通过，则：抛出异常，告知其需要先进行登录</li></ul><p>那么，判断会话是否登录的依据是什么？先来看看登录访问的流程：</p><p>登录访问的流程如下：</p><ol><li>用户提交 <code>name</code> + <code>password</code> 参数，调用登录接口</li><li>登陆成功，返回这个用户的 Token 会话凭证</li><li>用户后续的每次请求，都携带上这个 Token</li><li>服务器根据 Token 判断会话是否登陆成功</li></ol><p>所谓登录认证，指的就是服务器校验账号密码，为用户颁发Token 会凭证的过程，这个 Token 也是后续判断会话是否登录的关键所在</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303311541974.png"></p><h3 id="2-2-登录与注销"><a href="#2-2-登录与注销" class="headerlink" title="2.2 登录与注销"></a>2.2 登录与注销</h3><p>根据以上思路，Sa-Token 实现了一个会话登录函数：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 会话登录：参数填写要登录的账号id，建议数据类型：long | int | String，不可用传入复杂类型，如：User、Admin等等StpUtil.login(Object id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>基于上面这个函数，<code>Sa-Token 为要登录的账号创建了一个 Token 凭证，且通过 Cookie 上下文返回给了前端</code></p><p>Sa-Token 实现 <code>StpUtil.login(Object id)</code>，做了如下工作：</p><ol><li>检查此账号是否之前已有登录</li><li>为账号生成 <code>Token </code>凭证与 <code>Session </code>会话</li><li>通知全局侦听器，xx 账号登陆成功</li><li>将 <code>Token </code>注入到请求上下文</li><li>等等。。。</li></ol><p>基于 <code>StpUtil.login(Object id)</code>，一般登录接口代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 会话登录@RequestMapping("doLogin")public SaResult doLogin(String name, String pwd){    // 1. 比对前端提交的账号名称、密码    if("zhangsan".equals(name) &amp;&amp; "123456".equals(pwd)){        // 2. 根据账号id，进行登录        StpUtil.login(10001);        return SaResult.ok("登陆成功")；    }    return SaResult.error("登陆失败");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码实现中仅仅做了会话登录，而没有主动向前端返回 Token 信息。原因如下：<code>StpUtil.login(id)</code>利用了 Cookie 自动注入的特性，将原本需要返回的 Token 信息的代码，给省略了</p><blockquote><p>了解 Cookie 的两点基本功能：</p><ul><li>Cookie 可以从后端控制往浏览器中写入 Token 值</li><li>Cookie 会在前端每次发起请求时自动提交 Token 值</li></ul></blockquote><p>除了登录方法，Sa-Token 还实现了如下方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 当前会话注销登录StpUtil.logout();// 获取当前会话是否已经登录// true：已登录// false：未登录StpUtil.isLogin();// 校验当前会话是否已经登录，若未登录，抛出异常：NotLoginExceptionStpUtil.checkLogin();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>异常 <code>NotLoginException</code> 代表当前会话暂未登录，可能的原因有很多： 前端没有提交 Token、前端提交的 Token 是无效的、前端提交的 Token 已经过期 …… 等等</p></blockquote><h3 id="2-3-会话查询"><a href="#2-3-会话查询" class="headerlink" title="2.3 会话查询"></a>2.3 会话查询</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 获取当前会话账号id, 如果未登录，则抛出异常：`NotLoginException`StpUtil.getLoginId();// 类似查询API还有：StpUtil.getLoginIdAsString();    // 获取当前会话账号id, 并转化为`String`类型StpUtil.getLoginIdAsInt();       // 获取当前会话账号id, 并转化为`int`类型StpUtil.getLoginIdAsLong();      // 获取当前会话账号id, 并转化为`long`类型// ---------- 指定未登录情形下返回的默认值 ----------// 获取当前会话账号id, 如果未登录，则返回null StpUtil.getLoginIdDefaultNull();// 获取当前会话账号id, 如果未登录，则返回默认值 （`defaultValue`可以为任意类型）StpUtil.getLoginId(T defaultValue);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-Token-查询"><a href="#2-4-Token-查询" class="headerlink" title="2.4 Token 查询"></a>2.4 Token 查询</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 获取当前会话的token值StpUtil.getTokenValue();// 获取当前`StpLogic`的token名称StpUtil.getTokenName();// 获取指定token对应的账号id，如果未登录，则返回 nullStpUtil.getLoginIdByToken(String tokenValue);// 获取当前会话剩余有效期（单位：s，返回-1代表永久有效）StpUtil.getTokenTimeout();// 获取当前会话的token信息参数StpUtil.getTokenInfo();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 登录测试  */@RestController@RequestMapping("/acc/")public class LoginController {    // 测试登录    @RequestMapping("doLogin")    public SaResult doLogin(String name, String pwd) {        // 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对         if("zhang".equals(name) &amp;&amp; "123456".equals(pwd)) {            StpUtil.login(10001);            return SaResult.ok("登录成功");        }        return SaResult.error("登录失败");    }    // 查询登录状态    @RequestMapping("isLogin")    public SaResult isLogin() {        return SaResult.ok("是否登录：" + StpUtil.isLogin());    }    // 查询 Token 信息    @RequestMapping("tokenInfo")    public SaResult tokenInfo() {        return SaResult.data(StpUtil.getTokenInfo());    }    // 测试注销    @RequestMapping("logout")    public SaResult logout() {        StpUtil.logout();        return SaResult.ok();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、密码加密"><a href="#三、密码加密" class="headerlink" title="三、密码加密"></a>三、密码加密</h2>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Sa-token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/tur-study/2023/03/30/Redis/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/tur-study/2023/03/30/Redis/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一、初识-Redis"><a href="#一、初识-Redis" class="headerlink" title="一、初识 Redis"></a>一、初识 Redis</h2><h3 id="1-1-NoSQL"><a href="#1-1-NoSQL" class="headerlink" title="1.1 NoSQL"></a>1.1 NoSQL</h3><blockquote><p>对比 SQL 与 NoSQL 的区别</p></blockquote><ul><li>SQL：关系型数据库</li><li>NoSQL：非关系型数据库</li></ul><h4 id="1-1-1-数据结构"><a href="#1-1-1-数据结构" class="headerlink" title="1. 1.1 数据结构"></a>1. 1.1 数据结构</h4><h5 id="1-SQL"><a href="#1-SQL" class="headerlink" title="1. SQL"></a>1. SQL</h5><ul><li>结构化（Structured）</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312030264.png" alt="image-20221129224752320"></p><h5 id="2-NoSQL"><a href="#2-NoSQL" class="headerlink" title="2. NoSQL"></a>2. NoSQL</h5><ul><li>非结构化</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312030531.png" alt="image-20221129225146820"></p><h4 id="1-1-2-数据关联"><a href="#1-1-2-数据关联" class="headerlink" title="1.1.2 数据关联"></a>1.1.2 数据关联</h4><h5 id="1-SQL-1"><a href="#1-SQL-1" class="headerlink" title="1. SQL"></a>1. SQL</h5><ul><li>关联的（Relational）</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312030421.png" alt="image-20221129225809198"></p><h5 id="2-NoSQL-1"><a href="#2-NoSQL-1" class="headerlink" title="2. NoSQL"></a>2. NoSQL</h5><ul><li>无关联的</li></ul><h4 id="1-1-3-查询方式"><a href="#1-1-3-查询方式" class="headerlink" title="1.1.3 查询方式"></a>1.1.3 查询方式</h4><h5 id="1-SQL-2"><a href="#1-SQL-2" class="headerlink" title="1. SQL"></a>1. SQL</h5><ul><li>SQL 查询</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312031329.png" alt="image-20221129225909052"></p><h5 id="2-NoSQL-2"><a href="#2-NoSQL-2" class="headerlink" title="2. NoSQL"></a>2. NoSQL</h5><ul><li>非 SQL</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312031303.png" alt="image-20221129225951166"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312031649.png" alt="image-20221129230007224"></p><h4 id="1-1-4-事务特性"><a href="#1-1-4-事务特性" class="headerlink" title="1.1.4 事务特性"></a>1.1.4 事务特性</h4><h5 id="1-SQL-3"><a href="#1-SQL-3" class="headerlink" title="1. SQL"></a>1. SQL</h5><ul><li>ACID</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312032750.png" alt="image-20221129230120185"></p><h5 id="2-NoSQL-3"><a href="#2-NoSQL-3" class="headerlink" title="2. NoSQL"></a>2. NoSQL</h5><ul><li>BASE</li></ul><blockquote><ul><li>键值类型（Redis）</li><li>文档类型（MongoDB）</li><li>列类型（HBase）</li><li>Graph 类型（Neo4j）</li></ul></blockquote><h3 id="1-2-Redis-简介"><a href="#1-2-Redis-简介" class="headerlink" title="1.2 Redis 简介"></a>1.2 Redis 简介</h3><p><code>Redis</code>（Remote Dictionary Server），远程词典服务器，是一个基于内存的键值型 NoSQL 数据库</p><p>特征：</p><ul><li>键值（<code>key-value</code>）型，value 支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语音客户端</li></ul><h2 id="二、Redis-常见命令"><a href="#二、Redis-常见命令" class="headerlink" title="二、Redis 常见命令"></a>二、Redis 常见命令</h2><h3 id="2-1-Redis-数据结构"><a href="#2-1-Redis-数据结构" class="headerlink" title="2.1 Redis 数据结构"></a>2.1 Redis 数据结构</h3><p><code>Redis </code>是一个<code>key-value</code>的数据库，<code>key </code>一般是 <code>String </code>类型，不过 <code>value </code>的类型多种多样</p><ul><li><p>String：如 “hello world”</p></li><li><p>Hash：{ name: “Jack”, age: 21 }</p></li><li><p>List：[ A -&gt; B -&gt; C -&gt; C ]</p></li><li><p>Set：{ A, B, C}</p></li><li><p>SortedSet：{ A: 1, B: 2, C: 3 }</p></li><li><p>GEO：{ A: (120.3, 30.5 ) }</p></li><li><p>BitMap：0110110101110101011</p></li><li><p>HyperLog：0110110101110101011</p></li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312033258.png" alt="image-20230329163417027"></p><p>Redis 将操作不同数据类型的命令做了分组，在官网（<a href="https://redis.io/commands%EF%BC%89%E5%8F%AF%E4%BB%A5%E6%9F%A5%E5%88%B0%E4%B8%8D%E5%90%8C%E5%91%BD%E4%BB%A4">https://redis.io/commands）可以查到不同命令</a></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312033087.png" alt="image-20221130095432799"></p><h3 id="2-2-Redis-通用命令"><a href="#2-2-Redis-通用命令" class="headerlink" title="2.2 Redis 通用命令"></a>2.2 Redis 通用命令</h3><p>通用指令是部分数据类型都可用使用的指令，常见的有：</p><ul><li><p><code>KEYS</code>：查看复合模板的所有 <code>key</code>，<font color="red">不建议在生产环境设备上使用</font></p></li><li><p><code>DEL</code>：删除一个指定的 <code>key</code></p></li><li><p><code>EXISTS</code>：判断 <code>key </code>是否存在</p></li><li><p><code>EXPIRE</code>：给一个 <code>key</code> 设置有效期，有效期到期时，该 <code>key </code>会被自动删除</p></li><li><p><code>TTL</code>：查看一个 <code>key </code>的剩余有效期</p></li><li></li></ul><blockquote><p>通过 <code>help [command]</code> 可以查看一个命令的具体用法</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312034035.png" alt="image-20221130101123021"></p></blockquote><h3 id="2-3-String-类型"><a href="#2-3-String-类型" class="headerlink" title="2.3 String 类型"></a>2.3 String 类型</h3><h4 id="2-3-1-String-类型的三种格式"><a href="#2-3-1-String-类型的三种格式" class="headerlink" title="2.3.1 String 类型的三种格式"></a>2.3.1 String 类型的三种格式</h4><p><code>String </code>类型，即字符串类型，是 <code>Redis </code>中最简单的存储类型，其 <code>value</code> 是字符串，不过根据字符串的格式不同，可以分为如下3类：</p><ul><li><code>string</code>：普通字符串</li><li><code>int</code>：整数类型，可以做自增、自减操作</li><li><code>float</code>：浮点类型，可以做自增、自减操作</li></ul><blockquote><p>不管是哪种格式，底层都是字节数组形式存储，只不过编码方式不同。字符串类型的最大空间不能超过 512m</p></blockquote><h4 id="2-3-2-String-类型的常见命令"><a href="#2-3-2-String-类型的常见命令" class="headerlink" title="2.3.2 String 类型的常见命令"></a>2.3.2 String 类型的常见命令</h4><p><code>String </code>的常见命令有：</p><ul><li><code>SET</code>：添加或者修改已经存在的一个 String 类型的键值对</li><li><code>GET</code>：根据 key 获取 String 类型的 value</li><li><code>MSET</code>：批量添加多个 String 类型的键值对</li><li><code>MGET</code>：根据多个 key 获取多个 String 类型的 value</li><li><code>INCR</code>：让一个整型的 key 自增1</li><li><code>INCRBY</code>：让一个整型的 key 自增并指定步长。例如：incrby num 2 让 num 值自增 2</li><li><code>INCRBYFLOAT</code>：让一个浮点类型的数字自增并指定步长</li><li><code>SETNX</code>：添加一个 String 类型的键值对，前提是这个 key 不存在，否则不执行</li><li><code>SETEX</code>：添加一个 String 类型的键值对，并且指定有效期</li></ul><h4 id="2-3-3-key的结构"><a href="#2-3-3-key的结构" class="headerlink" title="2.3.3 key的结构"></a>2.3.3 key的结构</h4><blockquote><p>问题：如何区分不同类型的 key。例如：需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1</p></blockquote><p><code>Redis </code>的 <code>key </code>允许有多个单词形成层级结构，多个单词之间用 <code>: </code>隔开，格式如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312034365.png" alt="image-20221130150154494"></p><blockquote><p>格式并非固定，可以根据需求来删除或添加词条</p></blockquote><p>示例如下：</p><p>项目名称：hotel，有 user 和 product 两种不同类型的数据，定义 key 如下：</p><ul><li>user 相关的 key：hotel:user:1</li><li>product 相关的 key：hotel:product:1</li></ul><p>若 Value 是一个 Java 对象，如一个 User 对象，则可由将对象序列化为 JSON 字符串后存储</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312034736.png" alt="image-20221130185855534"></p><h3 id="2-4-Hash-类型"><a href="#2-4-Hash-类型" class="headerlink" title="2.4 Hash 类型"></a>2.4 Hash 类型</h3><h4 id="2-4-1-Hash-结构"><a href="#2-4-1-Hash-结构" class="headerlink" title="2.4.1 Hash 结构"></a>2.4.1 Hash 结构</h4><p>Hash 类型，也叫散列，其 value 是一个无序字典，类似于 Java 中的 HashMap 结构</p><blockquote><p>问题：String 结构是将对象序列化为 JSON 字符串后存储，当需要修改对象的某个字段时很不方便：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312035565.png" alt="image-20221130190238185"></p></blockquote><p>Hash 结构可以将对象中的的每个字段独立存储，可以针对单个字段做 CRUD</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312035131.png" alt="image-20221130191443785"></p><h4 id="2-4-2-Hash-类型常用命令"><a href="#2-4-2-Hash-类型常用命令" class="headerlink" title="2.4.2 Hash 类型常用命令"></a>2.4.2 Hash 类型常用命令</h4><p><code>Hash </code>的常见命令有：</p><ul><li><code>HSET key field value</code>：添加或者修改 hash 类型 key 的 field 的值</li><li><code>HGET key field</code>：获取一个 hash 类型 key field 的值</li><li><code>HMSET</code>：批量添加多个 hash类型 key 的 field 的值</li><li><code>HMGET</code>：批量获取多个 hash 类型 key 的 field 的值</li><li><code>HGETALL</code>：获取一个 hash 类型的 key 中的所有的 field 和 value</li><li><code>HKEYS</code>：获取一个 hash 类型的 key 中的所有的 field</li><li><code>HVALS</code>：获取一个 hash 类型的 key 中的所有的 value</li><li><code>HINCRBY</code>：让一个 hash 类型 key 的字段值自增并指定步长</li><li><code>HSETNX</code>：添加一个 hash 类型的 key 的 field 值，前提是这个 field 不存在，否则不执行</li></ul><h3 id="2-5-List-类型"><a href="#2-5-List-类型" class="headerlink" title="2.5 List 类型"></a>2.5 List 类型</h3><h4 id="2-5-1-List-类型简介"><a href="#2-5-1-List-类型简介" class="headerlink" title="2.5.1 List 类型简介"></a>2.5.1 List 类型简介</h4><p>Redis 中的 <code>List </code>类型与 Java 中的 <code>LinkedList </code>类似，可以看做是一个<font color="red">双向链表结构</font>，即支持正向检索也支持方向检索</p><p><code>List </code>类型的特征也与 <code>LinkedList </code>类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个<font color="red">有序数据</font>，例如：朋友圈点赞列表，评论列表</p><h4 id="2-5-2-List-类型的常见命令"><a href="#2-5-2-List-类型的常见命令" class="headerlink" title="2.5.2 List 类型的常见命令"></a>2.5.2 List 类型的常见命令</h4><ul><li><code>lpush key element … </code>：项列表左侧插入一个或多个元素</li><li><code>lpop key</code>：移除并返回列表左侧的第一个元素，没有则返回 nil</li><li><code>rpush key elemnt … </code>： 项列表右侧插入一个或多个元素</li><li><code>rpop key</code>：移除并返回列表右侧的第一个元素</li><li><code>lrange key star end</code>：返回一段角标范围内的所有元素</li><li><code>blpop 和 brpop</code>：与 lpop 和 rpop 类似，只不过在没有元素时等待指定时间，而不是直接返回 nil</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312036626.png" alt="image-20221130200304385"></p><blockquote><ol><li>如何利用 List 结构模拟一个栈：<ul><li>入口和出口在同一边</li></ul></li><li>如何利用 List 结构模拟一个队列：<ul><li>入口和出口不在同一边</li></ul></li><li>如何利用 List 结构模拟一个阻塞队列：<ul><li>入口和出口在不同边</li><li>出队时 <code>BLPOP </code>或 <code>BRPOP</code></li></ul></li></ol></blockquote><h3 id="2-6-Set-类型"><a href="#2-6-Set-类型" class="headerlink" title="2.6 Set 类型"></a>2.6 Set 类型</h3><h4 id="2-6-1-Set-结构"><a href="#2-6-1-Set-结构" class="headerlink" title="2.6.1 Set 结构"></a>2.6.1 Set 结构</h4><p>Redis 的 Set 结构与 Java 中的 HashSet 类似，可以看做是一个 value 为 null 的 HashMap</p><p>具备与 Hash Set 类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><h4 id="2-6-2-Set-的常见命令"><a href="#2-6-2-Set-的常见命令" class="headerlink" title="2.6.2 Set 的常见命令"></a>2.6.2 Set 的常见命令</h4><ul><li><code>sadd key member …</code> ： 向 set 中添加一个或多个元素</li><li><code>srem key member …</code> ：移除 set 中的指定元素</li><li><code>scard key</code>：返回 se 中元素的个数</li><li><code>sismember key member</code>：判断一个元素是否存在于 set 中</li><li><code>smembers</code>：获取 set 中的所有元素</li><li><code>sinter key1 key2 …</code> ： 求 key1 和 key2 的交集</li><li><code>sdiff key1 key2 … </code>：求 key1 和 key2 的差集</li><li><code>sunion key1 ke2 … </code>：求 key1 和 key2 的并集</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312036207.png" alt="image-20221130210806789"></p><h3 id="2-7-SortedSet-类型"><a href="#2-7-SortedSet-类型" class="headerlink" title="2.7 SortedSet 类型"></a>2.7 SortedSet 类型</h3><h4 id="2-7-1-SortedSet-类型"><a href="#2-7-1-SortedSet-类型" class="headerlink" title="2.7.1 SortedSet 类型"></a>2.7.1 SortedSet 类型</h4><p>Redis 的 SortedSet 是一个可排序的 set 集合，与 Java 中的 TreeSet 有些类似，但底层数据结构差别很大</p><p>SortedSet 中的每个元素都带有一个 score 属性，可以基于 score 属性对元素进行排序，底层的实现是一个跳表（SkipList）加 hash 表</p><p>SortedSet 具备以下特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><blockquote><p>因为 SortedSet 的可排序特性，经常被用来实现排行榜这样的功能</p></blockquote><h4 id="2-7-2-SortedSet-的常见命令"><a href="#2-7-2-SortedSet-的常见命令" class="headerlink" title="2.7.2 SortedSet 的常见命令"></a>2.7.2 SortedSet 的常见命令</h4><ul><li><code>zadd key score member</code>：添加一个或多个元素到 sorted set， 若已经存在则更新其 score 值</li><li><code>zrem key member </code>：删除 sorted set 中的一个指定元素</li><li><code>zscore key member</code>：获取 sorted set 中的指定元素的 score 值</li><li><code>zrank key member</code>：获取 sorted set 中指定元素的排名</li><li><code>zcard key</code>：获取 sorted set 的元素个数</li><li><code>zcount key min max</code>：统计 score 值在给定范围内的所有元素的个数</li><li><code>zincrby key increment member</code>：让 sorted set 中的指定元素自增，步长为指定的 increment 值</li><li><code>zrange key min max</code>：按照 score 排序后，获取指定排名范围内的元素，这是个左开右闭的区间</li><li><code>zrangebyscore key min max</code>：按照 score 排序后，获取指定 score 范围内的元素</li><li><code>zdiff、zinter、zunion</code>：求差集、交集、并集</li></ul><blockquote><p>==注意：==所有的排名都是默认升序，若需要降序则在命令的 Z 后面添加 rev 即可</p></blockquote><h2 id="三、Redis-的-Java-客户端"><a href="#三、Redis-的-Java-客户端" class="headerlink" title="三、Redis 的 Java 客户端"></a>三、Redis 的 Java 客户端</h2><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/clients">https://redis.io/clients</a></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312037116.png" alt="image-20221201095200934"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312037112.png" alt="image-20221201095300937"></p><h3 id="3-1-Jedis"><a href="#3-1-Jedis" class="headerlink" title="3.1 Jedis"></a>3.1 Jedis</h3><blockquote><p>jedis 官网地址：<a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p></blockquote><h4 id="3-1-1-Jedis-的基本使用"><a href="#3-1-1-Jedis-的基本使用" class="headerlink" title="3.1.1 Jedis 的基本使用"></a>3.1.1 Jedis 的基本使用</h4><p>Jedis 的使用步骤如下：</p><ul><li>引入依赖</li><li>创建 Jedis 对象，建立连接</li><li>使用 Jedis，方法名与 Redis 命令一致</li><li>释放资源</li></ul><p>具体如下：</p><ol><li><p>引入依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- redis 依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>建立连接：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.junit.jupiter.api.BeforeEach;import redis.clients.jedis.Jedis;public class RedisTest {    private Jedis jedis;    /**     * 建立连接     * */    @BeforeEach    public void setUp(){        // 建立连接        jedis = new Jedis("127.0.0.1", 6379);        // 设置密码        jedis.auth("123456");        // 选择库        jedis.select(0);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试 String</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.junit.jupiter.api.Test;....public class RedisTest {    ...    /**     * 测试 String     * */    @Test    void testString(){        // 插入数据，方法名称即redis命令的名称        String result = jedis.set("name", "张三");        System.out.println("result = " + result);        // 获取数据        String name = jedis.get("name");        System.out.println("name = " + name);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>释放资源：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.junit.jupiter.api.AfterEach;public class RedisTest {...    /**     * 释放资源     * */    @AfterEach    public void tearDown(){        // 释放资源        if(jedis != null){            jedis.close();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312038309.png" alt="image-20221201100027562"></p><h4 id="3-1-2-Jedis-连接池"><a href="#3-1-2-Jedis-连接池" class="headerlink" title="3.1.2 Jedis 连接池"></a>3.1.2 Jedis 连接池</h4><p>Jedis 本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用 Jedis 连接池代替 Jedis 的直连方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class JedisConnectionFactory {    private static final JedisPool jedisPool;        static {        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();        // 最大连接数        jedisPoolConfig.setMaxTotal(8);        // 最大空闲连接        jedisPoolConfig.setMaxIdle(8);        // 最小空闲连接        jedisPoolConfig.setMinIdle(0);        // 设置最长等待时间，ms        jedisPoolConfig.setMaxWaitMillis(200);        jedisPool = new JedisPool(jedisPoolConfig, "127.0.0.1", 6379, 1000, "123456");    }    /**     * 获取Jedis对象     * */    public static Jedis getJedis() {        return jedisPool.getResource();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的一些使用技巧</title>
      <link href="/tur-study/2023/03/29/MySQL/MySQL%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/tur-study/2023/03/29/MySQL/MySQL%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="1-获取指定id的上一个数据或下一个数据"><a href="#1-获取指定id的上一个数据或下一个数据" class="headerlink" title="1. 获取指定id的上一个数据或下一个数据"></a>1. 获取指定id的上一个数据或下一个数据</h3><p>示例如下：</p><ul><li>获取上一个数据</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from blog_article where id &lt; 123 order by id desc limit 1                                                 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体实现思想如下：</p><p>将表中数据进行倒序排列即 <code>desc</code>，选择 <code>id </code>小于指定值的数据即 <code>id $lt; 123</code>，并指定输出数据为1即 <code>limit 1</code></p><blockquote><p><code>$lt;</code> 代表小于号<code> &lt;</code></p></blockquote><ul><li>获取上一个数据</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from blog_article where id &gt; 123 order by id asc limit 1    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体实现思想如下：</p><p>将表中数据进行正序排列即 <code>asc</code>，选择 <code>id </code>大于指定值的数据即 <code>id $gt; 123</code>，并指定输出数据为1即 <code>limit 1</code></p><blockquote><p><code>$gt;</code> 代表小于号 <code>&gt;</code></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interceptor 拦截器的使用</title>
      <link href="/tur-study/2023/03/28/SpringBoot/Interceptor%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/03/28/SpringBoot/Interceptor%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/mathison-tur/blog_img/raw/master/md_img/image-20221129224752320.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filter 过滤器的使用</title>
      <link href="/tur-study/2023/03/28/SpringBoot/Filter%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/03/28/SpringBoot/Filter%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h3><p><code>SpringBoot </code>的过滤器，在 <code>web </code>开发中可以过滤指定的 <code>url</code>，如过滤掉不需要的接口请求，同时也可以修改 <code>request </code>和 <code>response </code>内容</p><p>过滤器的应用场景：</p><ul><li>过滤敏感词汇（防止sql注入）</li><li>设置字符编码</li><li>URL级别的权限访问控制</li><li>压缩相应信息</li></ul><h3 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h3><p>实现方式有以下两种：</p><ol><li>使用<code> spring boot</code> 提供的 <code>FilterRegistrationBean </code>注册 <code>Filter</code></li><li>使用原生 <code>servlet </code>注解定义 <code>Filter</code></li></ol><blockquote><p>两种方式的本质都是一样的，都是去FilterRegistrationBean 注册自定义 Filter</p></blockquote><h4 id="2-1-使用-SpringBoot-提供的-FIlterRegitrationBean-注册-Filter"><a href="#2-1-使用-SpringBoot-提供的-FIlterRegitrationBean-注册-Filter" class="headerlink" title="2.1 使用 SpringBoot 提供的 FIlterRegitrationBean 注册 Filter"></a>2.1 使用 SpringBoot 提供的 FIlterRegitrationBean 注册 Filter</h4><ol><li>定义 Filter</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">import lombok.extern.slf4j.Slf4j;import javax.servlet.*;import javax.servlet.FilterConfig;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;@Slf4jpublic class MyCorsFilter implements Filter {    // 令牌    static final String TOKEN = "1234567890";    // 内部接口    public static List&lt;String&gt; INSIDE_URLS = List.of("/web/article/list", "/web//article/condition");    // 白名单    public static List&lt;String&gt; WHITE_PATH = List.of("/white", "/login");    /**     * 核心过滤方法     * */    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {        // doFilter 方法中的 request 和 response 需要转换为对应的 HttpServletRequest 和 HttpServletResponse 方便调用某些方法        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpServletResponse response = (HttpServletResponse) servletResponse;        String ip = request.getRemoteAddr();        String requestURI = request.getRequestURI();        log.info("ip = {}, requestURI = {}", ip, requestURI);        if (INSIDE_URLS.contains(requestURI)){            // 内部接口，直接通过            filterChain.doFilter(servletRequest, servletResponse);            return;        }        if (WHITE_PATH.contains(requestURI)){            // 白名单接口，直接通过            filterChain.doFilter(servletRequest, servletResponse);            return;        }        String token = request.getHeader("token");        if (TOKEN.equals(token)){            // 令牌校验通过，允许接口通过            filterChain.doFilter(servletRequest, servletResponse);        }else {            // 令牌校验不通过，重定向到登陆界面        }    }    /**     * 初始化     * */    public void init(FilterConfig filterConfig) {}    /**     * 销毁方法     * */    public void destroy() {}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>注册自定义Filter过滤器配置类</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class FilterConfig {    /**     * 基础过滤器     * */    @Bean    public FilterRegistrationBean&lt;Filter&gt; baseFilter(){        FilterRegistrationBean&lt;Filter&gt; filterRegistrationBean = new FilterRegistrationBean&lt;&gt;();        filterRegistrationBean.setFilter(new MyCorsFilter());        filterRegistrationBean.setUrlPatterns(List.of("/*"));        filterRegistrationBean.setOrder(1);        return filterRegistrationBean;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试可以发现白名单和内部接口可以通过，而不在这两个范围内的接口若令牌token不对应，则不能通过</p><h3 id="3-跨域请求的实现"><a href="#3-跨域请求的实现" class="headerlink" title="3. 跨域请求的实现"></a>3. 跨域请求的实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class MyCorsFilter implements Filter {    public void doFilter(ServletRequest req, ServletResponse res,                         FilterChain chain) throws IOException, ServletException {        HttpServletResponse response = (HttpServletResponse) res;        response.setHeader("Access-Control-Allow-Origin", "*");        response.setHeader("Access-Control-Allow-Credentials", "true");        response.setHeader("Access-Control-Allow-Methods", "*");        response.setHeader("Access-Control-Allow-Headers", "Content-Type,Access-Token,Authorization");        response.setHeader("Access-Control-Expose-Headers", "*");        response.setHeader("Access-Control-Max-Age", "3600");        chain.doFilter(req, res);    }    public void init(FilterConfig filterConfig) {}    public void destroy() {}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在接口分组添加<code> @CrossOrigin</code>注解可以实现该接口分组的所有接口允许跨域请求</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis Plus 分页插件的使用</title>
      <link href="/tur-study/2023/03/28/MybatisPlus/Mybatis%20Plus%20%E4%B8%AD%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/03/28/MybatisPlus/Mybatis%20Plus%20%E4%B8%AD%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>官网：<a href="https://baomidou.com/">https://baomidou.com/</a></p></blockquote><p>Spring Boot 中的使用步骤如下：</p><h3 id="1-分页配置"><a href="#1-分页配置" class="headerlink" title="1. 分页配置"></a>1. 分页配置</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class MybatisPlusConfig{        @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor(){        // 1. 创建 MybatisPlusInterceptor 拦截器对象        MybatisPlusInterceptor mpInterceptor = new MybatisPlusInterceptor();        // 2. 添加分页拦截器，并声明使用的数据库类型        mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));        return mpInterceptor;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-使用官方已实现的接口实现分页"><a href="#2-使用官方已实现的接口实现分页" class="headerlink" title="2 使用官方已实现的接口实现分页"></a>2 使用官方已实现的接口实现分页</h3><blockquote><p>Service CRUD 接口</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 无条件分页查询IPage&lt;T&gt; page(IPage&lt;T&gt; page);// 条件分页查询IPage&lt;T&gt; page(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper);// 无条件分页查询IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page);// 条件分页查询IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参数说明</strong></p><table><thead><tr><th align="center">类型</th><th align="center">参数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IPage<t></t></td><td align="center">page</td><td align="center">翻页对象</td></tr><tr><td align="center">Wrapper<t></t></td><td align="center">queryWrapper</td><td align="center">实体对象封装操作类 QueryWrapper</td></tr></tbody></table><h3 id="3-自定义-mapper-method-使用分页"><a href="#3-自定义-mapper-method-使用分页" class="headerlink" title="3. 自定义 mapper # method 使用分页"></a>3. 自定义 mapper # method 使用分页</h3><p>示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">IPage&lt;UserVo&gt; selectPageVo(IPage&lt;?&gt; page, Integer state);// or (class MyPage extends Ipage&lt;UserVo&gt;{ private Integer state; })MyPage selectPageVo(MyPage page);// orList&lt;UserVo&gt; selectPageVo(IPage&lt;UserVo&gt; page, Integer state);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectPageVo<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx.xxx.xxx.UserVo<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    SELECT id,name FROM user WHERE state=#{state}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>如果返回类型是 IPage 则入参的 IPage 不能为null,因为 返回的IPage == 入参的IPage; 如果想临时不分页,可以在初始化IPage时size参数传 &lt;0 的值;</li><li>如果返回类型是 List 则入参的 IPage 可以为 null(为 null 则不分页),但需要你手动 入参的IPage.setRecords(返回的 List);</li><li>如果 xml 需要从 page 里取值,需要 <code>page.属性</code> 获取</li></ul></blockquote><h3 id="4-Page-类"><a href="#4-Page-类" class="headerlink" title="4. Page 类"></a>4. Page 类</h3><p>该类继承了 <code>IPage</code> 类，实现了 <code>简单分页模型</code> 如果要实现自己的分页模型可以继承 <code>Page</code> 类或者实现 <code>IPage</code> 类</p><table><thead><tr><th align="center">属性名</th><th align="center">类型</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">records</td><td align="center">List</td><td align="center">emptyList</td><td align="center">查询数据列表</td></tr><tr><td align="center">total</td><td align="center">Long</td><td align="center">0</td><td align="center">查询列表总记录数</td></tr><tr><td align="center">size</td><td align="center">Long</td><td align="center">10</td><td align="center">每页显示条数，默认 <code>10</code></td></tr><tr><td align="center">current</td><td align="center">Long</td><td align="center">1</td><td align="center">当前页</td></tr><tr><td align="center">orders</td><td align="center">List</td><td align="center">emptyList</td><td align="center">排序字段信息，允许前端传入的时候，注意 SQL 注入问题，可以使用 <code>SqlInjectionUtils.check(...)</code> 检查文本</td></tr><tr><td align="center">optimizeCountSql</td><td align="center">boolean</td><td align="center">true</td><td align="center">自动优化 COUNT SQL 如果遇到 <code>jSqlParser</code> 无法解析情况，设置该参数为 <code>false</code></td></tr><tr><td align="center">optimizeJoinOfCountSql</td><td align="center">boolean</td><td align="center">true</td><td align="center">自动优化 COUNT SQL 是否把 join 查询部分移除</td></tr><tr><td align="center">searchCount</td><td align="center">boolean</td><td align="center">true</td><td align="center">是否进行 count 查询，如果指向查询到列表不要查询总记录数，设置该参数为 <code>false</code></td></tr><tr><td align="center">maxLimit</td><td align="center">Long</td><td align="center"></td><td align="center">单页分页条数限制</td></tr><tr><td align="center">countId</td><td align="center">String</td><td align="center"></td><td align="center"><code>xml</code> 自定义 <code>count</code> 查询的 <code>statementId</code></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Knife4j配置与使用(OpenAPI2)</title>
      <link href="/tur-study/2023/03/27/SpringBoot/Knife4j%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/03/27/SpringBoot/Knife4j%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h3><p>maven 坐标如下</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.xiaoymin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>knife4j-openapi2-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 具体版本自行选择 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Spring Boot 版本建议在 2.4.0 ~ 3.0.0 之间</p></blockquote><h3 id="2-配置-yml-属性"><a href="#2-配置-yml-属性" class="headerlink" title="2. 配置 yml 属性"></a>2. 配置 yml 属性</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">knife4j:  enable: true  openapi:    title: 这是文档标题 # 文档标题    description: 这是简介 # 简介    email: 123456789@qq.com # 创建人邮件    concat: tur # 创建者    url: https://docs.xiaominfo.com # 项目文档地址    version: v4.0 # 版本    license: Apache 2.0 # 许可证    license-url: https://stackoverflow.com/ # 许可证地址    terms-of-service-url: https://stackoverflow.com/    group: # 分组      test1: # 组名，用以区分其他组        group-name: 分组名称 # 组别名称        api-rule: package # api扫描方式        api-rule-resources: # 指定扫描的位置          - com.knife4j.demo.new3 # 存放接口、对象的包<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问 Knife4j 的文档地址：<code>http://ip:sort/doc.html</code></p><h3 id="3-Java注解"><a href="#3-Java注解" class="headerlink" title="3. Java注解"></a>3. Java注解</h3><h5 id="1-Api：定义接口分组名称"><a href="#1-Api：定义接口分组名称" class="headerlink" title="1. @Api：定义接口分组名称"></a>1. <code>@Api</code>：定义接口分组名称</h5><p>参数说明：</p><ul><li><code>tags</code>:说明该类的作用，可以在 UI 界面上看到的注解</li><li><code>value</code>：一般会自动获取接口分组的名称，可以不用设置</li></ul><h5 id="2-ApiImplicitParam：单个参数注释"><a href="#2-ApiImplicitParam：单个参数注释" class="headerlink" title="2. @ApiImplicitParam：单个参数注释"></a>2. <code>@ApiImplicitParam</code>：单个参数注释</h5><p>用在 <code>@ApiImplicitParams</code> 中，指定一个请求参数的各个方面</p><ul><li><code>name</code>：参数名</li><li><code>value</code>：参数说明</li><li><code>required</code>：参数时是否必须传</li><li><code>paramType</code>：参数位置，有以下可选值<ul><li><code>header</code>：请求头 <code>@RequestHeader</code></li><li><code>query</code>：?param=value格式 <code>@RequestParam</code></li><li><code>path</code>：路径，Restful风格接口 <code>@PathVariable</code></li><li><code>body</code>：请求体</li><li><code>form</code>：以form表单的形式提交</li></ul></li><li><code>dataType</code>：参数类型，默认 String，其他值为 Integer</li><li><code>defaultValue</code>：参数的默认值</li></ul><h5 id="3-ApiImplicitParams：多个参数注释"><a href="#3-ApiImplicitParams：多个参数注释" class="headerlink" title="3. @ApiImplicitParams：多个参数注释"></a>3. <code>@ApiImplicitParams</code>：多个参数注释</h5><p>用在请求方法上，表示一组参数的说明</p><h5 id="4-ApiModel：实体类定义"><a href="#4-ApiModel：实体类定义" class="headerlink" title="4. @ApiModel：实体类定义"></a>4. <code>@ApiModel</code>：实体类定义</h5><h5 id="5-ApiModelProperty：实体属性定义"><a href="#5-ApiModelProperty：实体属性定义" class="headerlink" title="5. @ApiModelProperty：实体属性定义"></a>5. <code>@ApiModelProperty</code>：实体属性定义</h5><ul><li><code>value</code>：字段说明</li><li><code>name</code>：属性名</li><li><code>dataType</code>：属性类型</li><li><code>required</code>：是否必填</li><li><code>example</code>：举例说明</li><li><code>hidden</code>：隐藏</li></ul><h5 id="6-ApiOperation：接口定义"><a href="#6-ApiOperation：接口定义" class="headerlink" title="6. @ApiOperation：接口定义"></a>6. <code>@ApiOperation</code>：接口定义</h5><ul><li><code>value</code>：接口说明</li><li><code>httpMethod</code>：接口请求方式</li><li><code>response</code>：接口返回参数类型</li><li><code>notes</code>：接口发布说明</li></ul><h5 id="7-ApiParam：参数注释"><a href="#7-ApiParam：参数注释" class="headerlink" title="7. @ApiParam：参数注释"></a>7. <code>@ApiParam</code>：参数注释</h5><h5 id="8-ApiResponse：响应码"><a href="#8-ApiResponse：响应码" class="headerlink" title="8. @ApiResponse：响应码"></a>8. <code>@ApiResponse</code>：响应码</h5><p>用在 <code>@ApiResponses</code> 中，一般用于表达一个错误或正确的响应信息</p><ul><li><code>code</code>：响应码</li><li><code>message</code>：响应信息</li><li><code>resposne</code>：抛出异常类</li></ul><h5 id="9-ApiResponses：多个响应码"><a href="#9-ApiResponses：多个响应码" class="headerlink" title="9. @ApiResponses：多个响应码"></a>9. <code>@ApiResponses</code>：多个响应码</h5><p>用在请求的方法上，表示一组响应</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中select传递多个参数</title>
      <link href="/tur-study/2023/03/27/MybatisPlus/Mybatis%E4%B8%ADselect%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/"/>
      <url>/tur-study/2023/03/27/MybatisPlus/Mybatis%E4%B8%ADselect%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-单个参数"><a href="#1-单个参数" class="headerlink" title="1. 单个参数"></a>1. 单个参数</h3><p>传递单个参数时，方法名中的参数和 sql 语句中的参数名一致</p><p>如下：方法参数为 id，sql 中的参数也为 id</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// XXMapper.javapublic List&lt;XXBean&gt; getXXBeanList(Long id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- XXMapper.xml --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getXXXBeanList<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.Long<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>XXBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>　　select t.* from tableName t where t.id= #{id}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-多参数"><a href="#2-多参数" class="headerlink" title="2. 多参数"></a>2. 多参数</h3><p>多参数传递时不能使用 <code>parameterType</code>，除非所有参数的类型都一致，改用<code>#{index}</code>，是第几个就用第几个的索引，索引从<code>0</code>开始</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// XXMapper.javapublic List&lt;XXBean&gt; getXXBeanList(Long id, String name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- XXMapper.xml --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getXXXBeanList<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>XXBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>　　select * from tableName t where id=#{0} and name=#{1}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Map封装多参数"><a href="#3-Map封装多参数" class="headerlink" title="3. Map封装多参数"></a>3. Map封装多参数</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// XXMapper.javapublic List&lt;XXBean&gt; getXXBeanList(HashMap map);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- XXMapper.xml --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getXXXBeanList<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hashmap<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>XXBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>　　select * from tableName t where id= #{id} and name=#{name}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>map </code>中的 <code>key </code>名即是在 <code>#{}</code> 中使用的</p><h3 id="4-List-封装-in"><a href="#4-List-封装-in" class="headerlink" title="4. List 封装 in"></a>4. List 封装 in</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// XXMapper.javapublic List&lt;XXBean&gt; getXXBeanList(List&lt;String&gt; list);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- XXMapper.xml --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getXXXBeanList<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hashmap<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>XXBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>　　select 字段... from tableName t where id in    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    #{item}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>foreach 最后的效果是：<code>select 字段 from tableName where id in ('1', '2', '3',...)</code></p><h3 id="5-使用注解方式"><a href="#5-使用注解方式" class="headerlink" title="5. 使用注解方式"></a>5. 使用注解方式</h3><p>在方法上使用 <code>@Param</code> 注解注明参数名</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Page&lt;ArticleVO&gt; selectPreviewPage(            @Param("page") Page&lt;Object&gt; page,            @Param("publish") int publish,            @Param("categoryId") Long categoryId,            @Param("tagId") Long tagId);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectPreviewPage<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.blog.model.vo.ArticleVO<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        select                                                                          a.id as id,                                                                 a.title as title,                                                           a.avatar as avatar,                                                         a.is_stick as isStick,                                                      a.create_time as createTime,                                                c.id as categoryId,                                                         c.name as categoryName                                                  from blog_article a JOIN blog_category c on a.category_id = c.id            where a.is_publish = #{publish}                                             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>categoryId != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                                                and a.category_id = #{categoryId}                                       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>                                                                       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>tagId != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                                                     and a.id in (                                                                   select article_id from blog_article_tag where tag_id = #{tagId}         )                                                                       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>                                                                       order by a.is_stick desc, a.create_time desc                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>                                                                   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Hexo Using</title>
      <link href="/tur-study/2023/03/27/Java/GIt%20Hexo%20%E6%93%8D%E4%BD%9C/"/>
      <url>/tur-study/2023/03/27/Java/GIt%20Hexo%20%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Hexo-基本命令"><a href="#1-Hexo-基本命令" class="headerlink" title="1. Hexo 基本命令"></a>1. Hexo 基本命令</h4><pre class="line-numbers language-none"><code class="language-none">hexo init --新建一个网站，若没有设置folder，默认在当前文件夹建立网站hexo generate --生成个人博客所需的静态页面hexo server --启动服务器，默认访问端口：loclahost:4000hexo deploy --部署个人博客hexo clean --清除缓存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上命令都能用首字母缩写完成</p><pre class="line-numbers language-none"><code class="language-none">hexo g --generate 生成个人博客所需的静态页面hexo s --serverhexo d --deploy 部署个人博客hexo c --clean 清除缓存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-写文章用到的命令"><a href="#2-写文章用到的命令" class="headerlink" title="2. 写文章用到的命令"></a>2. 写文章用到的命令</h4><pre class="line-numbers language-none"><code class="language-none">hexo new --path java/ "文章标题" --新建文章hexo new page "页面名" -- 新建页面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-p, –path</td><td align="left">自定义新文章的路径</td></tr><tr><td align="left">-r, –replace</td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left">-s, –slug</td><td align="left">文章的Slug，作为新文章的文件名和发布后的URL</td></tr></tbody></table><p>编辑博客时使用如下命令</p><pre class="line-numbers language-none"><code class="language-none">hexo s --debug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后访问<a href="http://localhost:4000/%E6%9D%A5%E8%BF%9B%E5%85%A5%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%9B%B4%E6%94%B9%E4%BA%86%E9%85%8D%E7%BD%AE%E6%88%96%E6%96%87%E7%AB%A0%E5%90%8E%E9%9A%8F%E6%97%B6%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E6%9D%A5%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C%E3%80%82">http://localhost:4000/来进入调试模式，更改了配置或文章后随时刷新页面来查看效果。</a></p><h4 id="3-部署博客的步骤"><a href="#3-部署博客的步骤" class="headerlink" title="3. 部署博客的步骤"></a>3. 部署博客的步骤</h4><pre class="line-numbers language-none"><code class="language-none">hexo cleanhexo generatehexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>后两步可以简写为<code>hexo g -d</code></p><h4 id="4-目录结构说明"><a href="#4-目录结构说明" class="headerlink" title="4. 目录结构说明"></a>4. 目录结构说明</h4><pre class="line-numbers language-none"><code class="language-none">|  +-- .deploy      #hexo deploy生成的文件|  +-- node_modules  #npm组件|  +-- public        #生成的静态网页文件|  +--scaffolds      #模板|  +-- source        #博客正文和其他源文件|  |  +-- _posts    #我们自己写的文章以md结尾|  +-- themes        #主题|  +-- _config.yml  #全局配置文件|  `-- package.json  #定义了hexo所需要的各种模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-配置文件"><a href="#5-配置文件" class="headerlink" title="5. 配置文件"></a>5. 配置文件</h4><p>在文件夹跟目录下的<code>_config.yml</code>叫做<strong>站点配置文件</strong>,同样的文件名我们可以在<code>theme</code>文件夹下的主题文件夹里面也找的。而主题文件夹下的<code>_config.yml</code>叫做主题配置文件。这里说明一下站点配置文件：</p><pre class="line-numbers language-none"><code class="language-none"># Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #站点信息title:  #标题subtitle:  #副标题description:  #站点描述，给搜索引擎看的author:  #作者email:  #电子邮箱language: zh-CN #语言# URL #链接格式url:  #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:# Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮enable: true #是否启用line_number: true #显示行号tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev# Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap# Deployment #部署，将 lmintlcx 改成用户名deploy:type: gitrepo: github创库地址.gitbranch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal详解</title>
      <link href="/tur-study/2023/03/27/Java/ThreadLocal%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/03/27/Java/ThreadLocal%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ThreadLocal-简介"><a href="#一、ThreadLocal-简介" class="headerlink" title="一、ThreadLocal 简介"></a>一、ThreadLocal 简介</h2><p>ThreadLocal 叫做 <font color="red"><strong>线程变量</strong></font>，指 ThreadLocal 中<font color="red">填充的变量</font>属于<font color="red">当前线程</font>，该变量对于其他线程而言是隔离的，即该变量是当前线程独有的变量。ThreadLocal 为变量在每个线程中都创建了副本，那么每个线程都可以访问自己内部的副本变量</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/tur-study/2023/03/26/hello-world/"/>
      <url>/tur-study/2023/03/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
