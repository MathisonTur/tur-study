<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>商城项目文档</title>
      <link href="/tur-study/2023/04/24/Project/README/"/>
      <url>/tur-study/2023/04/24/Project/README/</url>
      
        <content type="html"><![CDATA[<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><table><thead><tr><th>依赖</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>SpringBoot</td><td>2.7.7</td><td>MVC框架</td></tr><tr><td>SpringCloud</td><td>2021.0.5</td><td>微服务框架</td></tr><tr><td>SpringCloudAlibaba</td><td>2021.0.5.0</td><td>阿里微服务组件</td></tr><tr><td>Nacos</td><td>2.2.0</td><td>服务注册与配置中心</td></tr><tr><td>Mybatis-Plus</td><td></td><td>ORM框架</td></tr><tr><td>Sa-Token</td><td></td><td>轻量级 Java 权限认证框架</td></tr><tr><td>Spring Security</td><td></td><td>权限认证框架</td></tr><tr><td>Knife4j</td><td></td><td>接口文档聚合工具</td></tr><tr><td>Kibana</td><td></td><td>分析和可视化平台</td></tr><tr><td>ElasticSearch</td><td></td><td>搜索引擎</td></tr><tr><td>RabbitMQ</td><td></td><td>消息队列</td></tr><tr><td>Redis</td><td></td><td>分布式缓存</td></tr><tr><td>Druid</td><td></td><td>数据库连接池</td></tr><tr><td>七牛云</td><td></td><td>七牛云对象存储</td></tr><tr><td>阿里云</td><td></td><td>阿里云对象存储</td></tr><tr><td>SLF4J</td><td></td><td>日志框架</td></tr><tr><td>Lombok</td><td></td><td>简化对象封装工具</td></tr><tr><td>Nginx</td><td></td><td>Http和反向代理web服务器</td></tr><tr><td>JustAuth</td><td></td><td>第三方登录工具</td></tr><tr><td>Hutool</td><td></td><td>Java工具包类库</td></tr><tr><td>Zipkin</td><td></td><td>链路追踪</td></tr><tr><td>Ip2region</td><td></td><td>离线IP地址定位库</td></tr><tr><td>Minio</td><td></td><td>本地对象存储服务</td></tr></tbody></table><h2 id="API地址"><a href="#API地址" class="headerlink" title="API地址"></a>API地址</h2><h3 id="前端项目"><a href="#前端项目" class="headerlink" title="前端项目"></a>前端项目</h3><table><thead><tr><th>项目</th><th>端口</th></tr></thead><tbody><tr><td>平台端</td><td>8000</td></tr><tr><td>商家端</td><td>8100</td></tr><tr><td>用户管理端</td><td>8200</td></tr></tbody></table><h3 id="后端服务地址"><a href="#后端服务地址" class="headerlink" title="后端服务地址"></a>后端服务地址</h3><table><thead><tr><th>服务</th><th>地址端口</th></tr></thead><tbody><tr><td>gateway</td><td>8080</td></tr><tr><td>auth</td><td>9001</td></tr><tr><td>biz</td><td>9002</td></tr><tr><td>leaf</td><td>9003</td></tr><tr><td>multishop</td><td>9004</td></tr><tr><td>order</td><td>9005</td></tr><tr><td>payment</td><td>9006</td></tr><tr><td>product</td><td>9007</td></tr><tr><td>rbac</td><td>9008</td></tr><tr><td>search</td><td>9009</td></tr><tr><td>user</td><td>9010</td></tr></tbody></table><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h2 id="每日计划"><a href="#每日计划" class="headerlink" title="每日计划"></a>每日计划</h2><h3 id="2023-x2F-04"><a href="#2023-x2F-04" class="headerlink" title="2023/04"></a>2023/04</h3><h4 id="2023-x2F-04-x2F-25-周二"><a href="#2023-x2F-04-x2F-25-周二" class="headerlink" title="2023/04/25 周二"></a>2023/04/25 周二</h4><ul><li><input checked="" disabled="" type="checkbox"> 定义统一响应类</li><li><input checked="" disabled="" type="checkbox"> 响应枚举码</li><li><input checked="" disabled="" type="checkbox"> 基于美团Leaf的生成id服务</li></ul><h4 id="2023-x2F-04-x2F-26-周三"><a href="#2023-x2F-04-x2F-26-周三" class="headerlink" title="2023/04/26 周三"></a>2023/04/26 周三</h4><ul><li><input checked="" disabled="" type="checkbox"> 自定义统一异常处理 </li><li><input checked="" disabled="" type="checkbox"> 拷贝工具</li><li><input checked="" disabled="" type="checkbox"> 代码生成器模块</li><li><input checked="" disabled="" type="checkbox"> 网关模块构建</li><li><input checked="" disabled="" type="checkbox"> 依据前端定义相应响应码</li><li><input disabled="" type="checkbox"> 用户账号登录<ul><li><input checked="" disabled="" type="checkbox"> 账号授权表</li><li><input checked="" disabled="" type="checkbox"> redis方法定义</li><li><input disabled="" type="checkbox"> 获取用户信息</li><li><input disabled="" type="checkbox"> redis存储用户信息</li><li><input disabled="" type="checkbox"> 返回token信息</li></ul></li></ul><h4 id="2023-x2F-04-x2F-27-周四"><a href="#2023-x2F-04-x2F-27-周四" class="headerlink" title="2023/04/27 周四"></a>2023/04/27 周四</h4><ul><li><input disabled="" type="checkbox"> 用户登录</li><li><input disabled="" type="checkbox"> 用户注册</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客社区项目文档</title>
      <link href="/tur-study/2023/04/21/Project/%E5%8D%9A%E5%AE%A2%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/"/>
      <url>/tur-study/2023/04/21/Project/%E5%8D%9A%E5%AE%A2%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><table><thead><tr><th>依赖</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>SpringBoot</td><td>2.7.11</td><td>MVC框架</td></tr><tr><td>SpringCloud</td><td>2021.0.5</td><td>微服务框架</td></tr><tr><td>SpringCloudAlibaba</td><td>2021.0.5.0</td><td>阿里微服务组件</td></tr><tr><td>Mybatis-Plus</td><td></td><td>ORM框架</td></tr><tr><td>Sa-Token</td><td></td><td>轻量级 Java 权限认证框架</td></tr><tr><td>Knife4j</td><td></td><td>接口文档聚合工具</td></tr><tr><td>Kibana</td><td></td><td>分析和可视化平台</td></tr><tr><td>ElasticSearch</td><td></td><td>搜索引擎</td></tr><tr><td>RabbitMQ</td><td></td><td>消息队列</td></tr><tr><td>Redis</td><td></td><td>分布式缓存</td></tr><tr><td>Druid</td><td></td><td>数据库连接池</td></tr><tr><td>七牛云</td><td></td><td>七牛云对象存储</td></tr><tr><td>阿里云</td><td></td><td>阿里云对象存储</td></tr><tr><td>SLF4J</td><td></td><td>日志框架</td></tr><tr><td>Lombok</td><td></td><td>简化对象封装工具</td></tr><tr><td>Nginx</td><td></td><td>Http和反向代理web服务器</td></tr><tr><td>JustAuth</td><td></td><td>第三方登录工具</td></tr><tr><td>Hutool</td><td></td><td>Java工具包类库</td></tr><tr><td>Zipkin</td><td></td><td>链路追踪</td></tr><tr><td>Flexmark-java</td><td></td><td>Markdown转换html</td></tr><tr><td>Ip2region</td><td></td><td>离线IP地址定位库</td></tr><tr><td>Minio</td><td></td><td>本地对象存储服务</td></tr></tbody></table><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm操作命令</title>
      <link href="/tur-study/2023/04/20/Vue/npm%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/tur-study/2023/04/20/Vue/npm%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install --registry=https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>建议不要用cnpm  安装有各种诡异的bug </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinIO使用详解</title>
      <link href="/tur-study/2023/04/19/SpringBoot/MinIO%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/04/19/SpringBoot/MinIO%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>MinIO 是一个非常轻量的服务,可以很简单的 和其他应用的结合使用，它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量 非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等。 </p><p>它一大特点就是<code>轻量</code>，使用简单，功能强大，支持各种平台，单个文件最大 5TB，兼 容 Amazon S3 接口，提供了 Java、Python、GO 等多版本 SDK 支</p><blockquote><p>官网：<a href="https://min.io/">https://min.io</a> </p><p>中文：<a href="https://www.minio.org.cn/%EF%BC%8Chttp://docs.minio.org.cn/docs/">https://www.minio.org.cn/，http://docs.minio.org.cn/docs/</a></p></blockquote><p>MinIO 集群采用<font color="red">去中心化</font>共享架构，每个结点是对等关系，通过 Nginx 可对 MinIO 进 行负载均衡访问</p><blockquote><p>去中心化有什么好处？ </p></blockquote><p>在大数据领域，通常的设计理念都是无中心和分布式。Minio 分布式模式可以帮助你搭 建一个高可用的对象存储服务，你可以使用这些存储设备，而不用考虑其真实物理位 置。</p><p> 它将分布在不同服务器上的多块硬盘组成一个对象存储服务。由于硬盘分布在不同的 节点上，分布式 Minio 避免了单点故障。如下图：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191532888.png"></p><p>Minio 使用<font color="red">纠删码技术</font>来保护数据，它是一种恢复丢失和损坏数据的数学算法，它将数 据分块冗余的分散存储在各各节点的磁盘上，所有的可用磁盘组成一个集合，上图由 8 块硬盘组成一个集合，当上传一个文件时会通过纠删码算法计算对文件进行分块存 储，除了将文件本身分成 4 个数据块，还会生成 4 个校验块，数据块和校验块会分散 的存储在这 8 块硬盘上。 </p><p>使用纠删码的好处是即便丢失一半数量（N/2）的硬盘，仍然可以恢复数据。 比如上 边集合中有 4 个以内的硬盘损害仍可保证数据恢复，不影响上传和下载，如果多于一 半的硬盘坏了则无法恢复。</p><h2 id="二、MinIO数据恢复演示"><a href="#二、MinIO数据恢复演示" class="headerlink" title="二、MinIO数据恢复演示"></a>二、MinIO数据恢复演示</h2><h3 id="2-1-MinIO的运行"><a href="#2-1-MinIO的运行" class="headerlink" title="2.1 MinIO的运行"></a>2.1 MinIO的运行</h3><h4 id="1-下载-MinIO"><a href="#1-下载-MinIO" class="headerlink" title="1. 下载 MinIO"></a>1. 下载 MinIO</h4><blockquote><p>下载地址：<a href="https://dl.min.io/server/minio/release/">https://dl.min.io/server/minio/release/</a></p></blockquote><ol><li>进入下载地址，相应的操作系统选择对应的安装包</li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191536992.png"></p><ol start="2"><li>选择 <code>minio.exe</code> 下载</li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191537689.png" alt="image-20230419153715623"></p><h4 id="2-命令行运行-minio-exe"><a href="#2-命令行运行-minio-exe" class="headerlink" title="2. 命令行运行 minio.exe"></a>2. 命令行运行 minio.exe</h4><blockquote><p>演示系统为：windows</p></blockquote><p>cmd 进入有 minio.exe 的目录。运行下边命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">minio.exe server D:\develop\minio_data\data1 D:\develop\minio_data\data2 D:\develop\minio_data\data3 D:\develop\minio_data\data4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，<code>D:\develop\minio_data\data1、2、3、4</code>为自定义的目录。即数据硬盘，用来存放文件</p><p>启动结果如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191541822.png" alt="image-20230419154123725"></p><p>说明如下：</p><pre class="line-numbers language-none"><code class="language-none">WARNING: MINIO_ACCESS_KEY and MINIO_SECRET_KEY are deprecated. Please use MINIO_ROOT_USER and MINIO_ROOT_PASSWORDFormatting 1st pool, 1 set(s), 4 drives per set.WARNING: Host local has more than 2 drives of set. A host failurewill result in data becoming unavailable.WARNING: Detected default credentials 'minioadmin:minioadmin', we recommend that you change these values with 'MINIO_ROOT_USER' and 'MINIO_ROOT_PASSWORD' environment variabl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>老版本使用的 MINIO_ACCESS_KEY 和 MINIO_SECRET_KEY 不推荐使用，推荐使用 MINIO_ROOT_USER 和 MINIO_ROOT_PASSWORD 设置账号和密码。</li><li>pool 即 minio 节点组成的池子，当前有一个 pool 和 4 个硬盘组成的 set 集合 </li><li>因为集合是 4 个硬盘，大于 2 的硬盘损坏数据将无法恢复。</li><li>账号和密码默认为 minioadmin、minioadmin，可以在环境变量中设置通过 ‘<code>MINIO_ROOT_USER</code>‘ and ‘<code>MINIO_ROOT_PASSWORD</code>‘ 进行设置</li></ol><h4 id="3-MinIO-Web界面"><a href="#3-MinIO-Web界面" class="headerlink" title="3. MinIO Web界面"></a>3. MinIO Web界面</h4><p>浏览器输入 <code>http://localhost:9000</code> 进入web界面</p><blockquote><p>MinIO 的默认端口是 9000</p></blockquote><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191545750.png"></p><p>登陆成功后，下一步创建 bucket，桶，它相当于存储文件的目录，可以创建若干的桶。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191546377.png"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191547579.png" alt="image-20230419154734511"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191547871.png" alt="image-20230419154756833"></p><h4 id="4-文件上传"><a href="#4-文件上传" class="headerlink" title="4. 文件上传"></a>4. 文件上传</h4><p>点击创建的 Bucket 的 <code>upload</code>，上传文件</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191550758.png" alt="image-20230419155036711"></p><p>打开之前建立好的4个数据盘，观察文件的存储情况：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191552498.png" alt="image-20230419155202452"></p><p>可以看到，上传的文件在四个目录上都有存储，即4个硬盘上</p><p>测试：删除一个、两个目录后，删除的目录会自动恢复。但删除三个目录后，有大于一半的数据盘损坏，数据无法恢复，此时报错：We encountered an internal error, please try again. (Read failed. Insufficient number of drives online)在线驱动器数量不足</p><h3 id="2-2-Docker-中安装-minio"><a href="#2-2-Docker-中安装-minio" class="headerlink" title="2.2 Docker 中安装 minio"></a>2.2 Docker 中安装 minio</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p 9000:9000 -p 9090:9090 --name minio \-e "MINIO_ACCESS_KEY=minio" \-e "MINIO_SECRET_KEY=minio123" \-v /home/admin/minio/data:/data \-v /home/admin/minio/config:/root/.minio \minio/minio server /data \--console-address ":9000" --address ":9090"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、SpringBoot-中使用-MinIO"><a href="#三、SpringBoot-中使用-MinIO" class="headerlink" title="三、SpringBoot 中使用 MinIO"></a>三、SpringBoot 中使用 MinIO</h2><p>maven 依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- minio --&gt;</span>                               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>                                     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.minio<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>minio<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>8.5.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>                                                                             <span class="token comment">&lt;!-- okhttp --&gt;</span>                              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>                                     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.squareup.okhttp3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>okhttp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.9.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>                                <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-上传文件"><a href="#3-1-上传文件" class="headerlink" title="3.1 上传文件"></a>3.1 上传文件</h3><ul><li><p>在 MInIO 中创建一个 Bucket</p><p>Bucket 的命名只允许全小写。不允许大写字母</p></li><li><p>将 Access Policy 的权限 private 更改为 public</p></li><li><p>如下是测试上传文件的代码。以上传图片为例</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MinioTest {    private static final MinioClient minioClient = MinioClient.builder()            .endpoint("http://localhost:9090")            .credentials("minio", "minio123")            .build();    public static void upload() throws ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException {        // 判断是否存在Bucket。若不存在则新建        boolean found = minioClient.bucketExists(BucketExistsArgs.builder().bucket("testbucket").build());        if (!found) {            minioClient.makeBucket(MakeBucketArgs.builder().bucket("testbucket").build());        } else {            System.out.println("Bucket is already exists!");        }        // 上传文件        minioClient.uploadObject(UploadObjectArgs.builder()                .bucket("testbucket") // Bucket                .object("list.jpg") // MinIO上文件名                .filename("C:\\Users\\18517\\Desktop\\list.jpg") // 文件地址                .build());        System.out.println("上传成功");    }    public static void main(String[] args) throws ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException {        upload();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>==注意事项：==</p><p>新版的 MinIO 的容器端口是 9000， 而对外的API接口是 9090。即访问 MinIO控制台时使用 9000 端口，而使用 MinIO 进行文件操作时，需要使用 9090 端口</p></blockquote><h3 id="3-2-查询文件"><a href="#3-2-查询文件" class="headerlink" title="3.2 查询文件"></a>3.2 查询文件</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MinioTest {    private static final MinioClient minioClient = MinioClient.builder()            .endpoint("http://1.12.233.28:9090")            .credentials("minio", "minio123")            .build();    public static void getFile() throws ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException {        // 获取文件流        InputStream stream = minioClient.getObject(GetObjectArgs.builder()                        .bucket("testbucket")                        .object("list.jpg")                .build());        // 存放的文件地址        FileOutputStream fileOutputStream = new FileOutputStream(new File("C:\\Users\\18517\\Desktop\\list.jpg"));        // IO流复制        IOUtils.copy(stream, fileOutputStream);        System.out.println("下载成功");    }    public static void main(String[] args) throws ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException {        getFile();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-删除文件"><a href="#3-3-删除文件" class="headerlink" title="3.3 删除文件"></a>3.3 删除文件</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MinioTest {    private static final MinioClient minioClient = MinioClient.builder()            .endpoint("http://1.12.233.28:9090")            .credentials("minio", "minio123")            .build();    public static void delete() throws ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException {        minioClient.removeObject(RemoveObjectArgs.builder()                        .bucket("testbucket")                        .object("list.jpg")                .build());        System.out.println("删除成功");    }    public static void main(String[] args) throws ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException {        delete();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Valid-Validated注解的使用</title>
      <link href="/tur-study/2023/04/18/SpringBoot/@Validated%20@Valid%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/04/18/SpringBoot/@Validated%20@Valid%E6%B3%A8%E8%A7%A3%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux安装常用应用</title>
      <link href="/tur-study/2023/04/18/linux/linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8/"/>
      <url>/tur-study/2023/04/18/linux/linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="安装-jdk"><a href="#安装-jdk" class="headerlink" title="安装 jdk"></a>安装 jdk</h3><h4 id="1-写在-openJDK，安装-Oracle-提供的JDK"><a href="#1-写在-openJDK，安装-Oracle-提供的JDK" class="headerlink" title="1. 写在 openJDK，安装 Oracle 提供的JDK"></a>1. 写在 openJDK，安装 Oracle 提供的JDK</h4>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot Web 注解详解</title>
      <link href="/tur-study/2023/04/14/SpringBoot/SpringBoot%20Web%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/04/14/SpringBoot/SpringBoot%20Web%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>主要用于将请求参数区域的数据映射到控制层方法的参数上</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ol><li><code>value</code>：请求中传入参数的名称，若不设置后台接口的 value 值，则<font color="red">默认为该变量名</font></li><li><code>required</code>：该参数是否为必传项。<ul><li><font color="red">默认是 true</font>，表示请求中一定要传入对应的参数，否则会报<font color="red">404</font> 错误。</li><li>如果设置为 false 时，当请求中没有此参数时，则会默认为 null。二对于基本数据类型的变量，则必须有值，这时会抛出空指针异常。如果允许控制，则接口中变量需要使用包装类来声明，不用 int 而是 Integer 来声明整型数字</li></ul></li><li><code>defaultValue</code>：参数的默认值，如果请求中没有同名的参数时，该变量默认为此值注意默认值可以使用SpEL表达式，如”#{systemProperties[‘java.vm.version’]}”</li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果在请求中传入多个同名参数，比如：<code>url?userName=zhl&amp;userName=holley</code>时怎么办？</p><p>其实此时传入的数据格式是：“zhl,holley”,即多个数据之间使用逗号分隔开，在后台接口中可以使用数组或者list类型的变量来接收：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String requestparam8(@RequestParam(value="userName") String []  userNames) 或者public String requestparam8(@RequestParam(value="list") List&lt;String&gt; list) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis Plus 中CRUD接口注意事项</title>
      <link href="/tur-study/2023/04/13/MybatisPlus/Mybatis%20Plus%20%E4%B8%ADCRUD%E6%8E%A5%E5%8F%A3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/tur-study/2023/04/13/MybatisPlus/Mybatis%20Plus%20%E4%B8%ADCRUD%E6%8E%A5%E5%8F%A3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>官网：<a href="https://baomidou.com/">https://baomidou.com/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mybatis Plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA中创建文件模板</title>
      <link href="/tur-study/2023/04/10/IDEA/IDEA%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF/"/>
      <url>/tur-study/2023/04/10/IDEA/IDEA%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>在 IDEA 中创建适合自己项目的文件模板，可以在新建文件时，免去一些常规重复的操作，如一些类中常添加的注解如@Data、@Builder等等，创建文件时，自动导入这些可以提高些许效率。</p><p>so， 开始吧。</p><p>下面以创建 pojo 模型类为例：</p><p>创建 pojo 模型类时，一般需要添加注解：</p><ul><li>@Data</li><li>@Builder</li><li>@NoArgsConstructor</li><li>@AllArgsConstrustor</li></ul><blockquote><p>至于这些注解的用处，想必都知道</p></blockquote><p>所以，目标便是将添加的注解放入到模板</p><p>步骤如下：</p><h5 id="1-打开：设置-gt-编辑器-gt-文件和代码模板"><a href="#1-打开：设置-gt-编辑器-gt-文件和代码模板" class="headerlink" title="1. 打开：设置 -> 编辑器 -> 文件和代码模板"></a>1. 打开：设置 -&gt; 编辑器 -&gt; 文件和代码模板</h5><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304102117353.png" alt="image-20230410211734116"></p><h5 id="2-在文件栏里新建文件"><a href="#2-在文件栏里新建文件" class="headerlink" title="2. 在文件栏里新建文件"></a>2. 在文件栏里新建文件</h5><ul><li><p>名称的命名随意，建议文件名容易知道它的用处。</p></li><li><p>文件扩展名默认 java。如果需要创建其他类型的需要改动</p></li><li><p>文件名(F)：即新建的类文件的文件名。书写格式如下：<code>$ClassName</code></p><blockquote><p>注：ClassName可以自定义，在新建文件时会出现的新建窗口，填写的值即文件名</p></blockquote></li></ul><h5 id="3-在编辑框里编写模板"><a href="#3-在编辑框里编写模板" class="headerlink" title="3. 在编辑框里编写模板"></a>3. 在编辑框里编写模板</h5><ul><li>添加类的javadoc注释</li><li>添加注解</li><li>添加类的定义</li></ul><p>内容如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import lombok.Builder;/*** @author ${USER}* @date ${DATE} ${TIME}* @description TODO* @version 1.0*/@Data@Builder@AllArgsConstructor@NoArgsConstructorpublic class $ClassName  {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>$ClassName</code> 需要与上方填写的文件名一致，保证文件名和类名一致</p><h5 id="4-创建好的模板如下所示："><a href="#4-创建好的模板如下所示：" class="headerlink" title="4.创建好的模板如下所示："></a>4.创建好的模板如下所示：</h5><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304102124535.png" alt="image-20230410211734116"></p><h5 id="5-模板的使用："><a href="#5-模板的使用：" class="headerlink" title="5. 模板的使用："></a>5. 模板的使用：</h5><blockquote><p>创建好的模板记得点应用</p></blockquote><p>在新建选项可以看到新建的模板出现了：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304102125891.png" alt="image-20230410212516834"></p><p>点击新建的模板，弹出填写 ClassName（文件名）的窗口：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304102126186.png" alt="image-20230410212615151"></p><p>填写你需要的文件名，即可创建成功文件。</p>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间相关类的使用</title>
      <link href="/tur-study/2023/04/10/Java/%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/04/10/Java/%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p><code>Calendar </code>类是一个抽象类，它为特定瞬间与 <code>YEAR、MONTH、DAY_OF—MONTH、HOUR </code>等日历字段之间的转换提供了一些方法，并为操作日历字段（如获得下星期的日期） 提供了一些方法</p><p>在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可</p><h5 id="创建一个代表系统当前日期的-Calendar-对象"><a href="#创建一个代表系统当前日期的-Calendar-对象" class="headerlink" title="创建一个代表系统当前日期的 Calendar 对象"></a>创建一个代表系统当前日期的 Calendar 对象</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">Calendar c = Calendar.getInstance(); //默认是当前日期<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="创建一个指定日期的-Calendar-对象"><a href="#创建一个指定日期的-Calendar-对象" class="headerlink" title="创建一个指定日期的 Calendar 对象"></a>创建一个指定日期的 Calendar 对象</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">//创建一个代表2019年12月22日的Calendar对象Calendar c1 = Calendar.getInstance();c1.set(2019, 12 - 1, 22);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>==注：==<font color="red">月份 - 1 </font>是因为 Calendar 中月份是从 0 开始计数，即一月为0，12月为11</p></blockquote><h3 id="2-Calendar-类对象字段类型"><a href="#2-Calendar-类对象字段类型" class="headerlink" title="2. Calendar 类对象字段类型"></a>2. Calendar 类对象字段类型</h3><p> Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想</p><table><thead><tr><th>常量</th><th>描述</th></tr></thead><tbody><tr><td>Calendar.YEAR</td><td>年份</td></tr><tr><td>Calendar.MONTH</td><td>月份</td></tr><tr><td>Calendar.DATE</td><td>日期</td></tr><tr><td>Calendar.DAY_OF_MONTH</td><td>日期，和上面的字段意义完全相同</td></tr><tr><td>Calendar.HOUR</td><td>12小时制的小时</td></tr><tr><td>Calendar.HOUR_OF_DAY</td><td>24小时制的小时</td></tr><tr><td>Calendar.MINUTE</td><td>分钟</td></tr><tr><td>Calendar.SECOND</td><td>秒</td></tr><tr><td>Calendar.DAY_OF_WEEK</td><td>星期几</td></tr></tbody></table><h3 id="3-Calendar-类对象信息的设置"><a href="#3-Calendar-类对象信息的设置" class="headerlink" title="3. Calendar 类对象信息的设置"></a>3. Calendar 类对象信息的设置</h3><h4 id="3-1-Set-设置"><a href="#3-1-Set-设置" class="headerlink" title="3.1 Set 设置"></a>3.1 Set 设置</h4><p>如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Calendar c1 = Calendar.getInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final void set(int year,int month,int date)c1.set(2009, 6, 12);//把Calendar对象c1的年月日分别设这为：2009、6、12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用字段类型设置</p><p>如果只设定某个字段，例如日期的值，则可以使用如下set方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void set(int field,int value)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">c1.set(Calendar.DATE,10);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">c1.set(Calendar.YEAR,2008);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他字段属性set的意义以此类推</p><h4 id="3-2-Add-设置"><a href="#3-2-Add-设置" class="headerlink" title="3.2 Add 设置"></a>3.2 Add 设置</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">Calendar c1 = Calendar.getInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">c1.add(Calendar.DATE, 10);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">c1.add(Calendar.DATE, -10);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他字段属性的add的意义以此类推</p><h3 id="4-Calendar-类对象信息的获得"><a href="#4-Calendar-类对象信息的获得" class="headerlink" title="4. Calendar 类对象信息的获得"></a>4. Calendar 类对象信息的获得</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">Calendar c1 = Calendar.getInstance();// 获得年份int year = c1.get(Calendar.YEAR);// 获得月份int month = c1.get(Calendar.MONTH) + 1;// 获得日期int date = c1.get(Calendar.DATE);// 获得小时int hour = c1.get(Calendar.HOUR_OF_DAY);// 获得分钟int minute = c1.get(Calendar.MINUTE);// 获得秒int second = c1.get(Calendar.SECOND);// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）int day = c1.get(Calendar.DAY_OF_WEEK);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-GregorianCalendar-类"><a href="#5-GregorianCalendar-类" class="headerlink" title="5. GregorianCalendar 类"></a>5. GregorianCalendar 类</h3><p>Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。</p><p>Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。</p><p>下面列出GregorianCalendar对象的几个构造方法：</p><table><thead><tr><th align="left"><strong>序号</strong></th><th><strong>构造函数和说明</strong></th></tr></thead><tbody><tr><td align="left">1</td><td><strong>GregorianCalendar()</strong>   在具有默认语言环境的默认时区内使用当前时间构造一个默认的 GregorianCalendar。</td></tr><tr><td align="left">2</td><td><strong>GregorianCalendar(int year, int month, int date)</strong>   在具有默认语言环境的默认时区内构造一个带有给定日期设置的 GregorianCalendar</td></tr><tr><td align="left">3</td><td><strong>GregorianCalendar(int year, int month, int date, int hour, int minute)</strong>   为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。</td></tr><tr><td align="left">4</td><td><strong>GregorianCalendar(int year, int month, int date, int hour, int minute, int second)</strong>    为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。</td></tr><tr><td align="left">5</td><td><strong>GregorianCalendar(Locale aLocale)</strong>   在具有给定语言环境的默认时区内构造一个基于当前时间的 GregorianCalendar。</td></tr><tr><td align="left">6</td><td><strong>GregorianCalendar(TimeZone zone)</strong>   在具有默认语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。</td></tr><tr><td align="left">7</td><td><strong>GregorianCalendar(TimeZone zone, Locale aLocale)</strong>    在具有给定语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。</td></tr></tbody></table><p>这里是GregorianCalendar 类提供的一些有用的方法列表：</p><table><thead><tr><th><strong>序号</strong></th><th><strong>方法和说明</strong></th></tr></thead><tbody><tr><td>1</td><td><strong>void add(int field, int amount)</strong>   根据日历规则，将指定的（有符号的）时间量添加到给定的日历字段中。</td></tr><tr><td>2</td><td><strong>protected void computeFields()</strong>   转换UTC毫秒值为时间域值</td></tr><tr><td>3</td><td><strong>protected void computeTime()</strong>   覆盖Calendar ，转换时间域值为UTC毫秒值</td></tr><tr><td>4</td><td><strong>boolean equals(Object obj)</strong>   比较此 GregorianCalendar 与指定的 Object。</td></tr><tr><td>5</td><td><strong>int get(int field)</strong>   获取指定字段的时间值</td></tr><tr><td>6</td><td><strong>int getActualMaximum(int field)</strong>   返回当前日期，给定字段的最大值</td></tr><tr><td>7</td><td><strong>int getActualMinimum(int field)</strong>   返回当前日期，给定字段的最小值</td></tr><tr><td>8</td><td><strong>int getGreatestMinimum(int field)</strong>    返回此 GregorianCalendar 实例给定日历字段的最高的最小值</td></tr><tr><td>9</td><td><strong>Date getGregorianChange()</strong>   获得格里高利历的更改日期。</td></tr><tr><td>10</td><td><strong>int getLeastMaximum(int field)</strong>   返回此 GregorianCalendar 实例给定日历字段的最低的最大值</td></tr><tr><td>11</td><td><strong>int getMaximum(int field)</strong>   返回此 GregorianCalendar 实例的给定日历字段的最大值。</td></tr><tr><td>12</td><td><strong>Date getTime()</strong>  获取日历当前时间。</td></tr><tr><td>13</td><td><strong>long getTimeInMillis()</strong>   获取用长整型表示的日历的当前时间</td></tr><tr><td>14</td><td><strong>TimeZone getTimeZone()</strong>   获取时区。</td></tr><tr><td>15</td><td><strong>int getMinimum(int field)</strong>   返回给定字段的最小值。</td></tr><tr><td>16</td><td><strong>int hashCode()</strong>   重写hashCode.</td></tr><tr><td>17</td><td><strong>boolean isLeapYear(int year)</strong>  确定给定的年份是否为闰年。</td></tr><tr><td>18</td><td><strong>void roll(int field, boolean up)</strong>   在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。</td></tr><tr><td>19</td><td><strong>void set(int field, int value)</strong>   用给定的值设置时间字段。</td></tr><tr><td>20</td><td><strong>void set(int year, int month, int date)</strong>   设置年、月、日的值。</td></tr><tr><td>21</td><td><strong>void set(int year, int month, int date, int hour, int minute)</strong>   设置年、月、日、小时、分钟的值。</td></tr><tr><td>22</td><td><strong>void set(int year, int month, int date, int hour, int minute, int second)</strong>   设置年、月、日、小时、分钟、秒的值。</td></tr><tr><td>23</td><td><strong>void setGregorianChange(Date date)</strong>   设置 GregorianCalendar 的更改日期。</td></tr><tr><td>24</td><td><strong>void setTime(Date date)</strong>   用给定的日期设置Calendar的当前时间。</td></tr><tr><td>25</td><td><strong>void setTimeInMillis(long millis)</strong>   用给定的long型毫秒数设置Calendar的当前时间。</td></tr><tr><td>26</td><td><strong>void setTimeZone(TimeZone value)</strong>   用给定时区值设置当前时区。</td></tr><tr><td>27</td><td><strong>String toString()</strong>   返回代表日历的字符串。</td></tr></tbody></table><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;  public class GregorianCalendarDemo {    public static void main(String[] args) {      String months[] = {      "Jan", "Feb", "Mar", "Apr",      "May", "Jun", "Jul", "Aug",      "Sep", "Oct", "Nov", "Dec"};            int year;      // 初始化 Gregorian 日历      // 使用当前时间和日期      // 默认为本地时间和时区      GregorianCalendar gcalendar = new GregorianCalendar();      // 显示当前时间和日期的信息      System.out.print("Date: ");      System.out.print(months[gcalendar.get(Calendar.MONTH)]);      System.out.print(" " + gcalendar.get(Calendar.DATE) + " ");      System.out.println(year = gcalendar.get(Calendar.YEAR));      System.out.print("Time: ");      System.out.print(gcalendar.get(Calendar.HOUR) + ":");      System.out.print(gcalendar.get(Calendar.MINUTE) + ":");      System.out.println(gcalendar.get(Calendar.SECOND));            // 测试当前年份是否为闰年      if(gcalendar.isLeapYear(year)) {         System.out.println("当前年份是闰年");      }      else {         System.out.println("当前年份不是闰年");      }   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上实例编译运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">Date: Apr 10 2023Time: 11:25:27当前年份不是闰年<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="6-实例：获取从去年这时到现在的日期"><a href="#6-实例：获取从去年这时到现在的日期" class="headerlink" title="6. 实例：获取从去年这时到现在的日期"></a>6. 实例：获取从去年这时到现在的日期</h3><p>在数据统计中，会遇到需要展示从去年这时到现在的所有日期的数据，如：2022-04-11到2023-04-11之间的所有日期，此处展示如何获取一年的日期</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DateUtils {    /**     * 日期格式     * */    public static final String YYYY_MM_DD = "yyyy-MM-dd";    /**     * @description 将date按照指定的格式转换成字符串     * @param date 日期     * @param code 日期格式。如：yyyy-MM-DD hh:mm:ss     * @return java.lang.String    */            public static String formatDate(Date date, String code){        SimpleDateFormat format = new SimpleDateFormat(code);        return format.format(date);    }    public static void main(String[] args) {        List&lt;String&gt; dateList = new ArrayList&lt;&gt;();        Date date = new Date();        // 获取当前日期        Calendar calendar = Calendar.getInstance();        // 指定时间为去年这时。即 year - 1        calendar.add(Calendar.YEAR, -1);        // 将获取时间添加入数组中        dateList.add(DateUtils.formatDate(calendar.getTime(), DateUtils.YYYY_MM_DD));        // 获取下一天日期        while (date.after(calendar.getTime())) { //倒序时间,顺序:after改before其他相应的改动。            calendar.add(Calendar.DAY_OF_MONTH, 1);            dateList.add(DateUtils.formatDate(calendar.getTime(), DateUtils.YYYY_MM_DD));        }        System.out.println(dateList.toString());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例的测试结果为：</p><pre class="line-numbers language-none"><code class="language-none">[2022-04-11, 2022-04-12, 2022-04-13, 2022-04-14, 2022-04-15, 2022-04-16, 2022-04-17, 2022-04-18, 2022-04-19, 2022-04-20, 2022-04-21, 2022-04-22, 2022-04-23, 2022-04-24, 2022-04-25, 2022-04-26, 2022-04-27, 2022-04-28, 2022-04-29, 2022-04-30, 2022-05-01, 2022-05-02, 2022-05-03, 2022-05-04, 2022-05-05, 2022-05-06, 2022-05-07, 2022-05-08, 2022-05-09, 2022-05-10, 2022-05-11, 2022-05-12, 2022-05-13, 2022-05-14, 2022-05-15, 2022-05-16, 2022-05-17, 2022-05-18, 2022-05-19, 2022-05-20, 2022-05-21, 2022-05-22, 2022-05-23, 2022-05-24, 2022-05-25, 2022-05-26, 2022-05-27, 2022-05-28, 2022-05-29, 2022-05-30, 2022-05-31, 2022-06-01, 2022-06-02, 2022-06-03, 2022-06-04, 2022-06-05, 2022-06-06, 2022-06-07, 2022-06-08, 2022-06-09, 2022-06-10, 2022-06-11, 2022-06-12, 2022-06-13, 2022-06-14, 2022-06-15, 2022-06-16, 2022-06-17, 2022-06-18, 2022-06-19, 2022-06-20, 2022-06-21, 2022-06-22, 2022-06-23, 2022-06-24, 2022-06-25, 2022-06-26, 2022-06-27, 2022-06-28, 2022-06-29, 2022-06-30, 2022-07-01, 2022-07-02, 2022-07-03, 2022-07-04, 2022-07-05, 2022-07-06, 2022-07-07, 2022-07-08, 2022-07-09, 2022-07-10, 2022-07-11, 2022-07-12, 2022-07-13, 2022-07-14, 2022-07-15, 2022-07-16, 2022-07-17, 2022-07-18, 2022-07-19, 2022-07-20, 2022-07-21, 2022-07-22, 2022-07-23, 2022-07-24, 2022-07-25, 2022-07-26, 2022-07-27, 2022-07-28, 2022-07-29, 2022-07-30, 2022-07-31, 2022-08-01, 2022-08-02, 2022-08-03, 2022-08-04, 2022-08-05, 2022-08-06, 2022-08-07, 2022-08-08, 2022-08-09, 2022-08-10, 2022-08-11, 2022-08-12, 2022-08-13, 2022-08-14, 2022-08-15, 2022-08-16, 2022-08-17, 2022-08-18, 2022-08-19, 2022-08-20, 2022-08-21, 2022-08-22, 2022-08-23, 2022-08-24, 2022-08-25, 2022-08-26, 2022-08-27, 2022-08-28, 2022-08-29, 2022-08-30, 2022-08-31, 2022-09-01, 2022-09-02, 2022-09-03, 2022-09-04, 2022-09-05, 2022-09-06, 2022-09-07, 2022-09-08, 2022-09-09, 2022-09-10, 2022-09-11, 2022-09-12, 2022-09-13, 2022-09-14, 2022-09-15, 2022-09-16, 2022-09-17, 2022-09-18, 2022-09-19, 2022-09-20, 2022-09-21, 2022-09-22, 2022-09-23, 2022-09-24, 2022-09-25, 2022-09-26, 2022-09-27, 2022-09-28, 2022-09-29, 2022-09-30, 2022-10-01, 2022-10-02, 2022-10-03, 2022-10-04, 2022-10-05, 2022-10-06, 2022-10-07, 2022-10-08, 2022-10-09, 2022-10-10, 2022-10-11, 2022-10-12, 2022-10-13, 2022-10-14, 2022-10-15, 2022-10-16, 2022-10-17, 2022-10-18, 2022-10-19, 2022-10-20, 2022-10-21, 2022-10-22, 2022-10-23, 2022-10-24, 2022-10-25, 2022-10-26, 2022-10-27, 2022-10-28, 2022-10-29, 2022-10-30, 2022-10-31, 2022-11-01, 2022-11-02, 2022-11-03, 2022-11-04, 2022-11-05, 2022-11-06, 2022-11-07, 2022-11-08, 2022-11-09, 2022-11-10, 2022-11-11, 2022-11-12, 2022-11-13, 2022-11-14, 2022-11-15, 2022-11-16, 2022-11-17, 2022-11-18, 2022-11-19, 2022-11-20, 2022-11-21, 2022-11-22, 2022-11-23, 2022-11-24, 2022-11-25, 2022-11-26, 2022-11-27, 2022-11-28, 2022-11-29, 2022-11-30, 2022-12-01, 2022-12-02, 2022-12-03, 2022-12-04, 2022-12-05, 2022-12-06, 2022-12-07, 2022-12-08, 2022-12-09, 2022-12-10, 2022-12-11, 2022-12-12, 2022-12-13, 2022-12-14, 2022-12-15, 2022-12-16, 2022-12-17, 2022-12-18, 2022-12-19, 2022-12-20, 2022-12-21, 2022-12-22, 2022-12-23, 2022-12-24, 2022-12-25, 2022-12-26, 2022-12-27, 2022-12-28, 2022-12-29, 2022-12-30, 2022-12-31, 2023-01-01, 2023-01-02, 2023-01-03, 2023-01-04, 2023-01-05, 2023-01-06, 2023-01-07, 2023-01-08, 2023-01-09, 2023-01-10, 2023-01-11, 2023-01-12, 2023-01-13, 2023-01-14, 2023-01-15, 2023-01-16, 2023-01-17, 2023-01-18, 2023-01-19, 2023-01-20, 2023-01-21, 2023-01-22, 2023-01-23, 2023-01-24, 2023-01-25, 2023-01-26, 2023-01-27, 2023-01-28, 2023-01-29, 2023-01-30, 2023-01-31, 2023-02-01, 2023-02-02, 2023-02-03, 2023-02-04, 2023-02-05, 2023-02-06, 2023-02-07, 2023-02-08, 2023-02-09, 2023-02-10, 2023-02-11, 2023-02-12, 2023-02-13, 2023-02-14, 2023-02-15, 2023-02-16, 2023-02-17, 2023-02-18, 2023-02-19, 2023-02-20, 2023-02-21, 2023-02-22, 2023-02-23, 2023-02-24, 2023-02-25, 2023-02-26, 2023-02-27, 2023-02-28, 2023-03-01, 2023-03-02, 2023-03-03, 2023-03-04, 2023-03-05, 2023-03-06, 2023-03-07, 2023-03-08, 2023-03-09, 2023-03-10, 2023-03-11, 2023-03-12, 2023-03-13, 2023-03-14, 2023-03-15, 2023-03-16, 2023-03-17, 2023-03-18, 2023-03-19, 2023-03-20, 2023-03-21, 2023-03-22, 2023-03-23, 2023-03-24, 2023-03-25, 2023-03-26, 2023-03-27, 2023-03-28, 2023-03-29, 2023-03-30, 2023-03-31, 2023-04-01, 2023-04-02, 2023-04-03, 2023-04-04, 2023-04-05, 2023-04-06, 2023-04-07, 2023-04-08, 2023-04-09, 2023-04-10, 2023-04-11]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sa-Token在微服务中使用</title>
      <link href="/tur-study/2023/04/09/SpringCloud/Sa-Token%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/04/09/SpringCloud/Sa-Token%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="四、微服务中使用-Sa-Token-依赖引入说明"><a href="#四、微服务中使用-Sa-Token-依赖引入说明" class="headerlink" title="四、微服务中使用 Sa-Token 依赖引入说明"></a>四、微服务中使用 Sa-Token 依赖引入说明</h2><blockquote><p>==注意：==<strong>在微服务架构中使用Sa-Token时，网关和内部服务要分开引入Sa-Token依赖（不要直接在顶级父pom中引入Sa-Token）</strong></p></blockquote><p>总体来讲，我们需要关注的依赖就是两个：<code>sa-token-spring-boot-starter</code> 和 <code>sa-token-reactor-spring-boot-starter</code>：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 权限认证，在线文档：https://sa-token.cc --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 权限认证（Reactor响应式集成），在线文档：https://sa-token.cc --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-reactor-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于内部基础服务来讲，我们一般都是使用SpringBoot默认的web模块：SpringMVC， 因为这个SpringMVC是基于Servlet模型的，在这里我们需要引入的是<code>sa-token-spring-boot-starter</code></p><p>对于网关服务，大体来讲分为两种：</p><ul><li>一种是基于Servlet模型的，如：Zuul，我们需要引入的是：<code>sa-token-spring-boot-starter</code>，详细戳：<a href="https://sa-token.cc/doc.html#/start/example">在SpringBoot环境集成</a></li><li>一种是基于Reactor模型的，如：SpringCloud Gateway、ShenYu 等等，我们需要引入的是：<code>sa-token-reactor-spring-boot-starter</code>，<strong>并且注册全局过滤器！</strong>，详细戳：<a href="https://sa-token.cc/doc.html#/start/webflux-example">在WebFlux环境集成</a></li></ul><blockquote><p>注：切不可直接在一个项目里同时引入这两个依赖，否则会造成项目无法启动</p></blockquote><p>另外，我们需要引入Redis集成包，因为我们的网关和子服务主要通过Redis来同步数据 </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 整合 Redis （使用 jackson 序列化方式） --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-dao-redis-jackson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sa-Token </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gateway服务网关</title>
      <link href="/tur-study/2023/04/08/SpringCloud/Gateway%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/"/>
      <url>/tur-study/2023/04/08/SpringCloud/Gateway%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><h3 id="1-为什么需要网关"><a href="#1-为什么需要网关" class="headerlink" title="1.  为什么需要网关"></a>1.  为什么需要网关</h3><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>架构图：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304082115722.png" alt="image-20210714210131152"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h3 id="2-Gateway-快速入门"><a href="#2-Gateway-快速入门" class="headerlink" title="2. Gateway 快速入门"></a>2. Gateway 快速入门</h3><p>基本步骤如下：</p><ol><li>创建SpringBoot工程gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h5 id="1-网关依赖"><a href="#1-网关依赖" class="headerlink" title="1. 网关依赖"></a>1. 网关依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--网关--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-基础配置与路由规则"><a href="#3-基础配置与路由规则" class="headerlink" title="3. 基础配置与路由规则"></a>3. 基础配置与路由规则</h5><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 10010 # 网关端口spring:  application:    name: gateway # 服务名称  cloud:    gateway:      routes: # 网关路由配置        - id: user-service # 路由id，自定义，只要唯一即可          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述实例中将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><blockquote><p>注：lb 负载均衡需要引入 Nacos 才可以使用</p></blockquote><h5 id="5-网关路由的流程图"><a href="#5-网关路由的流程图" class="headerlink" title="5. 网关路由的流程图"></a>5. 网关路由的流程图</h5><p>整个访问的流程如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304082119230.png" alt="image-20210714211742956"></p><p>总结：</p><p>网关搭建步骤：</p><ol><li><p>创建项目，引入nacos服务发现和gateway依赖</p></li><li><p>配置application.yml，包括服务基本信息、nacos地址、路由</p></li></ol><p>路由配置包括：</p><ol><li><p>路由id：路由的唯一标示</p></li><li><p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p></li><li><p>路由断言（predicates）：判断路由的规则，</p></li><li><p>路由过滤器（filters）：对请求或响应做处理</p></li></ol><h3 id="3-断言工厂"><a href="#3-断言工厂" class="headerlink" title="3. 断言工厂"></a>3. 断言工厂</h3><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><p>例如Path=/user/**是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header=X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host=<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method=GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path=/red/{segment},/blue/**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query=name, Jack或者-  Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr=192.168.1.1/24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><blockquote><p>一般只需要掌握Path这种路由工程就可以了。</p></blockquote><h3 id="4-过滤器工厂"><a href="#4-过滤器工厂" class="headerlink" title="4. 过滤器工厂"></a>4. 过滤器工厂</h3><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304082120187.png" alt="image-20210714212312871"></p><h4 id="4-1-路由过滤器种类"><a href="#4-1-路由过滤器种类" class="headerlink" title="4.1 路由过滤器种类"></a>4.1 路由过滤器种类</h4><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><h5 id="4-2-请求头过滤器"><a href="#4-2-请求头过滤器" class="headerlink" title="4.2 请求头过滤器"></a>4.2 请求头过滤器</h5><p>以AddRequestHeader 为例</p><blockquote><p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!</p></blockquote><p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    gateway:      routes:      - id: user-service         uri: lb://userservice         predicates:         - Path=/user/**         filters: # 过滤器        - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p><h5 id="3-4-3-默认过滤器"><a href="#3-4-3-默认过滤器" class="headerlink" title="3.4.3.默认过滤器"></a>3.4.3.默认过滤器</h5><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    gateway:      routes:      - id: user-service         uri: lb://userservice         predicates:         - Path=/user/**      default-filters: # 默认过滤项      - AddRequestHeader=Truth, Itcast is freaking awesome! <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-全局过滤器"><a href="#5-全局过滤器" class="headerlink" title="5. 全局过滤器"></a>5. 全局过滤器</h3><h5 id="5-1-全局过滤器作用"><a href="#5-1-全局过滤器作用" class="headerlink" title="5.1 全局过滤器作用"></a>5.1 全局过滤器作用</h5><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p><p>定义方式是实现GlobalFilter接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface GlobalFilter {    /**     *  处理当前请求，有必要的话通过{@link GatewayFilterChain}将请求交给下一个过滤器处理     *     * @param exchange 请求上下文，里面可以获取Request、Response等信息     * @param chain 用来把请求委托给下一个过滤器      * @return {@code Mono&lt;Void&gt;} 返回标示当前过滤器业务结束     */    Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在filter中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h4 id="5-2-自定义全局过滤器"><a href="#5-2-自定义全局过滤器" class="headerlink" title="5.2 自定义全局过滤器"></a>5.2 自定义全局过滤器</h4><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li><p>参数中是否有authorization，</p></li><li><p>authorization参数值是否为admin</p></li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p>在gateway中定义一个过滤器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package cn.itcast.gateway.filters;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.annotation.Order;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;@Order(-1)@Componentpublic class AuthorizeFilter implements GlobalFilter {    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {        // 1.获取请求参数        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();        // 2.获取authorization参数        String auth = params.getFirst("authorization");        // 3.校验        if ("admin".equals(auth)) {            // 放行            return chain.filter(exchange);        }        // 4.拦截        // 4.1.禁止访问，设置状态码        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);        // 4.2.结束处理        return exchange.getResponse().setComplete();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-过滤器执行顺序"><a href="#5-3-过滤器执行顺序" class="headerlink" title="5.3 过滤器执行顺序"></a>5.3 过滤器执行顺序</h4><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304082122421.png" alt="image-20210714214228409"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><h3 id="6-跨域问题"><a href="#6-跨域问题" class="headerlink" title="6.跨域问题"></a>6.跨域问题</h3><h4 id="6-1-什么是跨域问题"><a href="#6-1-什么是跨域问题" class="headerlink" title="6.1.什么是跨域问题"></a>6.1.什么是跨域问题</h4><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li><p>域名不同： <a href="http://www.taobao.com/">www.taobao.com</a> 和 <a href="http://www.taobao.org/">www.taobao.org</a> 和 <a href="http://www.jd.com/">www.jd.com</a> 和 miaosha.jd.com</p></li><li><p>域名相同，端口不同：localhost:8080和localhost8081</p></li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p><p>解决方案：CORS</p><h4 id="6-2-解决跨域问题"><a href="#6-2-解决跨域问题" class="headerlink" title="6.2 解决跨域问题"></a>6.2 解决跨域问题</h4><p>在gateway服务的application.yml文件中，添加下面的配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    gateway:      # 。。。      globalcors: # 全局的跨域处理        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题        corsConfigurations:          '[/**]':            allowedOrigins: # 允许哪些网站的跨域请求               - "http://localhost:8090"            allowedMethods: # 允许的跨域ajax的请求方式              - "GET"              - "POST"              - "DELETE"              - "PUT"              - "OPTIONS"            allowedHeaders: "*" # 允许在请求中携带的头信息            allowCredentials: true # 是否允许携带cookie            maxAge: 360000 # 这次跨域检测的有效期<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里Java代码规范解读</title>
      <link href="/tur-study/2023/04/06/Java/%E9%98%BF%E9%87%8CJava%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BB/"/>
      <url>/tur-study/2023/04/06/Java/%E9%98%BF%E9%87%8CJava%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、编程规约"><a href="#一、编程规约" class="headerlink" title="一、编程规约"></a>一、编程规约</h2><h3 id="1-1-命名风格"><a href="#1-1-命名风格" class="headerlink" title="1.1 命名风格"></a>1.1 命名风格</h3><h5 id="1-命名起始与结束"><a href="#1-命名起始与结束" class="headerlink" title="1. 命名起始与结束"></a>1. 命名起始与结束</h5><p>规约程度：==【强制】==</p><p>代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束</p><ul><li>反例：<code>_name / __name / $name / name_ / name$ / name__</code></li></ul><h5 id="2-中英文命名"><a href="#2-中英文命名" class="headerlink" title="2. 中英文命名"></a>2. 中英文命名</h5><p>规约程度：==【强制】==</p><p>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</p><blockquote><p>说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式<br>也要避免采用。</p></blockquote><ul><li>正例：<code>alibaba / taobao / youku / hangzhou</code> 等国际通用的名称，可视同英文。</li><li>反例：<code>DaZhePromotion </code>[打折] / <code>getPingfenByName</code>() [评分] / int 某变量 = 3</li></ul><h5 id="3-类名使用-UpperCamelCase"><a href="#3-类名使用-UpperCamelCase" class="headerlink" title="3. 类名使用 UpperCamelCase"></a>3. 类名使用 UpperCamelCase</h5><p>规约程度：==【强制】==</p><p>类名使用 <code>UpperCamelCase </code>风格，但以下情形例外：<code>DO / BO / DTO / VO / AO / PO / UID</code> 等， 后缀需要保持全大写。</p><ul><li>正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion</li><li>反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion</li></ul><h5 id="4-方法名、参数名、成员变量、局部变量：lowerCamelCase-风格"><a href="#4-方法名、参数名、成员变量、局部变量：lowerCamelCase-风格" class="headerlink" title="4. 方法名、参数名、成员变量、局部变量：lowerCamelCase 风格"></a>4. 方法名、参数名、成员变量、局部变量：lowerCamelCase 风格</h5><p>规约程度：==【强制】==</p><p>方法名、参数名、成员变量、局部变量都统一使用 <code>lowerCamelCase </code>风格，必须遵从<br>驼峰形式。</p><ul><li>正例： localValue / getHttpMessage() / inputUserId</li></ul><h5 id="5-常量名"><a href="#5-常量名" class="headerlink" title="5. 常量名"></a>5. 常量名</h5><p>规约程度：==【强制】==</p><p>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</p><ul><li>正例：MAX_STOCK_COUNT</li><li>反例：MAX_COUNT</li></ul><h5 id="6-抽象类名"><a href="#6-抽象类名" class="headerlink" title="6. 抽象类名"></a>6. 抽象类名</h5><p>规约程度：==【强制】==</p><p>抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。</p><h5 id="7-数组表示"><a href="#7-数组表示" class="headerlink" title="7. 数组表示"></a>7. 数组表示</h5><p>规约程度：==【强制】==</p><p>类型与中括号紧挨相连来表示数组。</p><ul><li>正例：定义整形数组 int[] arrayDemo;</li><li>反例：在 main 参数中，使用 String args[]来定义。</li></ul><h5 id="8-POJO-类中的布尔变量"><a href="#8-POJO-类中的布尔变量" class="headerlink" title="8. POJO 类中的布尔变量"></a>8. POJO 类中的布尔变量</h5><p>规约程度：==【强制】==</p><p><font color="red">POJO 类中布尔类型的变量，都不要加 is 前缀</font>，否则部分框架解析会引起序列化错误。建议统一使用 <code>flag </code>结尾</p><ul><li><p>正例：deletedFlag, deleted_flag</p></li><li><p>反例：定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，RPC框架在反向解析的时候，“误以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。</p></li></ul><h5 id="9-软件包名"><a href="#9-软件包名" class="headerlink" title="9. 软件包名"></a>9. 软件包名</h5><p>规约程度：==【强制】==</p><p>包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。</p><ul><li>正例：应用工具类包名为 com.alibaba.ai.util、类名为 MessageUtils（此规则参考 spring<br>的框架结构）</li></ul><h5 id="10-杜绝完全不规范缩写"><a href="#10-杜绝完全不规范缩写" class="headerlink" title="10. 杜绝完全不规范缩写"></a>10. 杜绝完全不规范缩写</h5><p>规约程度：==【强制】==</p><p>杜绝完全不规范的缩写，避免望文不知义。</p><ul><li>反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随<br>意缩写严重降低了代码的可阅读性</li></ul><h5 id="11-任何自定义元素，使用尽量完整的单词组表达"><a href="#11-任何自定义元素，使用尽量完整的单词组表达" class="headerlink" title="11. 任何自定义元素，使用尽量完整的单词组表达"></a>11. 任何自定义元素，使用尽量完整的单词组表达</h5><p>规约程度：==【推荐】==</p><p>为了达到代码自解释的目标，任何自定义编程元素在命名时，使用尽量完整的单词组合来表达其意</p><ul><li>正例：在 JDK 中，表达原子更新的类名为：AtomicReferenceFieldUpdater。</li><li>反例：变量 int a 的随意命名方式。</li></ul><h5 id="12-若-使用了设计模式，则应体现在命名上"><a href="#12-若-使用了设计模式，则应体现在命名上" class="headerlink" title="12.若 使用了设计模式，则应体现在命名上"></a>12.若 使用了设计模式，则应体现在命名上</h5><p>规约程度：==【推荐】==</p><p>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式</p><blockquote><p>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。</p></blockquote><ul><li>正例：<ul><li>public class OrderFactory;  </li><li>public class LoginProxy;  </li><li>public class ResourceObserver;</li></ul></li></ul><h5 id="13-接口类方法属性修饰符"><a href="#13-接口类方法属性修饰符" class="headerlink" title="13. 接口类方法属性修饰符"></a>13. 接口类方法属性修饰符</h5><p>规约程度：==【推荐】==</p><p>接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。</p><ul><li>正例：接口方法签名 void commit();   接口基础常量 String COMPANY = “alibaba”;</li><li>反例：接口方法定义 public abstract void f();</li></ul><blockquote><p>说明：JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默<br>认实现。 </p></blockquote><h5 id="14-接口和其实现类的命名"><a href="#14-接口和其实现类的命名" class="headerlink" title="14. 接口和其实现类的命名"></a>14. 接口和其实现类的命名</h5><p>接口和实现类的命名有两套规则：</p><h6 id="1-Service-和-DAO-类"><a href="#1-Service-和-DAO-类" class="headerlink" title="1.  Service 和 DAO 类"></a>1.  Service 和 DAO 类</h6><p>规约程度：==【强制】==</p><p>对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。</p><ul><li>正例：CacheServiceImpl 实现 CacheService 接口。</li></ul><h6 id="2-形容能力的接口名称"><a href="#2-形容能力的接口名称" class="headerlink" title="2. 形容能力的接口名称"></a>2. 形容能力的接口名称</h6><p>规约程度：==【推荐】==</p><p>如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形式）。</p><ul><li>正例：AbstractTranslator 实现 Translatable 接口。</li></ul><h5 id="15-枚举类"><a href="#15-枚举类" class="headerlink" title="15. 枚举类"></a>15. 枚举类</h5><p>规约程度：==【参考】==</p><p>枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</p><blockquote><p>说明：枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有。</p></blockquote><ul><li>正例：枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON。</li></ul><h5 id="16-各层命名"><a href="#16-各层命名" class="headerlink" title="16. 各层命名"></a>16. 各层命名</h5><p>规约程度：==【参考】==</p><h6 id="1-Service-x2F-DAO-层方法命名规约"><a href="#1-Service-x2F-DAO-层方法命名规约" class="headerlink" title="1. Service/DAO 层方法命名规约"></a>1. Service/DAO 层方法命名规约</h6><ul><li>获取单个对象的方法用 get 做前缀。</li><li>获取多个对象的方法用 list 做前缀，复数形式结尾如：listObjects。</li><li>获取统计值的方法用 count 做前缀。</li><li>插入的方法用 save/insert 做前缀。</li><li>删除的方法用 remove/delete 做前缀。</li><li>修改的方法用 update 做前缀。</li></ul><h6 id="2-领域模型命名规约"><a href="#2-领域模型命名规约" class="headerlink" title="2. 领域模型命名规约"></a>2. 领域模型命名规约</h6><ul><li>数据对象：xxxDO，xxx 即为 数据表名。</li><li>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</li><li>展示对象：xxxVO，xxx 一般为网页名称。</li><li>POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。</li></ul><h3 id="1-2-常量定义"><a href="#1-2-常量定义" class="headerlink" title="1.2 常量定义"></a>1.2 常量定义</h3><h5 id="1-不允许任何魔法值"><a href="#1-不允许任何魔法值" class="headerlink" title="1. 不允许任何魔法值"></a>1. 不允许任何魔法值</h5><p>规约程度：==【强制】==</p><p>不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。</p><ul><li>反例：String key = <font color="cyan">“Id#taobao_”</font> + tradeId;cache.put(key, value);</li></ul><h5 id="2-long-或-Long-赋值时，数值后使用大写-L"><a href="#2-long-或-Long-赋值时，数值后使用大写-L" class="headerlink" title="2. long 或 Long 赋值时，数值后使用大写 L"></a>2. long 或 Long 赋值时，数值后使用大写 L</h5><p>规约程度：==【强制】==</p><p>在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字1 混淆，造成误解</p><blockquote><p>说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2?</p></blockquote><h5 id="3-常量功能分类"><a href="#3-常量功能分类" class="headerlink" title="3. 常量功能分类"></a>3. 常量功能分类</h5><p>规约程度：==【推荐】==</p><p>不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。</p><blockquote><p>说明：大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解和维护。</p></blockquote><ul><li>正例：缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。</li></ul><h5 id="4-常量复用"><a href="#4-常量复用" class="headerlink" title="4. 常量复用"></a>4. 常量复用</h5><p>规约程度：==【推荐】==</p><p>常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量</p><h6 id="1-跨应用共享常量"><a href="#1-跨应用共享常量" class="headerlink" title="1. 跨应用共享常量"></a>1. 跨应用共享常量</h6><p>放置在二方库中，通常是 client.jar 中的 constant 目录下。</p><h6 id="2-应用内共享常量"><a href="#2-应用内共享常量" class="headerlink" title="2.应用内共享常量"></a>2.应用内共享常量</h6><p>放置在一方库中，通常是子模块中的 constant 目录下。</p><p>反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示<br>“是”的变量：</p><ul><li>类 A 中：public static final String YES = “yes”;</li><li>类 B 中：public static final String YES = “y”; </li><li>A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。</li></ul><h6 id="3-子工程内部共享常量"><a href="#3-子工程内部共享常量" class="headerlink" title="3.子工程内部共享常量"></a>3.子工程内部共享常量</h6><p>即在当前子工程的 constant 目录下</p><h6 id="4-包内共享常量"><a href="#4-包内共享常量" class="headerlink" title="4.包内共享常量"></a>4.包内共享常量</h6><p>即在当前包下单独的 constant 目录下</p><h6 id="5-类内共享常量"><a href="#5-类内共享常量" class="headerlink" title="5. 类内共享常量"></a>5. 类内共享常量</h6><p>直接在类内部 private static final 定义</p><h5 id="5-固定范围变化的变量使用-enum-来定义"><a href="#5-固定范围变化的变量使用-enum-来定义" class="headerlink" title="5. 固定范围变化的变量使用 enum 来定义"></a>5. 固定范围变化的变量使用 enum 来定义</h5><p>规约程度：==【推荐】==</p><p>如果变量值仅在一个固定范围内变化用 enum 类型来定义</p><p>说明：如果存在名称之外的延伸属性应使用 enum 类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public enum SeasonEnum{    SPRING(1), SUMMER(2), AUTUMN(3), WINTER(4);    private int seq;    SeasonEnum(int seq){        this.seq = se    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>报错合集</title>
      <link href="/tur-study/2023/04/05/%E6%8A%A5%E9%94%99%E5%90%88%E9%9B%86/"/>
      <url>/tur-study/2023/04/05/%E6%8A%A5%E9%94%99%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p><span class="github-emoji"><span>🦊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f98a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>希望每天都没有bug</p></blockquote><h2 id="一、SpringBoot"><a href="#一、SpringBoot" class="headerlink" title="一、SpringBoot"></a>一、SpringBoot</h2><h3 id="1-No-serializer-found-for-class-java-util-Collections-3-and-no-properties-discovered-to-create-BeanSerializer"><a href="#1-No-serializer-found-for-class-java-util-Collections-3-and-no-properties-discovered-to-create-BeanSerializer" class="headerlink" title="1. No serializer found for class java.util.Collections$3 and no properties discovered to create BeanSerializer"></a>1. No serializer found for class java.util.Collections$3 and no properties discovered to create BeanSerializer</h3><h4 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h4><p>使用fasyjson，在全局拦截器的时候，出现：</p><pre><code>No serializer found for class java.util.Collections$3 and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: org.apache.catalina.connector.RequestFacade[1]-&gt;o</code></pre><p>显示序列化，但我实现了序列化，还是有错，由于请求参数为空，所以传入了一个空对象，而fastjson无法解析，就抛出了异常</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在配置文件中添加如下配置，忽略对于参数是否为空的检测</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  jackson:    serialization:      FAIL_ON_EMPTY_BEANS: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：从报错信息上看，忽略参数是否为空检测是不推荐的，但暂未找到其他好的办法  <span class="github-emoji"><span>🙁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f641.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></blockquote><h3 id="2-循环依赖报错"><a href="#2-循环依赖报错" class="headerlink" title="2. 循环依赖报错"></a>2. 循环依赖报错</h3><h4 id="问题背景-1"><a href="#问题背景-1" class="headerlink" title="问题背景"></a>问题背景</h4><p>两个 Bean 中互相依赖对象，形成闭环，如 A 中引入了 B，B 中也引入了 A，这会导致 Spring 无法知道先加载哪一个，从而报错</p><pre class="line-numbers language-none"><code class="language-none">The dependencies of some of the beans in the application context form a cycle:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1. 修改配置文件"></a>1. 修改配置文件</h5><p>根据Action 中的提示删除依赖之间的关系循环</p><blockquote><p>不鼓励依赖循环引用，默认情况下禁止循环引用。更新应用程序以删除 Bean 之间的依赖关系循环。作为最后的手段，可以通过将  spring.main.allow-circular-references 设置为 true  来自动打破循环。因此可以在yml配置文件中设置来打破循环依赖</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:    main:        allow-circular-references: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="2-添加注解，延迟加载"><a href="#2-添加注解，延迟加载" class="headerlink" title="2. 添加注解，延迟加载"></a>2. 添加注解，延迟加载</h5><p>由于在循环依赖中，Spring在初始化的时候不知道先加载哪个bean，因此可以通过使用@Lazy注解，放在其中一个bean上，让这个bean延迟加载，另一个bean就会先加载，进而解决循环依赖问题</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304091543949.png" alt="image-20230409154347678"></p><h2 id="二、SpringCloud"><a href="#二、SpringCloud" class="headerlink" title="二、SpringCloud"></a>二、SpringCloud</h2><h3 id="1-No-spring-config-import-property-has-been-defined"><a href="#1-No-spring-config-import-property-has-been-defined" class="headerlink" title="1. No spring.config.import property has been defined"></a>1. No spring.config.import property has been defined</h3><h4 id="问题背景-2"><a href="#问题背景-2" class="headerlink" title="问题背景"></a>问题背景</h4><p>在我们配置spring cloud config的客户端映射时，启动项目之后出现No spring.config.import property has been defined的问题，如图：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052228437.png" alt="image-20230405222859110"></p><p>产生问题的原因是bootstrap.properties比application.properties的优先级要高<br>由于bootstrap.properties是系统级的资源配置文件，是用在程序引导执行时更加早期配置信息读取；<br>而application.properties是用户级的资源配置文件，是用来后续的一些配置所需要的公共参数。<br>但是在SpringCloud 2020.* 版本把bootstrap禁用了，导致在读取文件的时候读取不到而报错，所以我们只要把bootstrap从新导入进来就会生效了。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- bootstrap --&gt;</span>                                          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>                                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-bootstrap<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>                                               <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：若是父工程中没有添加cloud依赖的，此处需要添加版本，有则不需要</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 错误 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos的配置与使用</title>
      <link href="/tur-study/2023/04/05/SpringCloud/Nacos%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/04/05/SpringCloud/Nacos%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介与启动"><a href="#一、简介与启动" class="headerlink" title="一、简介与启动"></a>一、简介与启动</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>Nacos 是 SpringCloudAlibaba 中的一个组件，相比 Eureka 功能更加丰富</p><ul><li>Nacos 官网：<a href="https://nacos.io/zh-cn/">https://nacos.io/zh-cn/</a></li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052242845.png" alt="image-20230405224257780"></p><ul><li>Github 主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></li></ul><blockquote><p>==注意：==下载 nacos 时，要注意<font color="red"> 版本匹配</font>。版本需要与 SpringCloud、SpringBoot 对应，可以查看 github 上 spring-cloud-alibaba 的版本说明。地址：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a></p></blockquote><h3 id="1-2-启动"><a href="#1-2-启动" class="headerlink" title="1.2 启动"></a>1.2 启动</h3><ol><li>进入下载好的 nacos-server 文件夹下 bin 文件下：<code>start.cmd</code>就是 window 下启动的脚本</li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052259834.png" alt="image-20230405225936791"></p><ol start="2"><li>进入 cmd 命令控制台，输入一下命令：<code>start.cmd -m standalone</code> 启动 nacos</li></ol><blockquote><p>==注意：==cmd 需要进入 nacos 的 bin 文件夹，在执行命令</p></blockquote><ol start="3"><li>启动：</li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052301082.png" alt="image-20230405230141041"></p><p>提示信息出现 successfully 表示启动成功，访问<code>localhost:8848</code>，打开 nacos 配置页面</p><blockquote><p>==注意：==由于是在命令控制台中启动 nacos ，所以不能关闭此窗口，否则无法 访问 nacos</p></blockquote><h2 id="二、注册中心"><a href="#二、注册中心" class="headerlink" title="二、注册中心"></a>二、注册中心</h2><h3 id="2-1-注册服务到-nacos"><a href="#2-1-注册服务到-nacos" class="headerlink" title="2.1 注册服务到 nacos"></a>2.1 注册服务到 nacos</h3><p>步骤如下：</p><h4 id="2-1-1-引入依赖"><a href="#2-1-1-引入依赖" class="headerlink" title="2.1.1  引入依赖"></a>2.1.1  引入依赖</h4><h5 id="1-父工程引入-SpringCloudAlibaba-的依赖"><a href="#1-父工程引入-SpringCloudAlibaba-的依赖" class="headerlink" title="1. 父工程引入 SpringCloudAlibaba 的依赖"></a>1. 父工程引入 SpringCloudAlibaba 的依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2021.0.5.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>==注意：==</p><ul><li><code>&lt;type&gt;pom&lt;/type&gt;</code> 与 <code>&lt;scope&gt;import&lt;scope&gt;</code> 必须添加，否则子工程无法引入依赖</li><li>版本需要与 SpringCloud、SpringBoot 对应，可以查看 github 上 spring-cloud-alibaba 的版本说明。地址：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a></li></ul></blockquote><h5 id="2-子工程引入-nacos-discovery-依赖"><a href="#2-子工程引入-nacos-discovery-依赖" class="headerlink" title="2. 子工程引入 nacos-discovery 依赖"></a>2. 子工程引入 nacos-discovery 依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-配置-nacos-地址"><a href="#2-1-2-配置-nacos-地址" class="headerlink" title="2.1.2 配置 nacos 地址"></a>2.1.2 配置 nacos 地址</h4><p>在所需要注册的服务工程的 <code>application.yml</code> 中添加 nacos 地址：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848 # 8848是默认端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>重启服务工程后可以在 nacos 管理页面看到微服务信息：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052257618.png" alt="image-20230405225720564"></p><h3 id="2-2-环境隔离"><a href="#2-2-环境隔离" class="headerlink" title="2.2 环境隔离"></a>2.2 环境隔离</h3><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052304031.png" alt="image-20230405230442932"></p><blockquote><p>创建 namespace ，就不用记录了</p></blockquote><p>下面给微服务配置 namespace</p><p>给微服务配置namespace只能通过修改配置来实现。</p><p>修改 application.yml文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令空间 ID 是在创建 namespace 时，若没有指定则自动生成，可以指定为与 namespace 名一样。</p><p>如：namespace 为 dev</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        namespace: dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、Nacos-配置管理"><a href="#三、Nacos-配置管理" class="headerlink" title="三、Nacos 配置管理"></a>三、Nacos 配置管理</h2><h3 id="3-1-统一配置管理"><a href="#3-1-统一配置管理" class="headerlink" title="3.1 统一配置管理"></a>3.1 统一配置管理</h3><p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052315538.png" alt="image-20230405231526486"></p><h4 id="3-1-1-在-nacos-中添加配置文件"><a href="#3-1-1-在-nacos-中添加配置文件" class="headerlink" title="3.1.1 在 nacos 中添加配置文件"></a>3.1.1 在 nacos 中添加配置文件</h4><p>点击加号：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052316484.png" alt="image-20230405231635432"></p><p>在弹出的表单中，填写配置信息：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052317615.png" alt="image-20230405231721564"></p><blockquote><p>==注意：==项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p></blockquote><h4 id="3-1-2-从-nacos-拉取配置"><a href="#3-1-2-从-nacos-拉取配置" class="headerlink" title="3.1.2 从 nacos 拉取配置"></a>3.1.2 从 nacos 拉取配置</h4><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p><p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p><p>因此spring引入了一种新的配置文件：<code>bootstrap.yml</code>文件，会在<code>application.yml</code>之前被读取，流程如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052318308.png" alt="img"></p><h5 id="1-引入-nacos-config-依赖"><a href="#1-引入-nacos-config-依赖" class="headerlink" title="1. 引入 nacos-config 依赖"></a>1. 引入 nacos-config 依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--nacos配置管理依赖--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-添加-bootstrap-yml"><a href="#2-添加-bootstrap-yml" class="headerlink" title="2. 添加 bootstrap.yml"></a>2. 添加 bootstrap.yml</h5><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  application:    name: userservice # 服务名称  profiles:    active: dev #开发环境，这里是dev   cloud:    nacos:      server-addr: localhost:8848 # Nacos地址      config:        file-extension: yml # 文件后缀名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052320342.png" alt="image-20210714170845901"></p><h5 id="3-读取配置"><a href="#3-读取配置" class="headerlink" title="3. 读取配置"></a>3. 读取配置</h5><p>跟读取 application.yml 中值的读取一样，使用 <code>@Value</code> 注解</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052322094.png" alt="image-20210714170337448"></p><h3 id="3-2-配置热更新"><a href="#3-2-配置热更新" class="headerlink" title="3.2 配置热更新"></a>3.2 配置热更新</h3><h4 id="3-2-1-方式一"><a href="#3-2-1-方式一" class="headerlink" title="3.2.1 方式一"></a>3.2.1 方式一</h4><p>在<code>@Value</code>注入的变量所在类上添加注解<code>@RefreshScope：</code></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052322744.png" alt="image-20210714171036335"></p><h4 id="3-2-2-方式二"><a href="#3-2-2-方式二" class="headerlink" title="3.2.2 方式二"></a>3.2.2 方式二</h4><p>使用<code>@ConfigurationProperties</code>注解代替<code>@Value</code>注解。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@Data@ConfigurationProperties(prefix = "pattern")public class PatternProperties {    private String dateformat;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在UserController中使用这个类代替@Value：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052323568.png" alt="image-20210714171316124"></p><h3 id="3-3-配置共享"><a href="#3-3-配置共享" class="headerlink" title="3.3 配置共享"></a>3.3 配置共享</h3><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p></li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享，故而可以用来配置一些公共配置</p><p><strong>配置共享的优先级：</strong></p><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052324369.png" alt="image-20210714174623557"></p><h3 id="3-4-搭建-Nacos-集群"><a href="#3-4-搭建-Nacos-集群" class="headerlink" title="3.4 搭建 Nacos 集群"></a>3.4 搭建 Nacos 集群</h3><hr><h2 id="四、Nacos使用报错合集"><a href="#四、Nacos使用报错合集" class="headerlink" title="四、Nacos使用报错合集"></a>四、Nacos使用报错合集</h2><h3 id="1-Client-not-connected-current-status-STARTING-StatusRuntimeException"><a href="#1-Client-not-connected-current-status-STARTING-StatusRuntimeException" class="headerlink" title="1. Client not connected,current status:STARTING,StatusRuntimeException"></a>1. Client not connected,current status:STARTING,StatusRuntimeException</h3><p>Nacos报错：<code>Client not connected,current status:STARTING,StatusRuntimeException</code></p><p>解决办法：降低 nacos-client 版本</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.nacos<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>nacos-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.nacos<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>nacos-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.4.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tur-blog项目文档</title>
      <link href="/tur-study/2023/04/05/Project/tur-blog%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/"/>
      <url>/tur-study/2023/04/05/Project/tur-blog%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>个人博客项目文档</p></blockquote><h2 id="1-依赖版本说明"><a href="#1-依赖版本说明" class="headerlink" title="1. 依赖版本说明"></a>1. 依赖版本说明</h2><table><thead><tr><th>依赖</th><th>版本</th><th>官网</th></tr></thead><tbody><tr><td>SpringBoot</td><td>2.6.13.RELEASE</td><td></td></tr><tr><td>SpringCloud</td><td>2021.0.5</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解@Transactional的用法详解</title>
      <link href="/tur-study/2023/04/04/SpringBoot/%E6%B3%A8%E8%A7%A3-Transactional%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/04/04/SpringBoot/%E6%B3%A8%E8%A7%A3-Transactional%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>@Transactional</code> 注解可以保证方法内多个数据库操作要么同时成功、要么同时失败。但使用 <code>@Transactional</code> 注解需要注意许多细节，不然注解就会失效</p></blockquote><h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><p>事务管理在系统开发中是不可缺少的一部分，Spring 提供了很好的事务管理机制，主要分为：编程式事务和声明式事务</p><h3 id="1-1-编程式事务"><a href="#1-1-编程式事务" class="headerlink" title="1.1 编程式事务"></a>1.1 编程式事务</h3><p>指在代码中手动管理事务的提交、回滚等操作，代码侵入性比较强</p><p>示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void test() {      TransactionDefinition def = new DefaultTransactionDefinition();      TransactionStatus status = transactionManager.getTransaction(def);       try {         // 事务操作         // 事务提交         transactionManager.commit(status);       } catch (DataAccessException e) {         // 事务回滚         transactionManager.rollback(status);         throw e;       }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码，开发者可以通过 API 自己控制事务</p><h3 id="1-2-声明式事务"><a href="#1-2-声明式事务" class="headerlink" title="1.2 声明式事务"></a>1.2 声明式事务</h3><p>声明式事务基于 <code>AOP 面向切面</code>的，将具体业务域事务处理部分解耦，代码侵入性很低，在实际开发中使用较多。</p><p>声明式事务有两种实现方式：</p><ul><li>基于 TX 和 AOP 的 <code>xml 配置文件</code>方式</li><li>基于 <code>@Transactional</code> 注解</li></ul><p>声明式事务对代码没有侵入性，方法内只需要写业务逻辑就可以了，帮助我们节省了很多代码，他会自动帮我们进行事务的开启、提交以及回滚等操作，把程序员从事务管理中解放出来。可以说优点很明显，但是这种方式的缺点也很明显</p><h5 id="1-问题一：声明式事务的粒度问题"><a href="#1-问题一：声明式事务的粒度问题" class="headerlink" title="1. 问题一：声明式事务的粒度问题"></a>1. 问题一：声明式事务的粒度问题</h5><p>声明式事务有一个局限，就是它的最小粒度要作用在方法上。</p><p>也就是说，如果想要给一部分代码增加事务的话，就需要把这部分代码块单独出来作为一个方法。</p><blockquote><p>在大事务耗时过长需要高并发优化的情况下不建议使用声明式事务，建议采用上面提到的编程式事务</p></blockquote><h5 id="2-问题二：声明式事务容易被开发者忽略"><a href="#2-问题二：声明式事务容易被开发者忽略" class="headerlink" title="2. 问题二：声明式事务容易被开发者忽略"></a>2. 问题二：声明式事务容易被开发者忽略</h5><p>而事务一旦被忽略就容易造成很多故障</p><p>首先，如果开发者没有注意到一个方法是被事务嵌套的，那么就可能会再方法中加入一些如RPC远程调用、消息发送、缓存更新、文件写入等操作。</p><p>我们知道，这些操作如果被包在事务中，有两个问题：</p><p>1、这些操作自身是无法回滚的，这就会导致数据的不一致。可能RPC调用成功了，但是本地事务回滚了，可是PRC调用无法回滚了(这里不讨论分布式事务)。</p><p>2、在事务中有远程调用，就会拉长整个事务。那么久会导致本事务的数据库连接一直被占用，那么如果类似操作过多，就会导致数据库连接池耗尽。</p><p>有些时候，即使没有在事务中进行远程操作，但是有些人还是可能会不经意的进行一些内存操作，如运算。或者如果遇到分库分表的情况，有可能不经意间进行跨库操作。</p><h5 id="3-问题三：声明式事务用错，在某些场景下容易失效"><a href="#3-问题三：声明式事务用错，在某些场景下容易失效" class="headerlink" title="3. 问题三：声明式事务用错，在某些场景下容易失效"></a>3. 问题三：声明式事务用错，在某些场景下容易失效</h5><p>后面有详细介绍</p><h2 id="二、-Transactional-介绍"><a href="#二、-Transactional-介绍" class="headerlink" title="二、@Transactional 介绍"></a>二、@Transactional 介绍</h2><h3 id="2-1-Transactional-可以作用在接口、类、类方法上"><a href="#2-1-Transactional-可以作用在接口、类、类方法上" class="headerlink" title="2.1 @Transactional 可以作用在接口、类、类方法上"></a>2.1 @Transactional 可以作用在接口、类、类方法上</h3><ol><li>作用于类：表示该类的所有 public 方法都配置相同的事属性信息</li><li>作用于方法：当类、方法都配置了 @Transactional 时，方法的事务回覆盖类的事务配置信息</li><li>作用于接口：不推荐这种使用方法。因为一旦标注在接口上并且配置了 SpringAOP 使用 CGLib 动态代理，将会导致 @Transactional 失效</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional                                                              @RestController                                                             @RequestMapping                                                             public class MybatisPlusController {                                            @Autowired                                                                  private CityInfoDictMapper cityInfoDictMapper;                                                                                                          @Transactional(rollbackFor = Exception.class)                       @GetMapping("/test")                                                        public String test() throws Exception {                                          CityInfoDict cityInfoDict = new CityInfoDict();                      cityInfoDict.setParentCityId(2);                                     cityInfoDict.setCityName("2");                                       cityInfoDict.setCityLevel("2");                                      cityInfoDict.setCityCode("2");                                       int insert = cityInfoDictMapper.insert(cityInfoDict);                return insert + "";                                              }                                                               }                                                                           <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-Transactional-注解的属性"><a href="#2-2-Transactional-注解的属性" class="headerlink" title="2.2 @Transactional 注解的属性"></a>2.2 @Transactional 注解的属性</h3><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>可选的限定描述符，指定使用的事务管理器</td></tr><tr><td>propagation</td><td>enum: Propagation</td><td>可选的事务传播行为设置</td></tr><tr><td>isolation</td><td>enum: Isolation</td><td>可选的事务隔离级别设置</td></tr><tr><td>readOnly</td><td>boolean</td><td>读写或只读事务，默认读写</td></tr><tr><td>timeout</td><td>int (in seconds granularity)</td><td>事务超时时间设置</td></tr><tr><td>rollbackFor</td><td>Class对象数组，必须继承自Throwable</td><td>导致事务回滚的异常类数组</td></tr><tr><td>rollbackForClassName</td><td>类名数组，必须继承自Throwable</td><td>导致事务回滚的异常类名字数组</td></tr><tr><td>noRollbackFor</td><td>Class对象数组，必须继承自Throwable</td><td>不会导致事务回滚的异常类数组</td></tr><tr><td>noRollbackForClassName</td><td>类名数组，必须继承自Throwable</td><td>不会导致事务回滚的异常类名字数组</td></tr></tbody></table><h5 id="1-propagation-属性"><a href="#1-propagation-属性" class="headerlink" title="1. propagation 属性"></a>1. propagation 属性</h5><p><code>propagation </code>属性代表事务的传播行为，默认值为：<code>Propagation.REQUIRED</code>。其他属性信息如下：</p><table><thead><tr><th>Propagation.REQUIRED</th><th>如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。( 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 ）</th></tr></thead><tbody><tr><td>Propagation.SUPPORTS</td><td>如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</td></tr><tr><td>Propagation.MANDATORY</td><td>如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</td></tr><tr><td>Propagation.REQUIRES_NEW</td><td>重新创建一个新的事务，如果当前存在事务，暂停当前的事务。( 当类A中的 a 方法用默认Propagation.REQUIRED模式，类B中的 b方法加上采用  Propagation.REQUIRES_NEW模式，然后在 a 方法中调用 b方法操作数据库，然而  a方法抛出异常后，b方法并没有进行回滚，因为Propagation.REQUIRES_NEW会暂停 a方法的事务 )</td></tr><tr><td>Propagation.NOT_SUPPORTED</td><td>以非事务的方式运行，如果当前存在事务，暂停当前的事务。</td></tr><tr><td>Propagation.NEVER</td><td>以非事务的方式运行，如果当前存在事务，则抛出异常。</td></tr><tr><td>Propagation.NESTED</td><td>和 Propagation.REQUIRED 效果一样。</td></tr></tbody></table><h5 id="2-isolation-属性"><a href="#2-isolation-属性" class="headerlink" title="2. isolation 属性"></a>2. isolation 属性</h5><p><code>isolation </code>属性：事务的隔离级别，默认值为<code> Isolation.DEFAULT</code></p><ul><li><code>Isolation.DEFAULT</code>：使用底层数据库默认的隔离级别。</li><li><code>Isolation.READ_UNCOMMITTED</code></li><li><code>Isolation.READ_COMMITTED</code></li><li><code>Isolation.REPEATABLE_READ</code></li><li><code>Isolation.SERIALIZABLE</code></li></ul><h5 id="3-timeout-属性"><a href="#3-timeout-属性" class="headerlink" title="3. timeout 属性"></a>3. timeout 属性</h5><p><code>timeout </code>：事务的超时时间，默认值为 -1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</p><blockquote><p>事务超时，就会报错 TransactionTimedOutException:</p></blockquote><h5 id="4-readOnly-属性"><a href="#4-readOnly-属性" class="headerlink" title="4. readOnly 属性"></a>4. readOnly 属性</h5><p><code>readOnly </code>：指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</p><h5 id="5-rollbackFor-属性"><a href="#5-rollbackFor-属性" class="headerlink" title="5. rollbackFor 属性"></a>5. rollbackFor 属性</h5><p><code>rollbackFor </code>：用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</p><h5 id="6-noRollbackFor属性"><a href="#6-noRollbackFor属性" class="headerlink" title="6. noRollbackFor属性"></a>6. noRollbackFor属性</h5><p><code>noRollbackFor</code>：抛出指定的异常类型，不回滚事务，也可以指定多个异常类型</p><h2 id="三、-Transactional-失效场景"><a href="#三、-Transactional-失效场景" class="headerlink" title="三、@Transactional 失效场景"></a>三、@Transactional 失效场景</h2><h3 id="3-1-Transactional-应用在非-public修饰的方法上"><a href="#3-1-Transactional-应用在非-public修饰的方法上" class="headerlink" title="3.1 @Transactional 应用在非 public修饰的方法上"></a>3.1 @Transactional 应用在非 public修饰的方法上</h3><p>如果Transactional注解应用在非public 修饰的方法上，Transactional将会失效</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304040830528.png" alt="image-20230404083047229"></p><p>之所以会失效是因为在Spring AOP 代理时，如上图所示 TransactionInterceptor  （事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的  intercept 方法或 JdkDynamicAopProxy 的 invoke 方法会间接调用  AbstractFallbackTransactionAttributeSource的 computeTransactionAttribute  方法，获取Transactional 注解的事务配置信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected TransactionAttribute computeTransactionAttribute(Method method,    Class&lt;?&gt; targetClass) {        // Don't allow no-public methods as required.        if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {    return null;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。</p><blockquote><p>==注意：==protected、private 修饰的方法上使用 @Transactional 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。</p></blockquote><h3 id="3-2-transactional-注解属性-propagation-设置错误"><a href="#3-2-transactional-注解属性-propagation-设置错误" class="headerlink" title="3.2 @transactional 注解属性 propagation 设置错误"></a>3.2 @transactional 注解属性 propagation 设置错误</h3><p>这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。</p><ol><li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li></ol><h3 id="3-3-Transactional-注解属性-rollbackFor-设置错误"><a href="#3-3-Transactional-注解属性-rollbackFor-设置错误" class="headerlink" title="3.3 @Transactional 注解属性 rollbackFor 设置错误"></a>3.3 @Transactional 注解属性 rollbackFor 设置错误</h3><p>rollbackFor 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查unchecked异常（继承自  RuntimeException的异常）或者 Error才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望  Spring 能够回滚事务，就需要指定 rollbackFor属性。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304040833490.png" alt="image-20230404083312436"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 希望自定义的异常可以进行回滚 @Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。Spring源码如下：</p><pre class="line-numbers language-none"><code class="language-none">private int getDepth(Class&lt;?&gt; exceptionClass, int depth) {       if (exceptionClass.getName().contains(this.exceptionName)) {           // Found it!            return depth;       }       // If we've gone as far as we can go and haven't found it...       if (exceptionClass == Throwable.class) {            return -1;       }       return getDepth(exceptionClass.getSuperclass(), depth + 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-同一个类中方法调用，导致-Transactional失效"><a href="#3-4-同一个类中方法调用，导致-Transactional失效" class="headerlink" title="3.4 同一个类中方法调用，导致@Transactional失效"></a>3.4 同一个类中方法调用，导致@Transactional失效</h3><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。</p><p>那为啥会出现这种情况？其实这还是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//@Transactional                                                 @GetMapping("/test")                                         private Integer A() throws Exception {                           CityInfoDict cityInfoDict = new CityInfoDict();              cityInfoDict.setCityName("2");                               /**                                                           * B 插入字段为 3的数据                                               */                                                          this.insertB();                                              /**                                                           * A 插入字段为 2的数据                                               */                                                          int insert = cityInfoDictMapper.insert(cityInfoDict);                                                                     return insert;                                           }                                                                                                                         @Transactional()                                             public Integer insertB() throws Exception {                      CityInfoDict cityInfoDict = new CityInfoDict();              cityInfoDict.setCityName("3");                               cityInfoDict.setParentCityId(3);                                                                                          return cityInfoDictMapper.insert(cityInfoDict);          }                                                        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-异常被你的-catch“吃了”导致-Transactional失效"><a href="#3-5-异常被你的-catch“吃了”导致-Transactional失效" class="headerlink" title="3.5 异常被你的 catch“吃了”导致@Transactional失效"></a>3.5 异常被你的 catch“吃了”导致@Transactional失效</h3><p>这种情况是最常见的一种@Transactional注解失效场景</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional                                             private Integer A() throws Exception {                         int insert = 0;                                            try {                                                          CityInfoDict cityInfoDict = new CityInfoDict();            cityInfoDict.setCityName("2");                             cityInfoDict.setParentCityId(2);                           /**                                                         * A 插入字段为 2的数据                                             */                                                        insert = cityInfoDictMapper.insert(cityInfoDict);          /**                                                         * B 插入字段为 3的数据                                             */                                                        b.insertB();                                           } catch (Exception e) {                                        e.printStackTrace();                                   }                                                      }                                                          <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务还能正常回滚吗？</p><p>答案：不能！</p><p>会抛出异常：</p><p>1org.springframework.transaction.UnexpectedRollbackException:  Transaction rolled back because it has been marked as rollback-only<br>  　因为当ServiceB中抛出了一个异常以后，ServiceB标识当前事务需要rollback。但是ServiceA中由于你手动的捕获这个异常并进行处理，ServiceA认为当前事务应该正常commit。此时就出现了前后不一致，也就是因为这样，抛出了前面的UnexpectedRollbackException异常。</p><p>spring的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行commit or rollback，事务是否执行取决于是否抛出runtime异常。如果抛出runtime exception 并在你的业务方法中没有catch到的话，事务会回滚。</p><p>在业务方法中一般不需要catch异常，如果非要catch一定要手动抛出throw new RuntimeException()，否则会导致事务失效，数据commit造成数据不一致，所以有些时候try catch反倒会画蛇添足。</p><h3 id="3-6-数据库引擎不支持事务"><a href="#3-6-数据库引擎不支持事务" class="headerlink" title="3.6 数据库引擎不支持事务"></a>3.6 数据库引擎不支持事务</h3><p> 这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的MySQL数据库默认使用支持事务的innodb引擎。一旦数据库引擎切换成不支持事务的myisam，那事务就从根本上失效了。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO系列 BufferedReader</title>
      <link href="/tur-study/2023/04/03/Java/IO%E7%B3%BB%E5%88%97-BufferedReader/"/>
      <url>/tur-study/2023/04/03/Java/IO%E7%B3%BB%E5%88%97-BufferedReader/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304030916034.png" alt="image-20230403091636971"></p><p><code>BufferedReader</code>：缓冲输入流，继承与 <code>Reader</code></p><ul><li>从字符输入流读取文本，缓冲字符，已提供字符、数组和行的高效读取</li><li>可以指定缓冲区大小，或者使用默认大小。默认值足够大，可用于大部分用途</li></ul><p>通常创建 <code>BufferedReader </code>的基本语法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">BufferedReader br = new BufferedReader(new InputStreamReader(System.in))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>语法解析：</p><ol><li>System.in：字节输入流</li><li>new InputStreamReader：将字节流转换为字符流</li><li>new BufferedReader：将字符流放入字符流缓冲区之中</li></ol><h3 id="2-BufferedReader-方法列表"><a href="#2-BufferedReader-方法列表" class="headerlink" title="2. BufferedReader 方法列表"></a>2. BufferedReader 方法列表</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">BufferedReader(Reader in)BufferedReader(Reader in, int size)void     close()void     mark(int markLimit)boolean  markSupported()int      read()int      read(char[] buffer, int offset, int length)String   readLine()boolean  ready()void     reset()long     skip(long charCount)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要使用的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">BufferedReader br = new BufferedReader(new InputStreamReader(System.in));String str= br.readLine() ;char c = br.read() ;// BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>==注意：==</p><ol><li>StringBuffer类的readLine()从每次读取的一行内容，直至读取的为null为止。然后进行输出。</li><li>StringBuffer类的read()方法读取到的每一个字符转换的数字，然后进行输出。</li></ol><h3 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h3><h4 id="3-1-从控制台读取多字符输入"><a href="#3-1-从控制台读取多字符输入" class="headerlink" title="3.1  从控制台读取多字符输入"></a>3.1  从控制台读取多字符输入</h4><p>从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下：</p><pre><code>int read( ) throws IOException</code></pre><p>每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。</p><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//使用 BufferedReader 在控制台读取字符import java.io.*; public class BRRead {    public static void main(String[] args) throws IOException {        char c;        // 使用 System.in 创建 BufferedReader        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        System.out.println("输入字符, 按下 'q' 键退出。");        // 读取字符        do {            c = (char) br.read();            System.out.println(c);        } while (c != 'q');    }}以上实例编译运行结果如下:输入字符, 按下 'q' 键退出。runoobrunoobqq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-从控制台读取字符串"><a href="#3-2-从控制台读取字符串" class="headerlink" title="3.2 从控制台读取字符串"></a>3.2 从控制台读取字符串</h4><p>从标准输入读取一个字符串需要使用 <strong>BufferedReader 的 readLine() 方法</strong>。</p><p>它的一般格式是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String readLine( ) throws IOException<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">BRReadLines.java 文件代码：//使用 BufferedReader 在控制台读取字符import java.io.*; public class BRReadLines {    public static void main(String[] args) throws IOException {        // 使用 System.in 创建 BufferedReader        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        String str;        System.out.println("Enter lines of text.");        System.out.println("Enter 'end' to quit.");        do {            str = br.readLine();            System.out.println(str);        } while (!str.equals("end"));    }}以上实例编译运行结果如下:Enter lines of text.Enter 'end' to quit.This is line oneThis is line oneThis is line twoThis is line twoendend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String,StringBuffer,StringBuilder类的区别</title>
      <link href="/tur-study/2023/04/03/Java/String-StringBuffer-StringBuilder%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/tur-study/2023/04/03/Java/String-StringBuffer-StringBuilder%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="1-简述"><a href="#1-简述" class="headerlink" title="1. 简述"></a>1. 简述</h3><h4 id="1-1-String-类"><a href="#1-1-String-类" class="headerlink" title="1.1 String 类"></a>1.1 String 类</h4><p>Java 中 字符串属于对象，Java 提供了 String 类来创建和操作字符串。String 类是不可变类，即一旦一个 String 对象被创建以后，包含在这个对象中的字符序列是不可变的，直到这个对象被销毁</p><h4 id="1-2-StringBuilder-和-StringBuffer-类"><a href="#1-2-StringBuilder-和-StringBuffer-类" class="headerlink" title="1.2 StringBuilder 和 StringBuffer 类"></a>1.2 StringBuilder 和 StringBuffer 类</h4><p>StringBuffer、StringBuilder 是 Java 的两个可变字符串类，中文意译为“字符串缓冲区”。</p><p>StringBuffer 和 StringBuilder 功能基本相似，方法也差不多。</p><p>不同之处：StringBuffer 是<code>线程安全</code>的，而 StringBuilder <code>没有实现线程安全</code>，所以 StringBuilder 的性能略高。因此在通常情况下，需要创建一个内容可变的字符串对象时，<font color="red">优先考虑使用 StringBuilder 类</font></p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><p>StringBuffer、StringBuilder、String 都实现了 <code>CharSequence </code>接口</p><blockquote><p>CharSequence 是一个定义字符串操作的接口，只包括 length()、charAt(int index)、subSequence(int start, int end) 这几个API</p></blockquote><p>三者对 CharSequence 接口的实现过程不一样：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304030911053.png" alt="image-20230403091157842"></p><p>可见，String 直接实现了 CharSequence 接口，StringBuilder 和 StringBuffer 都是可变的字符序列，它们都继承于 AbstractStringBuilder，实现了 CharSequence 接口。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>String 是 Java 中基础且重要的类，被声明为<code> final class</code>，是不可变字符串。因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。</p><p> StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列。</p><p> 在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。</p><p><strong>线程安全：</strong></p><ul><li>StringBuffer：线程安全</li><li>StringBuilder：线程不安全</li></ul><p><strong>速度：</strong></p><p>一般情况下，速度从快到慢为 <code>StringBuilder &gt; StringBuffer &gt; String</code>，当然这是相对的，不是绝对的。</p><p><strong>使用环境：</strong></p><ul><li>操作少量的数据使用 String。</li><li>单线程操作大量数据使用 StringBuilder。</li><li>多线程操作大量数据使用 StringBuffer。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的加密工具类--DigestUtils</title>
      <link href="/tur-study/2023/04/02/Spring/Spring%E7%9A%84%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7%E7%B1%BB-DigestUtils/"/>
      <url>/tur-study/2023/04/02/Spring/Spring%E7%9A%84%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7%E7%B1%BB-DigestUtils/</url>
      
        <content type="html"><![CDATA[<h2 id="一、加密算法简介"><a href="#一、加密算法简介" class="headerlink" title="一、加密算法简介"></a>一、加密算法简介</h2><p>常见的加密算法可以分成三类：</p><ul><li>对称加密算法</li><li>非对称加密算法</li><li>Hash算法</li></ul><h3 id="1-1-对称加密"><a href="#1-1-对称加密" class="headerlink" title="1.1 对称加密"></a>1.1 对称加密</h3><p>指加密和解密使用相同密钥的加密算法。对称加密算法的优点在于加解密的高速度和使用长密钥时的难破解性。</p><p>假设两个用户需要使用对称加密方法加密然后交换数据，则用户最少需要2个密钥并交换使用，如果企业内用户有n个，则整个企业共需要n×(n-1) 个密钥，密钥的生成和分发将成为企业信息部门的恶梦。对称加密算法的安全性取决于加密密钥的保存情况，但要求企业中每一个持有密钥的人都保守秘密是不可能的，他们通常会有意无意的把密钥泄漏出去——如果一个用户使用的密钥被入侵者所获得，入侵者便可以读取该用户密钥加密的所有文档，如果整个企业共用一个加密密钥，那整个企业文档的保密性便无从谈起</p><p>常见的对称加密算法：DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES</p><h3 id="1-2-非对称加密"><a href="#1-2-非对称加密" class="headerlink" title="1.2 非对称加密"></a>1.2 非对称加密</h3><p>指加密和解密使用不同密钥的加密算法，也称为公私钥加密。假设两个用户要加密交换数据，双方交换公钥，使用时一方用对方的公钥加密，另一方即可用自己的私钥解密。</p><p>如果企业中有n个用户，企业需要生成n对密钥，并分发n个公钥。由于公钥是可以公开的，用户只要保管好自己的私钥即可，因此加密密钥的分发将变得十分简单。同时，由于每个用户的私钥是唯一的，其他用户除了可以可以通过信息发送者的公钥来验证信息的来源是否真实，还可以确保发送者无法否认曾发送过该信息。非对称加密的缺点是加解密速度要远远慢于对称加密，在某些极端情况下，甚至能比非对称加密慢上1000倍。</p><p>常见的非对称加密算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）</p><h3 id="1-3-Hash算法"><a href="#1-3-Hash算法" class="headerlink" title="1.3 Hash算法"></a>1.3 Hash算法</h3><p>Hash算法特别的地方在于它是一种单向算法，用户可以通过Hash算法对目标信息生成一段特定长度的唯一的Hash值，却不能通过这个Hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。</p><p>常见的Hash算法：MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1</p><blockquote><p>加密算法的效能通常可以按照算法本身的复杂程度、密钥长度（密钥越长越安全）、加解密速度等来衡量。上述的算法中，除了DES密钥长度不够、MD2速度较慢已逐渐被淘汰外，其他算法仍在目前的加密系统产品中使用。</p></blockquote><h3 id="1-4-加密算法的选择"><a href="#1-4-加密算法的选择" class="headerlink" title="1.4 加密算法的选择"></a>1.4 加密算法的选择</h3><p>我们应该根据自己的使用特点来确定，由于非对称加密算法的运行速度比对称加密算法的速度慢很多，当我们需要加密大量的数据时，建议采用对称加密算法，提高加解密速度。</p><p>对称加密算法不能实现签名，因此签名只能非对称算法。</p><p>由于对称加密算法的密钥管理是一个复杂的过程，密钥的管理直接决定着他的安全性，因此当数据量很小时，我们可以考虑采用非对称加密算法。</p><p>在实际的操作过程中，我们通常采用的方式是：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。</p><p>如果在选定了加密算法后，那采用多少位的密钥呢？一般来说，密钥越长，运行的速度就越慢，应该根据的我们实际需要的安全级别来选择，一般来说，RSA建议采用1024位的数字，ECC建议采用160位，AES采用128为即可。</p><h2 id="二、DigestUtils-的使用"><a href="#二、DigestUtils-的使用" class="headerlink" title="二、DigestUtils 的使用"></a>二、DigestUtils 的使用</h2><h3 id="2-1-SHA256加密"><a href="#2-1-SHA256加密" class="headerlink" title="2.1 SHA256加密"></a>2.1 SHA256加密</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">String encodekey = DigestUtils.sha256Hex("测试SHA256");System.out.println(encodekey);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">6c6c0785899852543f360d1270d400f709179fc03b62bada26aa0f69a8ec7dea<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**    * Calculates the SHA-256 digest and returns the value as a hex string.    * &lt;p&gt;    * Throws a &lt;code&gt;RuntimeException&lt;/code&gt; on JRE versions prior to 1.4.0.    * &lt;/p&gt;    *     * @param data    *            Data to digest    * @return SHA-256 digest as a hex string    * @since 1.4    */   public static String sha256Hex(String data) {       return Hex.encodeHexString(sha256(data));   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-md5加密"><a href="#2-2-md5加密" class="headerlink" title="2.2 md5加密"></a>2.2 md5加密</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">String encodekey = DigestUtils.md5Hex("测试MD5");System.out.println(encodekey);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">c2dbb895a66c3ca924ccdbea49fa6884<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**     * Calculates the MD5 digest and returns the value as a 16 element &lt;code&gt;byte[]&lt;/code&gt;.     *      * @param data     *            Data to digest     * @return MD5 digest     */    public static byte[] md5(String data) {        return md5(getBytesUtf8(data));    } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该类同时提供了上述两个方法的重载方法传入的不同参数,支持的加密算法如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">   private static MessageDigest getMd5Digest() {return getDigest("MD5");}private static MessageDigest getSha256Digest() {return getDigest("SHA-256");}private static MessageDigest getSha384Digest() {return getDigest("SHA-384");}private static MessageDigest getSha512Digest() {return getDigest("SHA-512");}private static MessageDigest getShaDigest() {return getDigest("SHA");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器解析工具-UserAgentUtils</title>
      <link href="/tur-study/2023/04/02/SpringBoot/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7-UserAgentUtils/"/>
      <url>/tur-study/2023/04/02/SpringBoot/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7-UserAgentUtils/</url>
      
        <content type="html"><![CDATA[<h3 id="1-UserAgentUtils简介"><a href="#1-UserAgentUtils简介" class="headerlink" title="1. UserAgentUtils简介"></a>1. UserAgentUtils简介</h3><p>UserAgentUtils 是一个用来解析 User-Agent 字符串的 Java 类库</p><p>能够识别的内容包括：</p><ul><li>超过150种不同的浏览器；</li><li>7种不同的浏览器类型；</li><li>超过60种不同的操作系统；</li><li>6种不同的设备类型；</li><li>9种不同的渲染引擎；</li><li>9种不同的Web应用，如HttpClient、Bot。</li></ul><blockquote><p>Github主页：<a href="https://github.com/HaraldWalker/user-agent-utils">https://github.com/HaraldWalker/user-agent-utils</a></p></blockquote><h3 id="2-Maven-依赖"><a href="#2-Maven-依赖" class="headerlink" title="2. Maven 依赖"></a>2. Maven 依赖</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>eu.bitwalker<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>UserAgentUtils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.21<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">String agent=request.getHeader("User-Agent");//"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.81 Safari/537.36"//解析agent字符串UserAgent userAgent = UserAgent.parseUserAgentString(agent);//获取浏览器对象Browser browser = userAgent.getBrowser();//获取操作系统对象OperatingSystem operatingSystem = userAgent.getOperatingSystem();System.out.println("浏览器名:"+browser.getName());System.out.println("浏览器类型:"+browser.getBrowserType());System.out.println("浏览器家族:"+browser.getGroup());System.out.println("浏览器生产厂商:"+browser.getManufacturer());System.out.println("浏览器使用的渲染引擎:"+browser.getRenderingEngine());System.out.println("浏览器版本:"+userAgent.getBrowserVersion());        System.out.println("操作系统名:"+operatingSystem.getName());System.out.println("访问设备类型:"+operatingSystem.getDeviceType());System.out.println("操作系统家族:"+operatingSystem.getGroup());System.out.println("操作系统生产厂商:"+operatingSystem.getManufacturer());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出内容：</p><pre class="line-numbers language-none"><code class="language-none">浏览器名:Chrome 43浏览器类型:WEB_BROWSER浏览器家族:CHROME浏览器生产厂商:GOOGLE浏览器使用的渲染引擎:WEBKIT浏览器版本:43.0.2357.81操作系统名:Mac OS X访问设备类型:COMPUTER操作系统家族:MAC_OS_X操作系统生产厂商:APPLE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现获取客户端IP地址</title>
      <link href="/tur-study/2023/04/02/Java/Java%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AFIP%E5%9C%B0%E5%9D%80/"/>
      <url>/tur-study/2023/04/02/Java/Java%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AFIP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p> 项目开发中，在日常处理操作日志时，基本都会通过aop<a href="https://so.csdn.net/so/search?q=%E5%88%87%E9%9D%A2&amp;spm=1001.2101.3001.7020">切面</a>来实现用户操作日志的记录，但涉及到记录操作日志，想必肯定会有一项是基本都会参考记录的，那就是操作人的客户端ip地址，日后查”脏”也方便。</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><ol><li>定义一个工具类，专门用来封装 ip 相关的方法类</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IpUtils { }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>获取ip</li></ol><p>通常获取客户端的IP地址都是通过 <code>request.getRemoteAddr()</code> ，但如今基本系统都会进行域名代理等，比如通过 Apache,Squid 等反向代理软件，使用<code>getRemoteAddr() </code>根本无法再获取到客户端的真实 IP 地址了。</p><p>​    为什么加了代理就获取不到了呢？这是因为在客户端和服务之间增加了中间代理，因此服务器是无法直接拿到客户端的 IP地址，服务器端应用也无法直接通过转发请求的地址返回给客户端，基本这种获取方式就直接被pass掉了。</p><p>下面是具体获取客户端ip的方法类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** * 获取客户端ip地址 * @param request */public static String getIP(final HttpServletRequest request) throws Exception {    if (request == null) {        throw (new Exception("getIpAddr method HttpServletRequest Object is null"));    }    String ipStr = request.getHeader("x-forwarded-for");    if (StringUtils.isBlank(ipStr) || "unknown".equalsIgnoreCase(ipStr)) {        ipStr = request.getHeader("Proxy-Client-IP");    }    if (StringUtils.isBlank(ipStr) || "unknown".equalsIgnoreCase(ipStr)) {        ipStr = request.getHeader("WL-Proxy-Client-IP");    }    if (StringUtils.isBlank(ipStr) || "unknown".equalsIgnoreCase(ipStr)) {        ipStr = request.getRemoteAddr();    }     // 多个路由时，取第一个非unknown的ip    final String[] arr = ipStr.split(",");    for (final String str : arr) {        if (!"unknown".equalsIgnoreCase(str)) {            ipStr = str;            break;        }    }    //目的是将localhost访问对应的ip 0:0:0:0:0:0:0:1 转成 127.0.0.1。    return ipStr.equals("0:0:0:0:0:0:0:1") ? "127.0.0.1" : ipStr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code> 0:0:0:0:0:0:0:1</code> 是<code>[ ipv6 ]</code>的表现形式，对应<code>[ ipv4 ]</code>来说相当于<code>127.0.0.1</code>，也就是本机</p></blockquote><p>上述方法是获取客户端公网IP的方法，通过 ipconfig 本地查询到的 ipv 是内网 ip。</p><blockquote><p>公网ip的查询网站如下：<a href="https://ip.cn/">https://ip.cn/</a> 或者<a href="https://ifconfig.me/">https://ifconfig.me/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP完成系统操作日志记录</title>
      <link href="/tur-study/2023/04/02/Spring/AOP%E5%AE%8C%E6%88%90%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
      <url>/tur-study/2023/04/02/Spring/AOP%E5%AE%8C%E6%88%90%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sa-Token-SSO单点登录</title>
      <link href="/tur-study/2023/04/01/SpringBoot/Sa-Token-SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>/tur-study/2023/04/01/SpringBoot/Sa-Token-SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、单点登录简述"><a href="#一、单点登录简述" class="headerlink" title="一、单点登录简述"></a>一、单点登录简述</h2><blockquote><p>单点登录是搭建统一认证中心的关键</p></blockquote><h3 id="1-1-单点登录"><a href="#1-1-单点登录" class="headerlink" title="1.1 单点登录"></a>1.1 单点登录</h3><p>单点登录可以将一个系统的各个模块的认证授权互通共享，即用户在一个系统模块登陆之后，便可以畅通无阻的访问其他模块。简而言之，单点登录可以做到：<code>在多个互相信任的系统中，用户只需登陆一次，就可以访问所有系统</code></p><h3 id="1-2-架构选型"><a href="#1-2-架构选型" class="headerlink" title="1.2 架构选型"></a>1.2 架构选型</h3><p>Sa-Token-SSO 由简入难划分为三种模式，解决不同架构下的 SSO 接入问题：</p><table><thead><tr><th>系统架构</th><th>采用模式</th><th>简介</th><th>文档链接</th></tr></thead><tbody><tr><td>前端同域 + 后端同 Redis</td><td>模式一</td><td>共享 Cookie 同步会话</td><td><a href="https://sa-token.cc/doc.html#/sso/sso-type1">文档</a>、<a href="https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-sso1-client">示例</a></td></tr><tr><td>前端不同域 + 后端同 Redis</td><td>模式二</td><td>URL重定向传播会话</td><td><a href="https://sa-token.cc/doc.html#/sso/sso-type2">文档</a>、<a href="https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-sso2-client">示例</a></td></tr><tr><td>前端不同域 + 后端不同 Redis</td><td>模式三</td><td>Http请求获取会话</td><td><a href="https://sa-token.cc/doc.html#/sso/sso-type3">文档</a>、<a href="https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-sso3-client">示例</a></td></tr></tbody></table><ol><li>前端同域：就是指多个系统可以部署在同一个主域名之下，比如：<code>c1.domain.com</code>、<code>c2.domain.com</code>、<code>c3.domain.com</code>。</li><li>后端同Redis：就是指多个系统可以连接同一个Redis。PS：这里并不需要把所有项目的数据都放在同一个Redis中，Sa-Token提供了 <strong><code>[权限缓存与业务缓存分离]</code></strong> 的解决方案，详情戳： <a href="https://sa-token.cc/doc.html#/plugin/alone-redis">Alone独立Redis插件</a>。</li><li>如果既无法做到前端同域，也无法做到后端同Redis，那么只能走模式三，Http请求获取会话（Sa-Token对SSO提供了完整的封装，只需要按照示例从文档上复制几段代码便可以轻松集成）。</li></ol><h3 id="1-3-Sa-Token-SSO-特性"><a href="#1-3-Sa-Token-SSO-特性" class="headerlink" title="1.3 Sa-Token-SSO 特性"></a>1.3 Sa-Token-SSO 特性</h3><ol><li>API 简单易用，文档介绍详细，且提供直接可用的集成示例。</li><li>支持三种模式，不论是否跨域、是否共享Redis、是否前后端分离，都可以完美解决。</li><li>安全性高：内置域名校验、Ticket校验、秘钥校验等，杜绝<code>Ticket劫持</code>、<code>Token窃取</code>等常见攻击手段</li><li>不丢参数：Sa-Token-SSO内有专门的算法保证了参数不丢失，登录成功之后原路返回页面。</li><li>无缝集成：由于Sa-Token本身就是一个权限认证框架，因此可以只用一个框架同时解决<code>权限认证</code> + <code>单点登录</code>问题，让你不再到处搜索：xxx单点登录与xxx权限认证如何整合……</li><li>高可定制：Sa-Token-SSO模块对代码架构侵入性极低，结合Sa-Token本身的路由拦截特性，可以非常轻松的定制化开发。</li></ol><p>下面记录 SSO 单点登录相关步骤：</p><h2 id="二、搭建统一认证中心-SSO-Server"><a href="#二、搭建统一认证中心-SSO-Server" class="headerlink" title="二、搭建统一认证中心 SSO-Server"></a>二、搭建统一认证中心 SSO-Server</h2><p>开始 SSO 对接之前，需要先搭建一个 SSO-Server 认证中</p><p>步骤如下：</p><h3 id="2-1-添加依赖"><a href="#2-1-添加依赖" class="headerlink" title="2.1 添加依赖"></a>2.1 添加依赖</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 权限认证，在线文档：https://sa-token.cc --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token 插件：整合SSO --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-sso<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token 整合 Redis (使用 jackson 序列化方式) --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-dao-redis-jackson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 线程池  --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 视图引擎（在前后端不分离模式下提供视图支持） --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-thymeleaf<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Http请求工具（在模式三的单点注销功能下用到，如不需要可以注释掉） --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.dtflys.forest<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>forest-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.5.26<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-开放认证接口"><a href="#2-2-开放认证接口" class="headerlink" title="2.2 开放认证接口"></a>2.2 开放认证接口</h3><p>开放认证接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Sa-Token-SSO Server端 Controller  */@RestControllerpublic class SsoServerController {    /*     * SSO-Server端：处理所有SSO相关请求 (下面的章节我们会详细列出开放的接口)      */    @RequestMapping("/sso/*")    public Object ssoRequest() {        return SaSsoProcessor.instance.serverDister();    }    /**     * 配置SSO相关参数      */    @Autowired    private void configSso(SaSsoConfig sso) {        // 配置：未登录时返回的View         sso.setNotLoginView(() -&gt; {            String msg = "当前会话在SSO-Server端尚未登录，请先访问"                    + "&lt;a href='/sso/doLogin?name=sa&amp;pwd=123456' target='_blank'&gt; doLogin登录 &lt;/a&gt;"                    + "进行登录之后，刷新页面开始授权";            return msg;        });        // 配置：登录处理函数         sso.setDoLoginHandle((name, pwd) -&gt; {            // 此处仅做模拟登录，真实环境应该查询数据进行登录             if("sa".equals(name) &amp;&amp; "123456".equals(pwd)) {                StpUtil.login(10001);                return SaResult.ok("登录成功！").setData(StpUtil.getTokenValue());            }            return SaResult.error("登录失败！");        });        // 配置 Http 请求处理器 （在模式三的单点注销功能下用到，如不需要可以注释掉）         sso.setSendHttp(url -&gt; {            try {                // 发起 http 请求                 System.out.println("------ 发起请求：" + url);                return Forest.get(url).executeAsString();            } catch (Exception e) {                e.printStackTrace();                return null;            }        });    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==注意：==</p><ul><li>在<code>setDoLoginHandle</code>函数里如果要获取name, pwd以外的参数，可通过<code>SaHolder.getRequest().getParam("xxx")</code>来获取 </li><li>在 <code>setSendHttp</code> 函数中，使用 <code>try-catch</code> 是为了提高整个注销流程的容错性，避免在一些极端情况下注销失败（例如：某个 Client 端上线之后又下线，导致 http 请求无法调用成功，从而阻断了整个注销流程）</li></ul><p>全局异常处理：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestControllerAdvicepublic class GlobalExceptionHandler {    // 全局异常拦截     @ExceptionHandler    public SaResult handlerException(Exception e) {        e.printStackTrace();         return SaResult.error(e.getMessage());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-application-yml-配置"><a href="#2-3-application-yml-配置" class="headerlink" title="2.3 application.yml 配置"></a>2.3 application.yml 配置</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 端口server:    port: 8800# Sa-Token 配置sa-token:     # ------- SSO-模式一相关配置  (非模式一不需要配置)     # cookie:         # 配置 Cookie 作用域         # domain: stp.com     # ------- SSO-模式二相关配置     sso:         # Ticket有效期 (单位: 秒)，默认五分钟         ticket-timeout: 300        # 所有允许的授权回调地址        allow-url: "*"        # 是否打开单点注销功能        is-slo: true        # ------- SSO-模式三相关配置 （下面的配置在SSO模式三并且 is-slo=true 时打开）        # 是否打开模式三         isHttp: true        # 接口调用秘钥（用于SSO模式三的单点注销功能）        secretkey: kQwIOrYvnXmSDkwEiFngrKidMcdrgKor        # ---- 除了以上配置项，你还需要为 Sa-Token 配置http请求处理器（文档有步骤说明） spring:     # Redis配置 （SSO模式一和模式二使用Redis来同步会话）    redis:        # Redis数据库索引（默认为0）        database: 1        # Redis服务器地址        host: 127.0.0.1        # Redis服务器连接端口        port: 6379        # Redis服务器连接密码（默认为空）        password: forest:     # 关闭 forest 请求日志打印    log-enabled: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>==注意：==</p><p><code>sa-token.sso.allow-url</code>为了方便测试配置为<code>*</code>，线上生产环境一定要配置为详细URL地址 </p></blockquote><h3 id="2-4-启动类"><a href="#2-4-启动类" class="headerlink" title="2.4 启动类"></a>2.4 启动类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@SpringBootApplication@MapperScan("com.blog.mapper")public class WebApplication {    public static void main(String[] args) {        SpringApplication.run(WebApplication.class, args);        log.info("\n---------Sa-Token-SSO认证中心启动成功");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动项目后：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020759417.png" alt="image-20230402075945152"></p><p>访问统一授权地址：（具体访问路径依据实际情况自己设定）</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020800521.png" alt="image-20230402080039458"></p><h2 id="三、SSO模式一：共享Cookie同步会话"><a href="#三、SSO模式一：共享Cookie同步会话" class="headerlink" title="三、SSO模式一：共享Cookie同步会话"></a>三、SSO模式一：共享Cookie同步会话</h2><blockquote><p>如果多个系统可以做到：前端同域，后端同Redis，便可以用 <code>共享Cookie同步会话</code> 的方式做到单点登录</p></blockquote><h3 id="3-1-解决思路"><a href="#3-1-解决思路" class="headerlink" title="3.1 解决思路"></a>3.1 解决思路</h3><p>多个系统之间为什么无法同步登录状态？</p><ol><li>前端的 <code>Token </code>无法在多个系统下共享</li><li>后端的 <code>Session </code>无法在多个系统间共享</li></ol><p>对于上述原因，单点登录有如下方法解决：</p><ol><li>使用 <code>共享Cookie</code> 来解决  Token 共享问题</li><li>使用 <code>Redis </code>来解决Session 共享问题</li></ol><p><strong>共享Cookie</strong></p><p>共享Cookie就是主域名Cookie在二级域名下的共享</p><p>示例：写在父域名<code>stp.com</code>下的Cookie，在<code>s1.stp.com</code>、<code>s2.stp.com</code>等子域名都是可以共享访问的。</p><p><strong>共享Redis</strong></p><p>共享Redis，并不需要我们把所有项目的数据都放在同一个Redis中，Sa-Token提供了 <strong>[权限缓存与业务缓存分离]</strong> 的解决方案</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020816900.png" alt="image-20230402081618844"></p><h3 id="3-2-准备工作"><a href="#3-2-准备工作" class="headerlink" title="3.2 准备工作"></a>3.2 准备工作</h3><p>修改hosts 文件<code>(C:\windows\system32\drivers\etc\hosts)</code>，添加以下IP映射，方便测试</p><pre class="line-numbers language-uri" data-language="uri"><code class="language-uri">127.0.0.1 sso.stp.com127.0.0.1 s1.stp.com127.0.0.1 s2.stp.com127.0.0.1 s3.stp.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中：<code>sso.stp.com</code>为统一认证中心地址，当用户在其它 Client 端发起登录请求时，均将其重定向至认证中心，待到登录成功之后再原路返回到 Client 端</p><h3 id="3-3-指定-Cookie-的作用域"><a href="#3-3-指定-Cookie-的作用域" class="headerlink" title="3.3 指定 Cookie 的作用域"></a>3.3 指定 Cookie 的作用域</h3><p>在<code>sso.stp.com</code>访问服务器，其Cookie也只能写入到<code>sso.stp.com</code>下，为了将Cookie写入到其父级域名<code>stp.com</code>下，我们需要更改 SSO-Server 端的 yml 配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">sa-token:     cookie:         # 配置 Cookie 作用域         domain: stp.com <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-搭建-Client-端项目"><a href="#3-4-搭建-Client-端项目" class="headerlink" title="3.4 搭建 Client 端项目"></a>3.4 搭建 Client 端项目</h3><h5 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 权限认证, 在线文档：https://sa-token.cc --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token 插件：整合SSO --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-sso<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token 整合redis (使用jackson序列化方式) --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-dao-redis-jackson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token插件：权限缓存与业务缓存分离 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-alone-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-新建-Controller-控制器"><a href="#2-新建-Controller-控制器" class="headerlink" title="2. 新建 Controller 控制器"></a>2. 新建 Controller 控制器</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Sa-Token-SSO Client端 Controller  * @author kong */@RestControllerpublic class SsoClientController {    // SSO-Client端：首页     @RequestMapping("/")    public String index() {        String authUrl = SaSsoManager.getConfig().splicingAuthUrl();        String solUrl = SaSsoManager.getConfig().splicingSloUrl();        String str = "&lt;h2&gt;Sa-Token SSO-Client 应用端&lt;/h2&gt;" +                     "&lt;p&gt;当前会话是否登录：" + StpUtil.isLogin() + "&lt;/p&gt;" +                     "&lt;p&gt;&lt;a href=\"javascript:location.href='" + authUrl + "?mode=simple&amp;redirect=' + encodeURIComponent(location.href);\"&gt;登录&lt;/a&gt; " +                     "&lt;a href=\"javascript:location.href='" + solUrl + "?back=' + encodeURIComponent(location.href);\"&gt;注销&lt;/a&gt; &lt;/p&gt;";        return str;    }    // 全局异常拦截     @ExceptionHandler    public SaResult handlerException(Exception e) {        e.printStackTrace();         return SaResult.error(e.getMessage());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-application-yml-配置"><a href="#3-application-yml-配置" class="headerlink" title="3. application.yml 配置"></a>3. application.yml 配置</h5><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 端口server:    port: 9001# Sa-Token 配置 sa-token:     # SSO-相关配置    sso:         # SSO-Server端-单点登录授权地址         auth-url: http://sso.stp.com:9000/sso/auth        # SSO-Server端-单点注销地址        slo-url: http://sso.stp.com:9000/sso/signout    # 配置 Sa-Token 单独使用的Redis连接 （此处需要和SSO-Server端连接同一个Redis）    alone-redis:         # Redis数据库索引        database: 1        # Redis服务器地址        host: 127.0.0.1        # Redis服务器连接端口        port: 6379        # Redis服务器连接密码（默认为空）        password:         # 连接超时时间        timeout: 10s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-启动类"><a href="#4-启动类" class="headerlink" title="4. 启动类"></a>4. 启动类</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * SSO模式一，Client端 Demo  */@SpringBootApplicationpublic class SaSso1ClientApplication {    public static void main(String[] args) {        SpringApplication.run(SaSso1ClientApplication.class, args);        System.out.println("\nSa-Token SSO模式一 Client端启动成功");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-访问测试"><a href="#5-访问测试" class="headerlink" title="5. 访问测试"></a>5. 访问测试</h5><p>启动client端和server端，访问 <code>http://s1.stp.com:9001</code></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020851161.png" alt="image-20230402085133074"></p><p>点击登录，重定向至认证中心：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020852328.png" alt="image-20230402085201271"></p><p>点击登录后再刷新页面：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020853616.png" alt="image-20230402085306565"></p><p>刷新另外两个Client端，均显示已登录 </p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020853412.png" alt="sso1-login-ok2.png"></p><p>测试完成 </p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Sa-Token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Feign使用详解</title>
      <link href="/tur-study/2023/04/01/SpringCloud/Feign%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/04/01/SpringCloud/Feign%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Feign-的基础使用"><a href="#1-Feign-的基础使用" class="headerlink" title="1. Feign 的基础使用"></a>1. Feign 的基础使用</h3><p>Feign 的使用步骤如下：</p><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-添加注解"><a href="#2-添加注解" class="headerlink" title="2. 添加注解"></a>2. 添加注解</h4><p>在启动类中添加注解 <code>@EnableFeignClients</code> 开启Feign 的功能</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304261706380.png" alt="image-20210714175102524"></p><h4 id="3-编写Feign-的客户端"><a href="#3-编写Feign-的客户端" class="headerlink" title="3. 编写Feign 的客户端"></a>3. 编写Feign 的客户端</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@FeignClient("userservice") // value="服务名称"public interface UserClient {        // 与接口声明一样    @GetMapping("/user/{id}")    User findById(@PathVariable("id") Long id);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：/user/{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p><h3 id="2-自定义配置"><a href="#2-自定义配置" class="headerlink" title="2. 自定义配置"></a>2. 自定义配置</h3><p>eign可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p><h3 id="3-Feign-使用优化"><a href="#3-Feign-使用优化" class="headerlink" title="3. Feign 使用优化"></a>3. Feign 使用优化</h3><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p><ul><li>URLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>因此提高<code>Feign</code>的性能主要手段就是使用<strong>连接池</strong>代替默认的<code>URLConnection</code>。</p><p>使用步骤如下：</p><blockquote><p>以 Apache 的 HttpClient 为例</p></blockquote><h4 id="3-1-引入依赖"><a href="#3-1-引入依赖" class="headerlink" title="3.1 引入依赖"></a>3.1 引入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--httpClient的依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.github.openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>feign-httpclient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-配置连接池"><a href="#3-2-配置连接池" class="headerlink" title="3.2 配置连接池"></a>3.2 配置连接池</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">feign:  client:    config:      default: # default全局的配置        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息  httpclient:    enabled: true # 开启feign对HttpClient的支持    max-connections: 200 # 最大的连接数    max-connections-per-route: 50 # 每个路径的最大连接数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a>4. 最佳实践</h3><p>feign 的客户端与服务提供者的controller 代码非常相似：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304261712958.png" alt="image-20210714190542730"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304261713354.png" alt="image-20210714190528450"></p><p>所以，需要简化这种重复代码的编写</p><h4 id="4-1-继承方式"><a href="#4-1-继承方式" class="headerlink" title="4.1 继承方式"></a>4.1 继承方式</h4><p>一样的代码可以通过继承来共享：</p><ol><li>定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</li><li>Feign客户端和Controller都集成改接口</li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304261715438.png" alt="image-20210714190640857"></p><p>优点：</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点：</p><ul><li><p>服务提供方、服务消费方紧耦合</p></li><li><p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</p></li></ul><h4 id="4-2-抽取方式"><a href="#4-2-抽取方式" class="headerlink" title="4.2 抽取方式"></a>4.2 抽取方式</h4><p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304261716772.png" alt="image-20210714214041796"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java正则</title>
      <link href="/tur-study/2023/04/01/Java/Java%E6%AD%A3%E5%88%99/"/>
      <url>/tur-study/2023/04/01/Java/Java%E6%AD%A3%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="一、正则表达式"><a href="#一、正则表达式" class="headerlink" title="一、正则表达式"></a>一、正则表达式</h2><h3 id="1-1-特殊字符"><a href="#1-1-特殊字符" class="headerlink" title="1.1 特殊字符"></a>1.1 特殊字符</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011503699.png" alt="image-20230401150341463"></p><h3 id="1-2-限定符"><a href="#1-2-限定符" class="headerlink" title="1.2 限定符"></a>1.2 限定符</h3><p>限定符用来指针正则表达式的一个给定组件必须要出现次才能满足适配，有 <code>*、+、?、{n}、{n,}、{n, m}</code>共六种</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011505216.png" alt="image-20230401150555170"></p><p>示例：以下正则表达式匹配一个正整数，<code>[1-9]</code>设置第一个数字不是0，<code>[0-9]* </code>表示任意多个数字：</p><pre class="line-numbers language-none"><code class="language-none">/[1-9][0-9]*/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二、Pattern-类和-Matcher-类"><a href="#二、Pattern-类和-Matcher-类" class="headerlink" title="二、Pattern 类和 Matcher 类"></a>二、Pattern 类和 Matcher 类</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>Pattern 对象是正则表达式编译后再内存中的表现形式。即正则表达式字符串必须先被编译为 Pattern 对象，然后再利用该 Pattern 对象创建对应的 Matcher 对象</p><p>Matcher 对象保留匹配的结果，多个 Matcher 对象可共享同一个 Pattern 对象</p><h3 id="2-Pattern-类常用方法"><a href="#2-Pattern-类常用方法" class="headerlink" title="2. Pattern 类常用方法"></a>2. Pattern 类常用方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 将一个字符串编译成 Pattern 对象Pattern pattern = Pattern.compile("a*c");// 使用 Pattern 对象创建 Matcher 对象Matcher matcher = pattern.matcher("abc");// 返回 trueboolean result = matcher.matches();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面定义的 Pattern 对象可以多次重复使用。如果某个正则表达式仅需一次使用，则可直接使用 Pattern 类的静态 <code>matches()</code>方法，此方法自动把指定字符串编译成匿名的 Pattern 对象，并执行匹配，代码如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 返回 trueboolean result = Pattern.matches ("a*c","abc");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-Matcher-类常用方法"><a href="#3-Matcher-类常用方法" class="headerlink" title="3. Matcher 类常用方法"></a>3. Matcher 类常用方法</h3><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">find()</td><td align="center">返回目标字符串中是否包含与 Pattern 匹配的子串</td></tr><tr><td align="center">group()</td><td align="center">返回上一次与 Pattern 匹配的子串</td></tr><tr><td align="center">start()</td><td align="center">返回上一次与 Pattern 匹配的子串在目标字符串中的开始位置</td></tr><tr><td align="center">end()</td><td align="center">返回上一次与 Pattern 匹配的子串在目标字符串中的结束位置加 1</td></tr><tr><td align="center">lookingAt()</td><td align="center">返回目标字符串前面部分与 Pattern 是否匹配</td></tr><tr><td align="center">matches()</td><td align="center">返回整个目标字符串与 Pattern 是否匹配</td></tr><tr><td align="center">reset()</td><td align="center">将现有的 Matcher 对象应用于一个新的字符序列。</td></tr></tbody></table><h4 id="3-1-find-和-group-方法"><a href="#3-1-find-和-group-方法" class="headerlink" title="3.1 find() 和 group() 方法"></a>3.1 find() 和 group() 方法</h4><p>通过 Matcher 类的 <code>find()</code> 和 <code>group()</code> 方法可以从目标字符串中依次取出特定子串（匹配正则表达式的子串），例如互联网的网络爬虫，它们可以自动从网页中识别出所有的电话号码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test{    public static void main(String[] args)    {        // 使用字符串模拟从网络上得到的网页源码        String str = "出售JAVA教程，联系电话：13600000001" + "毕业代做，联系电话：13600000002" + "出售二手电脑，联系电话：15800000001";        // 创建一个Pattern对象，并用它建立一个Matcher对象        // 该正则表达式只抓取13X和15X段的手机号        // 实际要抓取哪些电话号码，只要修改正则表达式即可        Matcher m = Pattern.compile("((13\\d)|(15\\d))\\d{8}").matcher(str);        // 将所有符合正则表达式的子串（电话号码）全部输出        while (m.find())        {            System.out.println(m.group());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面运行结果可以看出，<code>find()</code> 方法依次查找字符串中与 Pattern 匹配的子串，一旦找到对应的子串，下次调用 <code>find()</code> 方法时将接着向下查找。</p><h4 id="3-2-start-和-end-方法"><a href="#3-2-start-和-end-方法" class="headerlink" title="3.2 start() 和 end() 方法"></a>3.2 start() 和 end() 方法</h4><p><code>find()</code> 方法还可以传入一个 int 类型的参数，带 int 参数的 <code>find()</code> 方法将从该 int 索引处向下搜索。<code>start()</code> 和 <code>end() </code>方法主要用于确定子串在目标字符串中的位置，如下程序所示。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test2{    public static void main(String[] args)    {        // 创建一个Pattern对象，并用它建立一个Matcher对象        String regStr = "Java is very easy!";        System.out.println("目标字符串是：" + regStr);        Matcher m = Pattern.compile("\\w+").matcher(regStr);        while (m.find())        {            System.out.println(m.group() + "子串的起始位置：" + m.start() + "，其结束位置：" + m.end());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面程序使用 <code>find()</code>、<code>group()</code> 方法逐项取出目标字符串中与指定正则表达式匹配的子串，并使用<code>start()</code>、<code>end()</code> 方法返回子串在目标字符串中的位置。运行上面程序，看到如下运行结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">目标字符串是：Java is very easy!Java子串的起始位置：0，其结束位置：4is子串的起始位置：5，其结束位置：7very子串的起始位置：8，其结束位置：12easy子串的起始位置：13，其结束位置：17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-matches-和-LookingAt-方法"><a href="#3-3-matches-和-LookingAt-方法" class="headerlink" title="3.3 matches() 和 LookingAt() 方法"></a>3.3 matches() 和 LookingAt() 方法</h4><p><code>matches()</code> 和 <code>lookingAt()</code> 方法有点相似，只是 <code>matches()</code> 方法要求整个字符串和 Pattern 完全匹配时才返回 <code>true</code>，而 <code>lookingAt()</code> 只要字符串以 Pattern 开头就会返回 <code>true</code>。<code>reset()</code> 方法可将现有的 Matcher 对象应用于新的字符序列：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test3{    public static void main(String[] args)    {        String[] mails =        { "mymail@163.com", "mymail@gmail.com", "mymail@myweb.org", "mymail@abc.xx" };        String mailRegEx = "\\w{3,20}@\\w+\\.(com|org|cn|net|gov)";        Pattern mailPattern = Pattern.compile(mailRegEx);        Matcher matcher = null;        for (String mail : mails)        {            if (matcher == null)            {                matcher = mailPattern.matcher(mail);            }            else            {                matcher.reset(mail);            }            String result = mail + (matcher.matches() ? "是" : "不是") + "一个有效的邮件地址！";            System.out.println(result);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面程序创建了一个邮件地址的 Pattern，接着用这个 Pattern 与多个邮件地址进行匹配。当程序中的 Matcher 为 <code>null</code> 时，程序调用 <code>matcher()</code> 方法来创建一个 Matcher 对象，一旦 Matcher 对象被创建，程序就调用 Matcher 的 <code>reset()</code> 方法将该 Matcher 应用于新的字符序列。</p><p>从某个角度来看，Matcher 的 <code>matches()</code>、<code>lookingAt()</code> 和 String 类的 <code>equals()</code> 有点相似。区别是 String 类的 <code>equals()</code> 都是与字符串进行比较，而 Matcher 的 <code>matches()</code> 和 <code>lookingAt()</code> 则是与正则表达式进行匹配。</p><p>事实上，String 类里也提供了 <code>matches()</code> 方法，该方法返回该字符串是否匹配指定的正则表达式。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">"mymail@163.com".matches("\\w{3,20}@\\w+\\.(com|org|cn|net|gov)"); // 返回 true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><h3 id="3-1-匹配数字"><a href="#3-1-匹配数字" class="headerlink" title="3.1 匹配数字"></a>3.1 匹配数字</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * \d 的含义是 [0-9] * \D 的含义是 [^0-9] * {n} 匹配确定 n 次 */public static void matchNumber() {        Pattern p = Pattern.compile("summary_day\\.\\d+[0-9]\\.\\d{17}");        Matcher m = p.matcher("ipva.summary_day.20210621.20210622000205860.B20C41AB-0A17-46DB-9177-817533B8E551.1624291336921.txt");        System.out.println(m.pattern()); //myArray\[\d\]        while (m.find()){            System.out.println(m.group());        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011519329.png" alt="image-20230401151914278"></p><h3 id="3-2-匹配字母"><a href="#3-2-匹配字母" class="headerlink" title="3.2 匹配字母"></a>3.2 匹配字母</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * \w 任何一个字母数字字符（大小写均可）或下划线，等价于 [A-Za-z0-9_] * \W 表示[^A-Za-z0-9_] * + 匹配前面的子表达式或一次或多次 */public static void matchAlphanum() {        Pattern pattern = Pattern.compile("^ipva\\.\\w+");        Matcher matcher = pattern.matcher("ipva.summary_day.20210621.20210622000205860.B20C41AB-0A17-46DB-9177-817533B8E551.1624291336921.txt");        while (matcher.find()) {            System.out.println(matcher.group(0));        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011520210.png" alt="image-20230401152003168"></p><h3 id="3-3-特殊字符一"><a href="#3-3-特殊字符一" class="headerlink" title="3.3 特殊字符一"></a>3.3 特殊字符一</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * "*" 表示含有零个或者多个 * "+" 匹配前面的子表达式或一次或多次 */public static void matchRepeat() {    Pattern pattern = Pattern.compile("\\w+[\\w\\.]*@[\\d]+\\.\\w+");    Matcher matcher = pattern.matcher("Hello .kangll@163.com is my email address.");    while (matcher.find()) {        System.out.println(matcher.group(0));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011521053.png" alt="image-20230401152153010"></p><h3 id="3-4-特殊字符二"><a href="#3-4-特殊字符二" class="headerlink" title="3.4 特殊字符二"></a>3.4 特殊字符二</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * "*" 表示含有零个或者多个 * "+" 表示匹配前面的子表达式或一次或多次 * "?" 表示匹配零个或者一个字符 */public static void matchRepeat02() {    Pattern pattern = Pattern.compile("http[s]?://[\\w\\.]+");    Matcher matcher = pattern.matcher("The URL is http://www.kangll.com/");    while (matcher.find()) {        System.out.println(matcher.group(0));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011522577.png" alt="image-20230401152240532"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolTaskExecutor的使用</title>
      <link href="/tur-study/2023/04/01/SpringBoot/ThreadPoolTaskExecutor%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/04/01/SpringBoot/ThreadPoolTaskExecutor%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、线程池简介"><a href="#一、线程池简介" class="headerlink" title="一、线程池简介"></a>一、线程池简介</h2><h3 id="1-1-为什么使用线程池"><a href="#1-1-为什么使用线程池" class="headerlink" title="1.1 为什么使用线程池"></a>1.1 为什么使用线程池</h3><ul><li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗</li><li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建，便能立即执行</li><li>方便线程并发数的管控，因为线程若是无限制的创建，可能会导致内存占用过多而产生 <code>OOM</code>，并且会造成 <code>cpu </code>过度切换</li></ul><blockquote><ul><li><p><code>OOM</code>：Out of Memory，内存溢出，即内存不够了。详细见：<a href="https://blog.csdn.net/lovedingd/article/details/104650249/">https://blog.csdn.net/lovedingd/article/details/104650249/</a></p></li><li><p>cpu切换线程有时间成本，需要保持当前执行线程的现场，并恢复要执行线程的现场</p></li></ul></blockquote><ul><li>提供更强大的功能，延时定时线程池</li></ul><h3 id="1-2-线程池需要使用队列的原因"><a href="#1-2-线程池需要使用队列的原因" class="headerlink" title="1.2 线程池需要使用队列的原因"></a>1.2 线程池需要使用队列的原因</h3><p>线程若是无限制创建，可能会导致<code>内存</code>占用过多而产生 <code>OOM</code>，并且会造成<code>cpu</code>过度切换，创建线程池的消耗较高或者线程池创建线程需要获取 <code>mainlock </code>这个全局锁，影响并发效率，阻塞队列可以很好的缓冲</p><h3 id="1-3-线程池使用阻塞队列的原因"><a href="#1-3-线程池使用阻塞队列的原因" class="headerlink" title="1.3 线程池使用阻塞队列的原因"></a>1.3 线程池使用阻塞队列的原因</h3><p><code>阻塞队列</code>可以保证任务队列中没有任务时阻塞获取任务的线程，是的线程进入 <code>wait</code> 状态，释放 <code>cpu </code>资源，当队列中有任务时才唤醒对应线程，从队列中取出消息进行执行，使得线程不至于一直占用 <code>cpu </code>资源</p><blockquote><p>线程执行完任务后通过循环再次从任务队列中取出任务进行执行，代码片段如：<code>while(task != null || (task = getTask()) != null){}</code></p></blockquote><p>不用阻塞队列也是可以的，不过实现起来比较麻烦。</p><h3 id="1-4-线程池的配置"><a href="#1-4-线程池的配置" class="headerlink" title="1.4 线程池的配置"></a>1.4 线程池的配置</h3><h5 id="1-CPU密集型任务"><a href="#1-CPU密集型任务" class="headerlink" title="1. CPU密集型任务"></a>1. CPU密集型任务</h5><p>尽量使用较小的线程池，一般为 <code>CPU </code>核心数 <code>+1</code>，因为 <code>CPU </code>密集型任务使得 <code>CPU </code>使用率较高，若是开过多的线程数，会造成 <code>CPU </code>付过度切换</p><h5 id="2-IO-密集型任务"><a href="#2-IO-密集型任务" class="headerlink" title="2. IO 密集型任务"></a>2. IO 密集型任务</h5><p>可以使用稍大的线程池，一般为 <code>2*CPU</code> 核心数。<code>IO </code>密集型任务 <code>CPU </code>使用率并不高，因此可以让 <code>CPU </code>在等待 <code>IO </code>的时候有其他线程去处理别的任务，充分利用 <code>CPU </code>时间</p><h5 id="3-混合型任务"><a href="#3-混合型任务" class="headerlink" title="3. 混合型任务"></a>3. 混合型任务</h5><p>可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效<br>因为如果划分之后两个任务执行时间有数据级的差距，那么拆分没有意义。<br>因为先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失</p><h3 id="1-5-execute-和-submit-方法"><a href="#1-5-execute-和-submit-方法" class="headerlink" title="1.5 execute() 和 submit() 方法"></a>1.5 execute() 和 submit() 方法</h3><ul><li><code>execute()</code>：执行一个任务，没有返回值</li><li><code>submit()</code>，提交一个线程任务，有返回值</li></ul><p>submit(Callable<t> task)能获取到它的返回值，通过future.get()获取（阻塞直到任务执行完）。一般使用FutureTask+Callable配合使用<br>submit(Runnable task, T result)能通过传入的载体result间接获得线程的返回值。<br>submit(Runnable task)则是没有返回值的，就算获取它的返回值也是null</t></p><p>Future.get()方法会使取结果的线程进入阻塞状态，直到线程执行完成之后，唤醒取结果的线程，然后返回结果</p><h2 id="二、Spring-线程池"><a href="#二、Spring-线程池" class="headerlink" title="二、Spring 线程池"></a>二、Spring 线程池</h2><h3 id="2-1-Spring-线程池种类"><a href="#2-1-Spring-线程池种类" class="headerlink" title="2.1 Spring 线程池种类"></a>2.1 Spring 线程池种类</h3><h4 id="1-Spring-线程池的使用"><a href="#1-Spring-线程池的使用" class="headerlink" title="1. Spring 线程池的使用"></a>1. Spring 线程池的使用</h4><ul><li>Spring 通过任务执行器<code>TaskExecutor</code> 来实现多线程和并发</li><li>使用 <code>ThreadPoolTaskExecutor</code> 实现一个基于线程池的 <code>TaskExecutor</code></li><li>使用 <code>@EnableAsync</code> 开启异步，并通过在需要异步的方法上使用注解 <code>@Async</code> 声明是一个异步任务</li></ul><h4 id="2-Spring-已经实现的异常线程池："><a href="#2-Spring-已经实现的异常线程池：" class="headerlink" title="2. Spring 已经实现的异常线程池："></a>2. Spring 已经实现的异常线程池：</h4><ul><li><code>SimpleAsyncTaskExecutor</code>：不是真的线程池，这个类不重用线程，每次调用都会创建一个新的线程。</li><li><code>SyncTaskExecutor</code>：这个类没有实现异步调用，只是一个同步操作。只适用于不需要多线程的地方</li><li><code>ConcurrentTaskExecutor</code>：<code>Executor</code>的适配类，不推荐使用。如果<code>ThreadPoolTaskExecutor</code>不满足要求时，才用考虑使用这个类</li><li><code>SimpleThreadPoolTaskExecutor</code>：是<code>Quartz</code>的<code>SimpleThreadPool</code>的类。线程池同时被<code>quartz</code>和<code>非quartz</code>使用，才需要使用此类</li><li><code>ThreadPoolTaskExecutor </code>：最常使用，推荐。 其实质是对<code>java.util.concurrent.ThreadPoolExecutor</code>的包装</li></ul><h3 id="2-2-ThreadPoolTaskExecutor的使用"><a href="#2-2-ThreadPoolTaskExecutor的使用" class="headerlink" title="2.2 ThreadPoolTaskExecutor的使用"></a>2.2 ThreadPoolTaskExecutor的使用</h3><h4 id="1-线程池配置类"><a href="#1-线程池配置类" class="headerlink" title="1. 线程池配置类"></a>1. 线程池配置类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@EnableAsync # 开启异步public class TaskExecuteConfig {    @Value("task.executor.core_pool_size")    private int corePoolSize;    @Value("task.executor.max_pool_size")    private int maxPoolSize;    @Value("task.executor.queue_capacity")    private int queueCapacity;    @Value("task.executor.keep_alive_seconds")    private long keepAliveSeconds;    @Bean(name = "threadPoolTaskExecutor")    public ThreadPoolTaskExecutor SendTaskExecutor(){        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();        // 配置核心线程数        executor.setCorePoolSize(corePoolSize);        //最大线程数        executor.setMaxPoolSize(maxPoolSize);        // 队列大小        executor.setQueueCapacity(queueCapacity);        // 线程池维护线程所允许的空闲时间，单位秒，超过则销毁        // 线程池线程数量大于corePoolSize时，多出来的空闲线程，多长时间会被销毁        executor.setKeepAliveSeconds(keepAliveSeconds);        // 配置线程池中的线程名称前缀        executor.setThreadNamePrefix("pool-send-task-executor");        // 线程池拒绝策略        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());        executor.initialize();        return executor;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置类中方法说明：</p><ul><li><code>corePoolSize</code>:线程池维护线程的最小数量</li><li><code>maxPoolSize</code>:线程池维护线程的最大数量，线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值。如果队列中任务已满，并且当前线程个数小于maxPoolSize，那么会创建新的线程来执行任务。</li><li><code>keepAliveSeconds</code>:空闲线程的存活时间，单位秒</li><li><code>queueCapacity</code>：持有等待执行的任务队列，一个阻塞队列，用来存储等待执行的任务，当线程池中的线程数超过它的<code>corePoolSize</code>的时候，线程会进入阻塞队列进行阻塞等待</li><li><code>RejectedExecutionHandler handler</code>： 线程池的拒绝策略，是指当任务添加到线程池中被拒绝，而采取的处理措施。<br>当任务添加到线程池中之所以被拒绝，可能是由于：第一，线程池异常关闭。第二，任务数量超过线程池的最大限制。</li></ul><blockquote><p>Reject 策略预定义有如下四种：</p><ol><li><code>ThreadPoolExecutor.AbortPolicy</code>策略，是默认的策略,处理程序遭到拒绝将抛出运行时 RejectedExecutionException</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>策略 ,调用者的线程会执行该任务,如果执行器已关闭,则丢弃.</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>策略，不能执行的任务将被丢弃.</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>策略，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）</li><li>自定义策略：当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务</li></ol></blockquote><h4 id="2-异步方法"><a href="#2-异步方法" class="headerlink" title="2. 异步方法"></a>2. 异步方法</h4><p><code>@Async</code>注解可以用在方法上，表示该方法是个异步方法，也可以用在类上，那么表示此类的所有方法都是异步方法2 异步方法会自动注入使用<code>ThreadPoolTaskExecutor</code>作为<code>TaskExecutor</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class AsyncTaskService {    @Async    public void executeAsync(Integer i) throws Exception{        System.out.println("线程ID：" + Thread.currentThread().getId() + "线程名字：" +Thread.currentThread().getName()+"执行异步任务:" + i);    }    @Async    public Future&lt;String&gt; executeAsyncPlus(Integer i) throws Exception {        System.out.println("线程ID：" + Thread.currentThread().getId() +"线程名字：" +Thread.currentThread().getName()+ "执行异步有返回的任务:" + i);        return new AsyncResult&lt;&gt;("success:"+i);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Redis</title>
      <link href="/tur-study/2023/03/31/Redis/SpringBoot%E6%95%B4%E5%90%88Redis/"/>
      <url>/tur-study/2023/03/31/Redis/SpringBoot%E6%95%B4%E5%90%88Redis/</url>
      
        <content type="html"><![CDATA[<p><code>SpringBoot </code>中对 <code>Redis </code>的集成模块为 <code>SpringDataRedis</code>。官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li><p>提供了对不同Redis客户端的整合（<code>Lettuce</code>和<code>Jedis</code>）</p></li><li><p>提供了<code>RedisTemplate</code>统一API来操作Redis</p></li><li><p>支持Redis的发布订阅模型</p></li><li><p>支持Redis哨兵和Redis集群</p></li><li><p>支持基于<code>Lettuce</code>的响应式编程</p></li><li><p>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</p></li><li><p>支持基于Redis的<code>JDKCollection</code>实现</p></li></ul><h3 id="1-SpringDataRedis-的基本使用"><a href="#1-SpringDataRedis-的基本使用" class="headerlink" title="1. SpringDataRedis 的基本使用"></a>1. SpringDataRedis 的基本使用</h3><p><code>SpringDataRedis </code>中提供了 <code>RedisTemplate </code>工具类，其中封装了各种对 Redis 的操作，并且将不同数据类型的操作 API 封装到了不同的类型中</p><table><thead><tr><th align="center">API</th><th align="center">返回值类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">redisTemplate.opsForValue()</td><td align="center">ValueOperations</td><td align="center">操作 String 类型数据</td></tr><tr><td align="center">redisTemplate.opsForHash()</td><td align="center">HashOperations</td><td align="center">操作 Hash 类型数据</td></tr><tr><td align="center">redisTemplate.opsForList()</td><td align="center">ListOperations</td><td align="center">操作 List 类型数据</td></tr><tr><td align="center">redisTemplate.opsForSet()</td><td align="center">SetOperations</td><td align="center">操作 Set 类型数据</td></tr><tr><td align="center">redisTemplate.opsForZSet()</td><td align="center">ZSetOperations</td><td align="center">操作 ZSet 类型数据</td></tr><tr><td align="center">redisTemplate</td><td align="center"></td><td align="center">通用命令</td></tr></tbody></table><p>SpringDataRedis 的使用步骤如下：</p><ul><li>引入 <code>spring-boot-starter-data-redis</code> 依赖</li><li>在 <code>application.yml</code> 中配置 Redis 信息</li><li>注入 <code>RedisTemplate </code></li></ul><h5 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Redis依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 连接池依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-对-Redis-进行配置"><a href="#2-对-Redis-进行配置" class="headerlink" title="2. 对 Redis 进行配置"></a>2. 对 Redis 进行配置</h5><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  redis:    port: 6379 # 端口    host: 172.25.248.60 # 虚拟机地址    password: 123456 # 密码    lettuce:      pool:        max-wait: 200  # 等待时间        max-active: 8  # 最大连接数        max-idle: 8    # 最大空闲连接        min-idle: 0    # 最小空闲连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-注入-RedisTemplate"><a href="#3-注入-RedisTemplate" class="headerlink" title="3. 注入 RedisTemplate"></a>3. 注入 RedisTemplate</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Resourceprivate RedisTemplate redisTemplate;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestpublic class SpringDataRedisTest {        @Resource    private RedisTemplate redisTemplate;    @Test    void testString(){        // 插入数据        redisTemplate.opsForValue().set("name","李四");        // 读取数据        Object name = redisTemplate.opsForValue().get("name");        System.out.println("name = " + name);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-SpringDataRedis-的序列化形式"><a href="#2-SpringDataRedis-的序列化形式" class="headerlink" title="2. SpringDataRedis 的序列化形式"></a>2. SpringDataRedis 的序列化形式</h3><p><code>RedisTemplate </code>可以接收任意 <code>Object </code>作为值写入 <code>Redis</code>，只不过写入前会把 <code>Object </code>序列化为 字节形式，默认是采用 <font color="red">JDK 序列化</font></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312040360.png" alt="image-20221201161846388"></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>解决方法：<font color="red">自定义 RedisTemplate 序列化方式</font></p><ol><li>自定义 RedisTemplate</li><li>修改 RedisTemplate 的序列化器为 GenericJackson2JsonRedisSerializer</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**    * 自定义序列化方式    * */   @Bean   public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factoryon){       // 创建 Template       RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();       // 设置连接工厂       redisTemplate.setConnectionFactory(factoryon);       // 设置序列化工具       GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();       // key 和 hash key 采用 string 序列化       redisTemplate.setKeySerializer(RedisSerializer.string());       redisTemplate.setHashKeySerializer(RedisSerializer.string());       // value 和 hashValue 采用 JSON 序列化       redisTemplate.setValueSerializer(jsonRedisSerializer);       redisTemplate.setHashValueSerializer(jsonRedisSerializer);       return redisTemplate;   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@AllArgsConstructor@NoArgsConstructorpublic class User {    private String name;    private int age;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestpublic class SpringDataRedisTest {    @Autowired    private RedisTemplate redisTemplate;    @Test    void testUser(){        User user = new User("张三", 20);        //        redisTemplate.opsForValue().set("user:101", user);        //        Object object = redisTemplate.opsForValue().get("user:101");        System.out.println(object);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试效果：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312041243.png" alt="image-20221201163630093"></p><h4 id="3-2-3-StringRedisTemplate"><a href="#3-2-3-StringRedisTemplate" class="headerlink" title="3.2.3 StringRedisTemplate"></a>3.2.3 StringRedisTemplate</h4><p>上述自定义序列化方式中使用的 JSON 序列化方式，虽然可以满足需求，但仍存在一些问题：为了在反序列化时知道对象的类型，JSON 序列化器会将类的 class 类型写入 json 结果中，存入 Redis，会带来<font color="red">额外的内存开销</font></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312042279.png" alt="image-20221201164227016"></p><p>为了节省内存空间，不使用 JSON 序列化器来处理 value，而是统一使用 String 序列化器，要求只能存储 String 类型的 key 和 value。当需要存储 Java 对象时，手动完成对象的序列化和反序列化</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312042345.png" alt="image-20221201165453196"></p><p>Spring 默认提供了一个 StringRedisTemplate 类，其 key 和 value 的序列化方式默认就是 String 方式</p><p>使用步骤如下：</p><ol><li>使用 StringRedisTemplate</li><li>写入 Redis时，手动把对象序列化为 JSON</li><li>读取 Redis 时，手动把读取到的 JSON 反序列化为对象</li></ol><p>示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestpublic class StringRedisTemplateTest {    @Autowired    private StringRedisTemplate stringRedisTemplate;    // JSON 工具    private static final ObjectMapper objectMapper = new ObjectMapper();    @Test    void testStringTemplate() throws JsonProcessingException {        // 准备对象        User user = new User("张三", 20);        // 手动序列化        String json = objectMapper.writeValueAsString(user);        // 写入一条数据到 redis        stringRedisTemplate.opsForValue().set("user:200", json);        // 读取数据        String value = stringRedisTemplate.opsForValue().get("user:200");        // 反序列化        User user1 = objectMapper.readValue(value, User.class);        System.out.println("user1 = " + user1);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312043076.png" alt="image-20221201171224124"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312042750.png" alt="image-20221201171209566"></p><blockquote><p> 可见内存大大减少了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/tur-study/2023/03/31/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/tur-study/2023/03/31/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="防火墙相关命令"><a href="#防火墙相关命令" class="headerlink" title="防火墙相关命令"></a>防火墙相关命令</h3><h4 id="1-查看防火墙状态"><a href="#1-查看防火墙状态" class="headerlink" title="1. 查看防火墙状态"></a>1. 查看防火墙状态</h4><pre class="line-numbers language-none"><code class="language-none">systemctl status firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>inactive(dead)：未启动</li><li>active（running）：已启动。字体呈现绿色</li></ul><h4 id="2-开启防火墙"><a href="#2-开启防火墙" class="headerlink" title="2. 开启防火墙"></a>2. 开启防火墙</h4><ul><li>开启防火墙</li></ul><pre class="line-numbers language-none"><code class="language-none">systemctl start firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>设置开机自启动</li></ul><pre class="line-numbers language-none"><code class="language-none">systemctl enable firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-开放或限制端口"><a href="#3-开放或限制端口" class="headerlink" title="3. 开放或限制端口"></a>3. 开放或限制端口</h4><h5 id="3-1-开放端口"><a href="#3-1-开放端口" class="headerlink" title="3.1 开放端口"></a>3.1 开放端口</h5><ol><li>开启指定端口</li></ol><pre class="line-numbers language-none"><code class="language-none">firewalld-cmd --zone=public --add-port=6379/tcp --permanent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>--permanent</code>：声明该设置永久有效。不加的话机器重启之后就失效了</p></blockquote><ol start="2"><li>重新载入防火墙设置，使设置生效</li></ol><pre class="line-numbers language-none"><code class="language-none">firewalld-cmd --reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>查看是否生效</li></ol><pre class="line-numbers language-none"><code class="language-none">fiewwalld-cmd --zone=publi --query-port=6379/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>输出yes：表示开启</li><li>输出no：表示未开启</li></ul><ol start="4"><li>查看当前系统打开的所有端口</li></ol><pre class="line-numbers language-none"><code class="language-none">firewalld-cmd --zone=public --list-ports<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>需要查询详细信息的的话，可以输入：<code>firewalld-cmd --list-all</code></p></blockquote><h5 id="3-2-限制端口"><a href="#3-2-限制端口" class="headerlink" title="3.2 限制端口"></a>3.2 限制端口</h5><ol><li>限制指定端口，将开放的命令的 add 更改为 remove</li></ol><pre class="line-numbers language-none"><code class="language-none">firewalld-cmd --zone=public --remove-port=6379/tcp --permanent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>设置之后，记得重载，不然设置是没有效果的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 整合 Sa-Token 基础</title>
      <link href="/tur-study/2023/03/31/SpringBoot/Sa-Token%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/"/>
      <url>/tur-study/2023/03/31/SpringBoot/Sa-Token%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="一、SpringBoot-集成-Sa-Token-示例"><a href="#一、SpringBoot-集成-Sa-Token-示例" class="headerlink" title="一、SpringBoot 集成 Sa-Token 示例"></a>一、SpringBoot 集成 Sa-Token 示例</h2><ol><li>添加依赖</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 权限认证，在线文档：https://sa-token.cc --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>设置配置文件</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">#=================== Sa-Token 配置 ========================sa-token:  # token名称，同时也是cookie名称  token-name: satoken  # token有效期，单位s，默认30天。-1代表永不过期  timeout: 2592000   # token临时有效期，指定时间内无操作就视为token过期，单位s  activity-timeout: -1  # 是否允许同一账号并发登录，true：允许一起登录。false：新登录挤掉旧登陆  is-concurrent: true  # 在多人登录同一账号时，是否共用一个token。true：所有登录共用一个token  is-share: true  # token风格  token-style: uuid  # 是否输出操作日志  is-log: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>创建测试 Controller</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping("/user/")public class UserController {    // 测试登录    @RequestMapping("doLogin")    public String doLogin(String username, String password) {        // 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对         if("zhang".equals(username) &amp;&amp; "123456".equals(password)) {            // 10001，仅代表用户id，需要以实际情况而定            StpUtil.login(10001);            return "登录成功";        }        return "登录失败";    }    // 查询登录状态    @RequestMapping("isLogin")    public String isLogin() {        return "当前会话是否登录：" + StpUtil.isLogin();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>测试：</li></ol><p>从浏览器一次访问上述测试接口：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303311524572.png"></p><hr><h2 id="二、登录认证"><a href="#二、登录认证" class="headerlink" title="二、登录认证"></a>二、登录认证</h2><h3 id="2-1-设计思路"><a href="#2-1-设计思路" class="headerlink" title="2.1 设计思路"></a>2.1 设计思路</h3><p>对于一些登陆之后才能访问的接口，如查询我的账号资料。通常的做法事增加一层接口校验</p><ul><li>如果校验通过，则：正常返回数据</li><li>若校验未通过，则：抛出异常，告知其需要先进行登录</li></ul><p>那么，判断会话是否登录的依据是什么？先来看看登录访问的流程：</p><p>登录访问的流程如下：</p><ol><li>用户提交 <code>name</code> + <code>password</code> 参数，调用登录接口</li><li>登陆成功，返回这个用户的 Token 会话凭证</li><li>用户后续的每次请求，都携带上这个 Token</li><li>服务器根据 Token 判断会话是否登陆成功</li></ol><p>所谓登录认证，指的就是服务器校验账号密码，为用户颁发Token 会凭证的过程，这个 Token 也是后续判断会话是否登录的关键所在</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303311541974.png"></p><h3 id="2-2-登录与注销"><a href="#2-2-登录与注销" class="headerlink" title="2.2 登录与注销"></a>2.2 登录与注销</h3><p>根据以上思路，Sa-Token 实现了一个会话登录函数：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 会话登录：参数填写要登录的账号id，建议数据类型：long | int | String，不可用传入复杂类型，如：User、Admin等等StpUtil.login(Object id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>基于上面这个函数，<code>Sa-Token 为要登录的账号创建了一个 Token 凭证，且通过 Cookie 上下文返回给了前端</code></p><p>Sa-Token 实现 <code>StpUtil.login(Object id)</code>，做了如下工作：</p><ol><li>检查此账号是否之前已有登录</li><li>为账号生成 <code>Token </code>凭证与 <code>Session </code>会话</li><li>通知全局侦听器，xx 账号登陆成功</li><li>将 <code>Token </code>注入到请求上下文</li><li>等等。。。</li></ol><p>基于 <code>StpUtil.login(Object id)</code>，一般登录接口代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 会话登录@RequestMapping("doLogin")public SaResult doLogin(String name, String pwd){    // 1. 比对前端提交的账号名称、密码    if("zhangsan".equals(name) &amp;&amp; "123456".equals(pwd)){        // 2. 根据账号id，进行登录        StpUtil.login(10001);        return SaResult.ok("登陆成功")；    }    return SaResult.error("登陆失败");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码实现中仅仅做了会话登录，而没有主动向前端返回 Token 信息。原因如下：<code>StpUtil.login(id)</code>利用了 Cookie 自动注入的特性，将原本需要返回的 Token 信息的代码，给省略了</p><blockquote><p>了解 Cookie 的两点基本功能：</p><ul><li>Cookie 可以从后端控制往浏览器中写入 Token 值</li><li>Cookie 会在前端每次发起请求时自动提交 Token 值</li></ul></blockquote><p>除了登录方法，Sa-Token 还实现了如下方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 当前会话注销登录StpUtil.logout();// 获取当前会话是否已经登录// true：已登录// false：未登录StpUtil.isLogin();// 校验当前会话是否已经登录，若未登录，抛出异常：NotLoginExceptionStpUtil.checkLogin();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>异常 <code>NotLoginException</code> 代表当前会话暂未登录，可能的原因有很多： 前端没有提交 Token、前端提交的 Token 是无效的、前端提交的 Token 已经过期 …… 等等</p></blockquote><h3 id="2-3-会话查询"><a href="#2-3-会话查询" class="headerlink" title="2.3 会话查询"></a>2.3 会话查询</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 获取当前会话账号id, 如果未登录，则抛出异常：`NotLoginException`StpUtil.getLoginId();// 类似查询API还有：StpUtil.getLoginIdAsString();    // 获取当前会话账号id, 并转化为`String`类型StpUtil.getLoginIdAsInt();       // 获取当前会话账号id, 并转化为`int`类型StpUtil.getLoginIdAsLong();      // 获取当前会话账号id, 并转化为`long`类型// ---------- 指定未登录情形下返回的默认值 ----------// 获取当前会话账号id, 如果未登录，则返回null StpUtil.getLoginIdDefaultNull();// 获取当前会话账号id, 如果未登录，则返回默认值 （`defaultValue`可以为任意类型）StpUtil.getLoginId(T defaultValue);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-Token-查询"><a href="#2-4-Token-查询" class="headerlink" title="2.4 Token 查询"></a>2.4 Token 查询</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 获取当前会话的token值StpUtil.getTokenValue();// 获取当前`StpLogic`的token名称StpUtil.getTokenName();// 获取指定token对应的账号id，如果未登录，则返回 nullStpUtil.getLoginIdByToken(String tokenValue);// 获取当前会话剩余有效期（单位：s，返回-1代表永久有效）StpUtil.getTokenTimeout();// 获取当前会话的token信息参数StpUtil.getTokenInfo();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 登录测试  */@RestController@RequestMapping("/acc/")public class LoginController {    // 测试登录    @RequestMapping("doLogin")    public SaResult doLogin(String name, String pwd) {        // 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对         if("zhang".equals(name) &amp;&amp; "123456".equals(pwd)) {            StpUtil.login(10001);            return SaResult.ok("登录成功");        }        return SaResult.error("登录失败");    }    // 查询登录状态    @RequestMapping("isLogin")    public SaResult isLogin() {        return SaResult.ok("是否登录：" + StpUtil.isLogin());    }    // 查询 Token 信息    @RequestMapping("tokenInfo")    public SaResult tokenInfo() {        return SaResult.data(StpUtil.getTokenInfo());    }    // 测试注销    @RequestMapping("logout")    public SaResult logout() {        StpUtil.logout();        return SaResult.ok();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、密码加密"><a href="#三、密码加密" class="headerlink" title="三、密码加密"></a>三、密码加密</h2>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Sa-token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/tur-study/2023/03/30/Redis/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/tur-study/2023/03/30/Redis/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一、初识-Redis"><a href="#一、初识-Redis" class="headerlink" title="一、初识 Redis"></a>一、初识 Redis</h2><h3 id="1-1-NoSQL"><a href="#1-1-NoSQL" class="headerlink" title="1.1 NoSQL"></a>1.1 NoSQL</h3><blockquote><p>对比 SQL 与 NoSQL 的区别</p></blockquote><ul><li>SQL：关系型数据库</li><li>NoSQL：非关系型数据库</li></ul><h4 id="1-1-1-数据结构"><a href="#1-1-1-数据结构" class="headerlink" title="1. 1.1 数据结构"></a>1. 1.1 数据结构</h4><h5 id="1-SQL"><a href="#1-SQL" class="headerlink" title="1. SQL"></a>1. SQL</h5><ul><li>结构化（Structured）</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312030264.png" alt="image-20221129224752320"></p><h5 id="2-NoSQL"><a href="#2-NoSQL" class="headerlink" title="2. NoSQL"></a>2. NoSQL</h5><ul><li>非结构化</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312030531.png" alt="image-20221129225146820"></p><h4 id="1-1-2-数据关联"><a href="#1-1-2-数据关联" class="headerlink" title="1.1.2 数据关联"></a>1.1.2 数据关联</h4><h5 id="1-SQL-1"><a href="#1-SQL-1" class="headerlink" title="1. SQL"></a>1. SQL</h5><ul><li>关联的（Relational）</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312030421.png" alt="image-20221129225809198"></p><h5 id="2-NoSQL-1"><a href="#2-NoSQL-1" class="headerlink" title="2. NoSQL"></a>2. NoSQL</h5><ul><li>无关联的</li></ul><h4 id="1-1-3-查询方式"><a href="#1-1-3-查询方式" class="headerlink" title="1.1.3 查询方式"></a>1.1.3 查询方式</h4><h5 id="1-SQL-2"><a href="#1-SQL-2" class="headerlink" title="1. SQL"></a>1. SQL</h5><ul><li>SQL 查询</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312031329.png" alt="image-20221129225909052"></p><h5 id="2-NoSQL-2"><a href="#2-NoSQL-2" class="headerlink" title="2. NoSQL"></a>2. NoSQL</h5><ul><li>非 SQL</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312031303.png" alt="image-20221129225951166"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312031649.png" alt="image-20221129230007224"></p><h4 id="1-1-4-事务特性"><a href="#1-1-4-事务特性" class="headerlink" title="1.1.4 事务特性"></a>1.1.4 事务特性</h4><h5 id="1-SQL-3"><a href="#1-SQL-3" class="headerlink" title="1. SQL"></a>1. SQL</h5><ul><li>ACID</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312032750.png" alt="image-20221129230120185"></p><h5 id="2-NoSQL-3"><a href="#2-NoSQL-3" class="headerlink" title="2. NoSQL"></a>2. NoSQL</h5><ul><li>BASE</li></ul><blockquote><ul><li>键值类型（Redis）</li><li>文档类型（MongoDB）</li><li>列类型（HBase）</li><li>Graph 类型（Neo4j）</li></ul></blockquote><h3 id="1-2-Redis-简介"><a href="#1-2-Redis-简介" class="headerlink" title="1.2 Redis 简介"></a>1.2 Redis 简介</h3><p><code>Redis</code>（Remote Dictionary Server），远程词典服务器，是一个基于内存的键值型 NoSQL 数据库</p><p>特征：</p><ul><li>键值（<code>key-value</code>）型，value 支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语音客户端</li></ul><h2 id="二、Redis-常见命令"><a href="#二、Redis-常见命令" class="headerlink" title="二、Redis 常见命令"></a>二、Redis 常见命令</h2><h3 id="2-1-Redis-数据结构"><a href="#2-1-Redis-数据结构" class="headerlink" title="2.1 Redis 数据结构"></a>2.1 Redis 数据结构</h3><p><code>Redis </code>是一个<code>key-value</code>的数据库，<code>key </code>一般是 <code>String </code>类型，不过 <code>value </code>的类型多种多样</p><ul><li><p>String：如 “hello world”</p></li><li><p>Hash：{ name: “Jack”, age: 21 }</p></li><li><p>List：[ A -&gt; B -&gt; C -&gt; C ]</p></li><li><p>Set：{ A, B, C}</p></li><li><p>SortedSet：{ A: 1, B: 2, C: 3 }</p></li><li><p>GEO：{ A: (120.3, 30.5 ) }</p></li><li><p>BitMap：0110110101110101011</p></li><li><p>HyperLog：0110110101110101011</p></li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312033258.png" alt="image-20230329163417027"></p><p>Redis 将操作不同数据类型的命令做了分组，在官网（<a href="https://redis.io/commands%EF%BC%89%E5%8F%AF%E4%BB%A5%E6%9F%A5%E5%88%B0%E4%B8%8D%E5%90%8C%E5%91%BD%E4%BB%A4">https://redis.io/commands）可以查到不同命令</a></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312033087.png" alt="image-20221130095432799"></p><h3 id="2-2-Redis-通用命令"><a href="#2-2-Redis-通用命令" class="headerlink" title="2.2 Redis 通用命令"></a>2.2 Redis 通用命令</h3><p>通用指令是部分数据类型都可用使用的指令，常见的有：</p><ul><li><p><code>KEYS</code>：查看复合模板的所有 <code>key</code>，<font color="red">不建议在生产环境设备上使用</font></p></li><li><p><code>DEL</code>：删除一个指定的 <code>key</code></p></li><li><p><code>EXISTS</code>：判断 <code>key </code>是否存在</p></li><li><p><code>EXPIRE</code>：给一个 <code>key</code> 设置有效期，有效期到期时，该 <code>key </code>会被自动删除</p></li><li><p><code>TTL</code>：查看一个 <code>key </code>的剩余有效期</p></li><li></li></ul><blockquote><p>通过 <code>help [command]</code> 可以查看一个命令的具体用法</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312034035.png" alt="image-20221130101123021"></p></blockquote><h3 id="2-3-String-类型"><a href="#2-3-String-类型" class="headerlink" title="2.3 String 类型"></a>2.3 String 类型</h3><h4 id="2-3-1-String-类型的三种格式"><a href="#2-3-1-String-类型的三种格式" class="headerlink" title="2.3.1 String 类型的三种格式"></a>2.3.1 String 类型的三种格式</h4><p><code>String </code>类型，即字符串类型，是 <code>Redis </code>中最简单的存储类型，其 <code>value</code> 是字符串，不过根据字符串的格式不同，可以分为如下3类：</p><ul><li><code>string</code>：普通字符串</li><li><code>int</code>：整数类型，可以做自增、自减操作</li><li><code>float</code>：浮点类型，可以做自增、自减操作</li></ul><blockquote><p>不管是哪种格式，底层都是字节数组形式存储，只不过编码方式不同。字符串类型的最大空间不能超过 512m</p></blockquote><h4 id="2-3-2-String-类型的常见命令"><a href="#2-3-2-String-类型的常见命令" class="headerlink" title="2.3.2 String 类型的常见命令"></a>2.3.2 String 类型的常见命令</h4><p><code>String </code>的常见命令有：</p><ul><li><code>SET</code>：添加或者修改已经存在的一个 String 类型的键值对</li><li><code>GET</code>：根据 key 获取 String 类型的 value</li><li><code>MSET</code>：批量添加多个 String 类型的键值对</li><li><code>MGET</code>：根据多个 key 获取多个 String 类型的 value</li><li><code>INCR</code>：让一个整型的 key 自增1</li><li><code>INCRBY</code>：让一个整型的 key 自增并指定步长。例如：incrby num 2 让 num 值自增 2</li><li><code>INCRBYFLOAT</code>：让一个浮点类型的数字自增并指定步长</li><li><code>SETNX</code>：添加一个 String 类型的键值对，前提是这个 key 不存在，否则不执行</li><li><code>SETEX</code>：添加一个 String 类型的键值对，并且指定有效期</li></ul><h4 id="2-3-3-key的结构"><a href="#2-3-3-key的结构" class="headerlink" title="2.3.3 key的结构"></a>2.3.3 key的结构</h4><blockquote><p>问题：如何区分不同类型的 key。例如：需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1</p></blockquote><p><code>Redis </code>的 <code>key </code>允许有多个单词形成层级结构，多个单词之间用 <code>: </code>隔开，格式如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312034365.png" alt="image-20221130150154494"></p><blockquote><p>格式并非固定，可以根据需求来删除或添加词条</p></blockquote><p>示例如下：</p><p>项目名称：hotel，有 user 和 product 两种不同类型的数据，定义 key 如下：</p><ul><li>user 相关的 key：hotel:user:1</li><li>product 相关的 key：hotel:product:1</li></ul><p>若 Value 是一个 Java 对象，如一个 User 对象，则可由将对象序列化为 JSON 字符串后存储</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312034736.png" alt="image-20221130185855534"></p><h3 id="2-4-Hash-类型"><a href="#2-4-Hash-类型" class="headerlink" title="2.4 Hash 类型"></a>2.4 Hash 类型</h3><h4 id="2-4-1-Hash-结构"><a href="#2-4-1-Hash-结构" class="headerlink" title="2.4.1 Hash 结构"></a>2.4.1 Hash 结构</h4><p>Hash 类型，也叫散列，其 value 是一个无序字典，类似于 Java 中的 HashMap 结构</p><blockquote><p>问题：String 结构是将对象序列化为 JSON 字符串后存储，当需要修改对象的某个字段时很不方便：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312035565.png" alt="image-20221130190238185"></p></blockquote><p>Hash 结构可以将对象中的的每个字段独立存储，可以针对单个字段做 CRUD</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312035131.png" alt="image-20221130191443785"></p><h4 id="2-4-2-Hash-类型常用命令"><a href="#2-4-2-Hash-类型常用命令" class="headerlink" title="2.4.2 Hash 类型常用命令"></a>2.4.2 Hash 类型常用命令</h4><p><code>Hash </code>的常见命令有：</p><ul><li><code>HSET key field value</code>：添加或者修改 hash 类型 key 的 field 的值</li><li><code>HGET key field</code>：获取一个 hash 类型 key field 的值</li><li><code>HMSET</code>：批量添加多个 hash类型 key 的 field 的值</li><li><code>HMGET</code>：批量获取多个 hash 类型 key 的 field 的值</li><li><code>HGETALL</code>：获取一个 hash 类型的 key 中的所有的 field 和 value</li><li><code>HKEYS</code>：获取一个 hash 类型的 key 中的所有的 field</li><li><code>HVALS</code>：获取一个 hash 类型的 key 中的所有的 value</li><li><code>HINCRBY</code>：让一个 hash 类型 key 的字段值自增并指定步长</li><li><code>HSETNX</code>：添加一个 hash 类型的 key 的 field 值，前提是这个 field 不存在，否则不执行</li></ul><h3 id="2-5-List-类型"><a href="#2-5-List-类型" class="headerlink" title="2.5 List 类型"></a>2.5 List 类型</h3><h4 id="2-5-1-List-类型简介"><a href="#2-5-1-List-类型简介" class="headerlink" title="2.5.1 List 类型简介"></a>2.5.1 List 类型简介</h4><p>Redis 中的 <code>List </code>类型与 Java 中的 <code>LinkedList </code>类似，可以看做是一个<font color="red">双向链表结构</font>，即支持正向检索也支持方向检索</p><p><code>List </code>类型的特征也与 <code>LinkedList </code>类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个<font color="red">有序数据</font>，例如：朋友圈点赞列表，评论列表</p><h4 id="2-5-2-List-类型的常见命令"><a href="#2-5-2-List-类型的常见命令" class="headerlink" title="2.5.2 List 类型的常见命令"></a>2.5.2 List 类型的常见命令</h4><ul><li><code>lpush key element … </code>：项列表左侧插入一个或多个元素</li><li><code>lpop key</code>：移除并返回列表左侧的第一个元素，没有则返回 nil</li><li><code>rpush key elemnt … </code>： 项列表右侧插入一个或多个元素</li><li><code>rpop key</code>：移除并返回列表右侧的第一个元素</li><li><code>lrange key star end</code>：返回一段角标范围内的所有元素</li><li><code>blpop 和 brpop</code>：与 lpop 和 rpop 类似，只不过在没有元素时等待指定时间，而不是直接返回 nil</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312036626.png" alt="image-20221130200304385"></p><blockquote><ol><li>如何利用 List 结构模拟一个栈：<ul><li>入口和出口在同一边</li></ul></li><li>如何利用 List 结构模拟一个队列：<ul><li>入口和出口不在同一边</li></ul></li><li>如何利用 List 结构模拟一个阻塞队列：<ul><li>入口和出口在不同边</li><li>出队时 <code>BLPOP </code>或 <code>BRPOP</code></li></ul></li></ol></blockquote><h3 id="2-6-Set-类型"><a href="#2-6-Set-类型" class="headerlink" title="2.6 Set 类型"></a>2.6 Set 类型</h3><h4 id="2-6-1-Set-结构"><a href="#2-6-1-Set-结构" class="headerlink" title="2.6.1 Set 结构"></a>2.6.1 Set 结构</h4><p>Redis 的 Set 结构与 Java 中的 HashSet 类似，可以看做是一个 value 为 null 的 HashMap</p><p>具备与 Hash Set 类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><h4 id="2-6-2-Set-的常见命令"><a href="#2-6-2-Set-的常见命令" class="headerlink" title="2.6.2 Set 的常见命令"></a>2.6.2 Set 的常见命令</h4><ul><li><code>sadd key member …</code> ： 向 set 中添加一个或多个元素</li><li><code>srem key member …</code> ：移除 set 中的指定元素</li><li><code>scard key</code>：返回 se 中元素的个数</li><li><code>sismember key member</code>：判断一个元素是否存在于 set 中</li><li><code>smembers</code>：获取 set 中的所有元素</li><li><code>sinter key1 key2 …</code> ： 求 key1 和 key2 的交集</li><li><code>sdiff key1 key2 … </code>：求 key1 和 key2 的差集</li><li><code>sunion key1 ke2 … </code>：求 key1 和 key2 的并集</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312036207.png" alt="image-20221130210806789"></p><h3 id="2-7-SortedSet-类型"><a href="#2-7-SortedSet-类型" class="headerlink" title="2.7 SortedSet 类型"></a>2.7 SortedSet 类型</h3><h4 id="2-7-1-SortedSet-类型"><a href="#2-7-1-SortedSet-类型" class="headerlink" title="2.7.1 SortedSet 类型"></a>2.7.1 SortedSet 类型</h4><p>Redis 的 SortedSet 是一个可排序的 set 集合，与 Java 中的 TreeSet 有些类似，但底层数据结构差别很大</p><p>SortedSet 中的每个元素都带有一个 score 属性，可以基于 score 属性对元素进行排序，底层的实现是一个跳表（SkipList）加 hash 表</p><p>SortedSet 具备以下特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><blockquote><p>因为 SortedSet 的可排序特性，经常被用来实现排行榜这样的功能</p></blockquote><h4 id="2-7-2-SortedSet-的常见命令"><a href="#2-7-2-SortedSet-的常见命令" class="headerlink" title="2.7.2 SortedSet 的常见命令"></a>2.7.2 SortedSet 的常见命令</h4><ul><li><code>zadd key score member</code>：添加一个或多个元素到 sorted set， 若已经存在则更新其 score 值</li><li><code>zrem key member </code>：删除 sorted set 中的一个指定元素</li><li><code>zscore key member</code>：获取 sorted set 中的指定元素的 score 值</li><li><code>zrank key member</code>：获取 sorted set 中指定元素的排名</li><li><code>zcard key</code>：获取 sorted set 的元素个数</li><li><code>zcount key min max</code>：统计 score 值在给定范围内的所有元素的个数</li><li><code>zincrby key increment member</code>：让 sorted set 中的指定元素自增，步长为指定的 increment 值</li><li><code>zrange key min max</code>：按照 score 排序后，获取指定排名范围内的元素，这是个左开右闭的区间</li><li><code>zrangebyscore key min max</code>：按照 score 排序后，获取指定 score 范围内的元素</li><li><code>zdiff、zinter、zunion</code>：求差集、交集、并集</li></ul><blockquote><p>==注意：==所有的排名都是默认升序，若需要降序则在命令的 Z 后面添加 rev 即可</p></blockquote><h2 id="三、Redis-的-Java-客户端"><a href="#三、Redis-的-Java-客户端" class="headerlink" title="三、Redis 的 Java 客户端"></a>三、Redis 的 Java 客户端</h2><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/clients">https://redis.io/clients</a></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312037116.png" alt="image-20221201095200934"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312037112.png" alt="image-20221201095300937"></p><h3 id="3-1-Jedis"><a href="#3-1-Jedis" class="headerlink" title="3.1 Jedis"></a>3.1 Jedis</h3><blockquote><p>jedis 官网地址：<a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p></blockquote><h4 id="3-1-1-Jedis-的基本使用"><a href="#3-1-1-Jedis-的基本使用" class="headerlink" title="3.1.1 Jedis 的基本使用"></a>3.1.1 Jedis 的基本使用</h4><p>Jedis 的使用步骤如下：</p><ul><li>引入依赖</li><li>创建 Jedis 对象，建立连接</li><li>使用 Jedis，方法名与 Redis 命令一致</li><li>释放资源</li></ul><p>具体如下：</p><ol><li><p>引入依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- redis 依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>建立连接：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.junit.jupiter.api.BeforeEach;import redis.clients.jedis.Jedis;public class RedisTest {    private Jedis jedis;    /**     * 建立连接     * */    @BeforeEach    public void setUp(){        // 建立连接        jedis = new Jedis("127.0.0.1", 6379);        // 设置密码        jedis.auth("123456");        // 选择库        jedis.select(0);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试 String</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.junit.jupiter.api.Test;....public class RedisTest {    ...    /**     * 测试 String     * */    @Test    void testString(){        // 插入数据，方法名称即redis命令的名称        String result = jedis.set("name", "张三");        System.out.println("result = " + result);        // 获取数据        String name = jedis.get("name");        System.out.println("name = " + name);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>释放资源：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.junit.jupiter.api.AfterEach;public class RedisTest {...    /**     * 释放资源     * */    @AfterEach    public void tearDown(){        // 释放资源        if(jedis != null){            jedis.close();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312038309.png" alt="image-20221201100027562"></p><h4 id="3-1-2-Jedis-连接池"><a href="#3-1-2-Jedis-连接池" class="headerlink" title="3.1.2 Jedis 连接池"></a>3.1.2 Jedis 连接池</h4><p>Jedis 本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用 Jedis 连接池代替 Jedis 的直连方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class JedisConnectionFactory {    private static final JedisPool jedisPool;        static {        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();        // 最大连接数        jedisPoolConfig.setMaxTotal(8);        // 最大空闲连接        jedisPoolConfig.setMaxIdle(8);        // 最小空闲连接        jedisPoolConfig.setMinIdle(0);        // 设置最长等待时间，ms        jedisPoolConfig.setMaxWaitMillis(200);        jedisPool = new JedisPool(jedisPoolConfig, "127.0.0.1", 6379, 1000, "123456");    }    /**     * 获取Jedis对象     * */    public static Jedis getJedis() {        return jedisPool.getResource();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的一些使用技巧</title>
      <link href="/tur-study/2023/03/29/MySQL/MySQL%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/tur-study/2023/03/29/MySQL/MySQL%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="1-获取指定id的上一个数据或下一个数据"><a href="#1-获取指定id的上一个数据或下一个数据" class="headerlink" title="1. 获取指定id的上一个数据或下一个数据"></a>1. 获取指定id的上一个数据或下一个数据</h3><p>示例如下：</p><ul><li>获取上一个数据</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from blog_article where id &lt; 123 order by id desc limit 1                                                 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体实现思想如下：</p><p>将表中数据进行倒序排列即 <code>desc</code>，选择 <code>id </code>小于指定值的数据即 <code>id $lt; 123</code>，并指定输出数据为1即 <code>limit 1</code></p><blockquote><p><code>$lt;</code> 代表小于号<code> &lt;</code></p></blockquote><ul><li>获取上一个数据</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from blog_article where id &gt; 123 order by id asc limit 1    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体实现思想如下：</p><p>将表中数据进行正序排列即 <code>asc</code>，选择 <code>id </code>大于指定值的数据即 <code>id $gt; 123</code>，并指定输出数据为1即 <code>limit 1</code></p><blockquote><p><code>$gt;</code> 代表小于号 <code>&gt;</code></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interceptor 拦截器的使用</title>
      <link href="/tur-study/2023/03/28/SpringBoot/Interceptor%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/03/28/SpringBoot/Interceptor%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/mathison-tur/blog_img/raw/master/md_img/image-20221129224752320.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filter 过滤器的使用</title>
      <link href="/tur-study/2023/03/28/SpringBoot/Filter%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/03/28/SpringBoot/Filter%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h3><p><code>SpringBoot </code>的过滤器，在 <code>web </code>开发中可以过滤指定的 <code>url</code>，如过滤掉不需要的接口请求，同时也可以修改 <code>request </code>和 <code>response </code>内容</p><p>过滤器的应用场景：</p><ul><li>过滤敏感词汇（防止sql注入）</li><li>设置字符编码</li><li>URL级别的权限访问控制</li><li>压缩相应信息</li></ul><h3 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h3><p>实现方式有以下两种：</p><ol><li>使用<code> spring boot</code> 提供的 <code>FilterRegistrationBean </code>注册 <code>Filter</code></li><li>使用原生 <code>servlet </code>注解定义 <code>Filter</code></li></ol><blockquote><p>两种方式的本质都是一样的，都是去FilterRegistrationBean 注册自定义 Filter</p></blockquote><h4 id="2-1-使用-SpringBoot-提供的-FIlterRegitrationBean-注册-Filter"><a href="#2-1-使用-SpringBoot-提供的-FIlterRegitrationBean-注册-Filter" class="headerlink" title="2.1 使用 SpringBoot 提供的 FIlterRegitrationBean 注册 Filter"></a>2.1 使用 SpringBoot 提供的 FIlterRegitrationBean 注册 Filter</h4><ol><li>定义 Filter</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">import lombok.extern.slf4j.Slf4j;import javax.servlet.*;import javax.servlet.FilterConfig;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;@Slf4jpublic class MyCorsFilter implements Filter {    // 令牌    static final String TOKEN = "1234567890";    // 内部接口    public static List&lt;String&gt; INSIDE_URLS = List.of("/web/article/list", "/web//article/condition");    // 白名单    public static List&lt;String&gt; WHITE_PATH = List.of("/white", "/login");    /**     * 核心过滤方法     * */    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {        // doFilter 方法中的 request 和 response 需要转换为对应的 HttpServletRequest 和 HttpServletResponse 方便调用某些方法        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpServletResponse response = (HttpServletResponse) servletResponse;        String ip = request.getRemoteAddr();        String requestURI = request.getRequestURI();        log.info("ip = {}, requestURI = {}", ip, requestURI);        if (INSIDE_URLS.contains(requestURI)){            // 内部接口，直接通过            filterChain.doFilter(servletRequest, servletResponse);            return;        }        if (WHITE_PATH.contains(requestURI)){            // 白名单接口，直接通过            filterChain.doFilter(servletRequest, servletResponse);            return;        }        String token = request.getHeader("token");        if (TOKEN.equals(token)){            // 令牌校验通过，允许接口通过            filterChain.doFilter(servletRequest, servletResponse);        }else {            // 令牌校验不通过，重定向到登陆界面        }    }    /**     * 初始化     * */    public void init(FilterConfig filterConfig) {}    /**     * 销毁方法     * */    public void destroy() {}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>注册自定义Filter过滤器配置类</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class FilterConfig {    /**     * 基础过滤器     * */    @Bean    public FilterRegistrationBean&lt;Filter&gt; baseFilter(){        FilterRegistrationBean&lt;Filter&gt; filterRegistrationBean = new FilterRegistrationBean&lt;&gt;();        filterRegistrationBean.setFilter(new MyCorsFilter());        filterRegistrationBean.setUrlPatterns(List.of("/*"));        filterRegistrationBean.setOrder(1);        return filterRegistrationBean;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试可以发现白名单和内部接口可以通过，而不在这两个范围内的接口若令牌token不对应，则不能通过</p><h3 id="3-跨域请求的实现"><a href="#3-跨域请求的实现" class="headerlink" title="3. 跨域请求的实现"></a>3. 跨域请求的实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class MyCorsFilter implements Filter {    public void doFilter(ServletRequest req, ServletResponse res,                         FilterChain chain) throws IOException, ServletException {        HttpServletResponse response = (HttpServletResponse) res;        response.setHeader("Access-Control-Allow-Origin", "*");        response.setHeader("Access-Control-Allow-Credentials", "true");        response.setHeader("Access-Control-Allow-Methods", "*");        response.setHeader("Access-Control-Allow-Headers", "Content-Type,Access-Token,Authorization");        response.setHeader("Access-Control-Expose-Headers", "*");        response.setHeader("Access-Control-Max-Age", "3600");        chain.doFilter(req, res);    }    public void init(FilterConfig filterConfig) {}    public void destroy() {}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在接口分组添加<code> @CrossOrigin</code>注解可以实现该接口分组的所有接口允许跨域请求</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis Plus 分页插件的使用</title>
      <link href="/tur-study/2023/03/28/MybatisPlus/Mybatis%20Plus%20%E4%B8%AD%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/03/28/MybatisPlus/Mybatis%20Plus%20%E4%B8%AD%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>官网：<a href="https://baomidou.com/">https://baomidou.com/</a></p></blockquote><p>Spring Boot 中的使用步骤如下：</p><h3 id="1-分页配置"><a href="#1-分页配置" class="headerlink" title="1. 分页配置"></a>1. 分页配置</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class MybatisPlusConfig{        @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor(){        // 1. 创建 MybatisPlusInterceptor 拦截器对象        MybatisPlusInterceptor mpInterceptor = new MybatisPlusInterceptor();        // 2. 添加分页拦截器，并声明使用的数据库类型        mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));        return mpInterceptor;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-使用官方已实现的接口实现分页"><a href="#2-使用官方已实现的接口实现分页" class="headerlink" title="2 使用官方已实现的接口实现分页"></a>2 使用官方已实现的接口实现分页</h3><blockquote><p>Service CRUD 接口</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 无条件分页查询IPage&lt;T&gt; page(IPage&lt;T&gt; page);// 条件分页查询IPage&lt;T&gt; page(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper);// 无条件分页查询IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page);// 条件分页查询IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参数说明</strong></p><table><thead><tr><th align="center">类型</th><th align="center">参数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IPage<t></t></td><td align="center">page</td><td align="center">翻页对象</td></tr><tr><td align="center">Wrapper<t></t></td><td align="center">queryWrapper</td><td align="center">实体对象封装操作类 QueryWrapper</td></tr></tbody></table><h3 id="3-自定义-mapper-method-使用分页"><a href="#3-自定义-mapper-method-使用分页" class="headerlink" title="3. 自定义 mapper # method 使用分页"></a>3. 自定义 mapper # method 使用分页</h3><p>示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">IPage&lt;UserVo&gt; selectPageVo(IPage&lt;?&gt; page, Integer state);// or (class MyPage extends Ipage&lt;UserVo&gt;{ private Integer state; })MyPage selectPageVo(MyPage page);// orList&lt;UserVo&gt; selectPageVo(IPage&lt;UserVo&gt; page, Integer state);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectPageVo<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx.xxx.xxx.UserVo<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    SELECT id,name FROM user WHERE state=#{state}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>如果返回类型是 IPage 则入参的 IPage 不能为null,因为 返回的IPage == 入参的IPage; 如果想临时不分页,可以在初始化IPage时size参数传 &lt;0 的值;</li><li>如果返回类型是 List 则入参的 IPage 可以为 null(为 null 则不分页),但需要你手动 入参的IPage.setRecords(返回的 List);</li><li>如果 xml 需要从 page 里取值,需要 <code>page.属性</code> 获取</li></ul></blockquote><h3 id="4-Page-类"><a href="#4-Page-类" class="headerlink" title="4. Page 类"></a>4. Page 类</h3><p>该类继承了 <code>IPage</code> 类，实现了 <code>简单分页模型</code> 如果要实现自己的分页模型可以继承 <code>Page</code> 类或者实现 <code>IPage</code> 类</p><table><thead><tr><th align="center">属性名</th><th align="center">类型</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">records</td><td align="center">List</td><td align="center">emptyList</td><td align="center">查询数据列表</td></tr><tr><td align="center">total</td><td align="center">Long</td><td align="center">0</td><td align="center">查询列表总记录数</td></tr><tr><td align="center">size</td><td align="center">Long</td><td align="center">10</td><td align="center">每页显示条数，默认 <code>10</code></td></tr><tr><td align="center">current</td><td align="center">Long</td><td align="center">1</td><td align="center">当前页</td></tr><tr><td align="center">orders</td><td align="center">List</td><td align="center">emptyList</td><td align="center">排序字段信息，允许前端传入的时候，注意 SQL 注入问题，可以使用 <code>SqlInjectionUtils.check(...)</code> 检查文本</td></tr><tr><td align="center">optimizeCountSql</td><td align="center">boolean</td><td align="center">true</td><td align="center">自动优化 COUNT SQL 如果遇到 <code>jSqlParser</code> 无法解析情况，设置该参数为 <code>false</code></td></tr><tr><td align="center">optimizeJoinOfCountSql</td><td align="center">boolean</td><td align="center">true</td><td align="center">自动优化 COUNT SQL 是否把 join 查询部分移除</td></tr><tr><td align="center">searchCount</td><td align="center">boolean</td><td align="center">true</td><td align="center">是否进行 count 查询，如果指向查询到列表不要查询总记录数，设置该参数为 <code>false</code></td></tr><tr><td align="center">maxLimit</td><td align="center">Long</td><td align="center"></td><td align="center">单页分页条数限制</td></tr><tr><td align="center">countId</td><td align="center">String</td><td align="center"></td><td align="center"><code>xml</code> 自定义 <code>count</code> 查询的 <code>statementId</code></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Knife4j配置与使用(OpenAPI2)</title>
      <link href="/tur-study/2023/03/27/SpringBoot/Knife4j%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/03/27/SpringBoot/Knife4j%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h3><p>maven 坐标如下</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.xiaoymin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>knife4j-openapi2-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 具体版本自行选择 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Spring Boot 版本建议在 2.4.0 ~ 3.0.0 之间</p></blockquote><h3 id="2-配置-yml-属性"><a href="#2-配置-yml-属性" class="headerlink" title="2. 配置 yml 属性"></a>2. 配置 yml 属性</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">knife4j:  enable: true  openapi:    title: 这是文档标题 # 文档标题    description: 这是简介 # 简介    email: 123456789@qq.com # 创建人邮件    concat: tur # 创建者    url: https://docs.xiaominfo.com # 项目文档地址    version: v4.0 # 版本    license: Apache 2.0 # 许可证    license-url: https://stackoverflow.com/ # 许可证地址    terms-of-service-url: https://stackoverflow.com/    group: # 分组      test1: # 组名，用以区分其他组        group-name: 分组名称 # 组别名称        api-rule: package # api扫描方式        api-rule-resources: # 指定扫描的位置          - com.knife4j.demo.new3 # 存放接口、对象的包<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问 Knife4j 的文档地址：<code>http://ip:sort/doc.html</code></p><h3 id="3-Java注解"><a href="#3-Java注解" class="headerlink" title="3. Java注解"></a>3. Java注解</h3><h5 id="1-Api：定义接口分组名称"><a href="#1-Api：定义接口分组名称" class="headerlink" title="1. @Api：定义接口分组名称"></a>1. <code>@Api</code>：定义接口分组名称</h5><p>参数说明：</p><ul><li><code>tags</code>:说明该类的作用，可以在 UI 界面上看到的注解</li><li><code>value</code>：一般会自动获取接口分组的名称，可以不用设置</li></ul><h5 id="2-ApiImplicitParam：单个参数注释"><a href="#2-ApiImplicitParam：单个参数注释" class="headerlink" title="2. @ApiImplicitParam：单个参数注释"></a>2. <code>@ApiImplicitParam</code>：单个参数注释</h5><p>用在 <code>@ApiImplicitParams</code> 中，指定一个请求参数的各个方面</p><ul><li><code>name</code>：参数名</li><li><code>value</code>：参数说明</li><li><code>required</code>：参数时是否必须传</li><li><code>paramType</code>：参数位置，有以下可选值<ul><li><code>header</code>：请求头 <code>@RequestHeader</code></li><li><code>query</code>：?param=value格式 <code>@RequestParam</code></li><li><code>path</code>：路径，Restful风格接口 <code>@PathVariable</code></li><li><code>body</code>：请求体</li><li><code>form</code>：以form表单的形式提交</li></ul></li><li><code>dataType</code>：参数类型，默认 String，其他值为 Integer</li><li><code>defaultValue</code>：参数的默认值</li></ul><h5 id="3-ApiImplicitParams：多个参数注释"><a href="#3-ApiImplicitParams：多个参数注释" class="headerlink" title="3. @ApiImplicitParams：多个参数注释"></a>3. <code>@ApiImplicitParams</code>：多个参数注释</h5><p>用在请求方法上，表示一组参数的说明</p><h5 id="4-ApiModel：实体类定义"><a href="#4-ApiModel：实体类定义" class="headerlink" title="4. @ApiModel：实体类定义"></a>4. <code>@ApiModel</code>：实体类定义</h5><h5 id="5-ApiModelProperty：实体属性定义"><a href="#5-ApiModelProperty：实体属性定义" class="headerlink" title="5. @ApiModelProperty：实体属性定义"></a>5. <code>@ApiModelProperty</code>：实体属性定义</h5><ul><li><code>value</code>：字段说明</li><li><code>name</code>：属性名</li><li><code>dataType</code>：属性类型</li><li><code>required</code>：是否必填</li><li><code>example</code>：举例说明</li><li><code>hidden</code>：隐藏</li></ul><h5 id="6-ApiOperation：接口定义"><a href="#6-ApiOperation：接口定义" class="headerlink" title="6. @ApiOperation：接口定义"></a>6. <code>@ApiOperation</code>：接口定义</h5><ul><li><code>value</code>：接口说明</li><li><code>httpMethod</code>：接口请求方式</li><li><code>response</code>：接口返回参数类型</li><li><code>notes</code>：接口发布说明</li></ul><h5 id="7-ApiParam：参数注释"><a href="#7-ApiParam：参数注释" class="headerlink" title="7. @ApiParam：参数注释"></a>7. <code>@ApiParam</code>：参数注释</h5><h5 id="8-ApiResponse：响应码"><a href="#8-ApiResponse：响应码" class="headerlink" title="8. @ApiResponse：响应码"></a>8. <code>@ApiResponse</code>：响应码</h5><p>用在 <code>@ApiResponses</code> 中，一般用于表达一个错误或正确的响应信息</p><ul><li><code>code</code>：响应码</li><li><code>message</code>：响应信息</li><li><code>resposne</code>：抛出异常类</li></ul><h5 id="9-ApiResponses：多个响应码"><a href="#9-ApiResponses：多个响应码" class="headerlink" title="9. @ApiResponses：多个响应码"></a>9. <code>@ApiResponses</code>：多个响应码</h5><p>用在请求的方法上，表示一组响应</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中select传递多个参数</title>
      <link href="/tur-study/2023/03/27/MybatisPlus/Mybatis%E4%B8%ADselect%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/"/>
      <url>/tur-study/2023/03/27/MybatisPlus/Mybatis%E4%B8%ADselect%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-单个参数"><a href="#1-单个参数" class="headerlink" title="1. 单个参数"></a>1. 单个参数</h3><p>传递单个参数时，方法名中的参数和 sql 语句中的参数名一致</p><p>如下：方法参数为 id，sql 中的参数也为 id</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// XXMapper.javapublic List&lt;XXBean&gt; getXXBeanList(Long id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- XXMapper.xml --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getXXXBeanList<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.Long<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>XXBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>　　select t.* from tableName t where t.id= #{id}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-多参数"><a href="#2-多参数" class="headerlink" title="2. 多参数"></a>2. 多参数</h3><p>多参数传递时不能使用 <code>parameterType</code>，除非所有参数的类型都一致，改用<code>#{index}</code>，是第几个就用第几个的索引，索引从<code>0</code>开始</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// XXMapper.javapublic List&lt;XXBean&gt; getXXBeanList(Long id, String name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- XXMapper.xml --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getXXXBeanList<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>XXBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>　　select * from tableName t where id=#{0} and name=#{1}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Map封装多参数"><a href="#3-Map封装多参数" class="headerlink" title="3. Map封装多参数"></a>3. Map封装多参数</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// XXMapper.javapublic List&lt;XXBean&gt; getXXBeanList(HashMap map);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- XXMapper.xml --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getXXXBeanList<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hashmap<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>XXBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>　　select * from tableName t where id= #{id} and name=#{name}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>map </code>中的 <code>key </code>名即是在 <code>#{}</code> 中使用的</p><h3 id="4-List-封装-in"><a href="#4-List-封装-in" class="headerlink" title="4. List 封装 in"></a>4. List 封装 in</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// XXMapper.javapublic List&lt;XXBean&gt; getXXBeanList(List&lt;String&gt; list);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- XXMapper.xml --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getXXXBeanList<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hashmap<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>XXBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>　　select 字段... from tableName t where id in    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    #{item}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>foreach 最后的效果是：<code>select 字段 from tableName where id in ('1', '2', '3',...)</code></p><h3 id="5-使用注解方式"><a href="#5-使用注解方式" class="headerlink" title="5. 使用注解方式"></a>5. 使用注解方式</h3><p>在方法上使用 <code>@Param</code> 注解注明参数名</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Page&lt;ArticleVO&gt; selectPreviewPage(            @Param("page") Page&lt;Object&gt; page,            @Param("publish") int publish,            @Param("categoryId") Long categoryId,            @Param("tagId") Long tagId);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectPreviewPage<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.blog.model.vo.ArticleVO<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        select                                                                          a.id as id,                                                                 a.title as title,                                                           a.avatar as avatar,                                                         a.is_stick as isStick,                                                      a.create_time as createTime,                                                c.id as categoryId,                                                         c.name as categoryName                                                  from blog_article a JOIN blog_category c on a.category_id = c.id            where a.is_publish = #{publish}                                             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>categoryId != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                                                and a.category_id = #{categoryId}                                       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>                                                                       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>tagId != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                                                     and a.id in (                                                                   select article_id from blog_article_tag where tag_id = #{tagId}         )                                                                       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>                                                                       order by a.is_stick desc, a.create_time desc                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>                                                                   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Hexo Using</title>
      <link href="/tur-study/2023/03/27/Java/GIt%20Hexo%20%E6%93%8D%E4%BD%9C/"/>
      <url>/tur-study/2023/03/27/Java/GIt%20Hexo%20%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Hexo-基本命令"><a href="#1-Hexo-基本命令" class="headerlink" title="1. Hexo 基本命令"></a>1. Hexo 基本命令</h4><pre class="line-numbers language-none"><code class="language-none">hexo init --新建一个网站，若没有设置folder，默认在当前文件夹建立网站hexo generate --生成个人博客所需的静态页面hexo server --启动服务器，默认访问端口：loclahost:4000hexo deploy --部署个人博客hexo clean --清除缓存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上命令都能用首字母缩写完成</p><pre class="line-numbers language-none"><code class="language-none">hexo g --generate 生成个人博客所需的静态页面hexo s --serverhexo d --deploy 部署个人博客hexo c --clean 清除缓存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-写文章用到的命令"><a href="#2-写文章用到的命令" class="headerlink" title="2. 写文章用到的命令"></a>2. 写文章用到的命令</h4><pre class="line-numbers language-none"><code class="language-none">hexo new --path java/ "文章标题" --新建文章hexo new page "页面名" -- 新建页面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-p, –path</td><td align="left">自定义新文章的路径</td></tr><tr><td align="left">-r, –replace</td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left">-s, –slug</td><td align="left">文章的Slug，作为新文章的文件名和发布后的URL</td></tr></tbody></table><p>编辑博客时使用如下命令</p><pre class="line-numbers language-none"><code class="language-none">hexo s --debug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后访问<a href="http://localhost:4000/%E6%9D%A5%E8%BF%9B%E5%85%A5%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%9B%B4%E6%94%B9%E4%BA%86%E9%85%8D%E7%BD%AE%E6%88%96%E6%96%87%E7%AB%A0%E5%90%8E%E9%9A%8F%E6%97%B6%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E6%9D%A5%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C%E3%80%82">http://localhost:4000/来进入调试模式，更改了配置或文章后随时刷新页面来查看效果。</a></p><h4 id="3-部署博客的步骤"><a href="#3-部署博客的步骤" class="headerlink" title="3. 部署博客的步骤"></a>3. 部署博客的步骤</h4><pre class="line-numbers language-none"><code class="language-none">hexo cleanhexo generatehexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>后两步可以简写为<code>hexo g -d</code></p><h4 id="4-目录结构说明"><a href="#4-目录结构说明" class="headerlink" title="4. 目录结构说明"></a>4. 目录结构说明</h4><pre class="line-numbers language-none"><code class="language-none">|  +-- .deploy      #hexo deploy生成的文件|  +-- node_modules  #npm组件|  +-- public        #生成的静态网页文件|  +--scaffolds      #模板|  +-- source        #博客正文和其他源文件|  |  +-- _posts    #我们自己写的文章以md结尾|  +-- themes        #主题|  +-- _config.yml  #全局配置文件|  `-- package.json  #定义了hexo所需要的各种模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-配置文件"><a href="#5-配置文件" class="headerlink" title="5. 配置文件"></a>5. 配置文件</h4><p>在文件夹跟目录下的<code>_config.yml</code>叫做<strong>站点配置文件</strong>,同样的文件名我们可以在<code>theme</code>文件夹下的主题文件夹里面也找的。而主题文件夹下的<code>_config.yml</code>叫做主题配置文件。这里说明一下站点配置文件：</p><pre class="line-numbers language-none"><code class="language-none"># Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #站点信息title:  #标题subtitle:  #副标题description:  #站点描述，给搜索引擎看的author:  #作者email:  #电子邮箱language: zh-CN #语言# URL #链接格式url:  #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:# Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮enable: true #是否启用line_number: true #显示行号tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev# Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap# Deployment #部署，将 lmintlcx 改成用户名deploy:type: gitrepo: github创库地址.gitbranch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal详解</title>
      <link href="/tur-study/2023/03/27/Java/ThreadLocal%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/03/27/Java/ThreadLocal%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ThreadLocal-简介"><a href="#一、ThreadLocal-简介" class="headerlink" title="一、ThreadLocal 简介"></a>一、ThreadLocal 简介</h2><p>ThreadLocal 叫做 <font color="red"><strong>线程变量</strong></font>，指 ThreadLocal 中<font color="red">填充的变量</font>属于<font color="red">当前线程</font>，该变量对于其他线程而言是隔离的，即该变量是当前线程独有的变量。ThreadLocal 为变量在每个线程中都创建了副本，那么每个线程都可以访问自己内部的副本变量</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/tur-study/2023/03/26/hello-world/"/>
      <url>/tur-study/2023/03/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
