<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java 序列化与反序列化详解</title>
      <link href="/tur-study/2023/05/12/Java/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/05/12/Java/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><h3 id="1-1-序列化与反序列化概念"><a href="#1-1-序列化与反序列化概念" class="headerlink" title="1.1 序列化与反序列化概念"></a>1.1 序列化与反序列化概念</h3><ul><li><p>Java 序列化是指将对象转化成一个字节序列（二进制数据）的过程</p><p>将序列化对象写入文件之后，可以从文件中读取出来，并且对它进行反序列化</p></li><li><p>Java 反序列化是指将一个对象的字节序列回复成 Java 对象的多成</p><p>一个平台中序列化的对象，可以在另一个平台进行反序列化，这个过程在 JVM 中完成，得益于 Java 的可移植性</p></li></ul><h3 id="1-2-序列化与反序列化的过程"><a href="#1-2-序列化与反序列化的过程" class="headerlink" title="1.2 序列化与反序列化的过程"></a>1.2 序列化与反序列化的过程</h3><p>内存中的数据信息被拆分成一小块一小块的部分，为每个小块设置编号，然后存放到硬盘文件中，也就是将 Java 对象对象的状态保存下来存储到文件中的过程就叫做序列化。</p><p>将硬盘中保存了 Java 对象状态的字节序列按照编号组装成对象恢复到内存中，这个过程称为反序列化。</p><h3 id="1-3-核心类和关键字"><a href="#1-3-核心类和关键字" class="headerlink" title="1.3 核心类和关键字"></a>1.3 核心类和关键字</h3><ul><li><code>ObjectOutputStream</code>：IO 类，包含序列化对象的方法 <code>writeObject(Object o)</code></li><li><code>ObjectInputStream</code>：IO 类，包含序列化对象的方法 <code>readObject()</code></li></ul><p>上面两个 IO 流类是高层次的数据库，需要借助文件流进行序列化与反序列化操作。</p><ul><li><p><code>Serializable</code>：接口，是一个标志性接口，标识实现接口的类可以在 JVM 中进行序列化，JVM 会为该类自动生成一个序列化版本号。<font color="red">参与序列化与反序列化的类必须实现 <code>Serializable </code>接口</font></p><blockquote><p>在Java中，如果一个类实现了Serializable接口，JVM底层就会帮我们实现序列化和反序列化。如果我们不实现Serializable接口，那么就需要我们自己实现序列化和反序列化</p></blockquote></li><li><p><code>serialVersionUID</code>：类属性，序列化版本号，用于给 JVM 区别同名类，没有提供版本号时，JVM 会默认提供序列化版本号</p></li><li><p><code>transient</code>：关键字，当序列化时不希望某些属性参与，则可由使用这个关键字标注该属性</p></li></ul><h2 id="二、序列化应用"><a href="#二、序列化应用" class="headerlink" title="二、序列化应用"></a>二、序列化应用</h2><h3 id="2-1应用示例"><a href="#2-1应用示例" class="headerlink" title="2.1应用示例"></a>2.1应用示例</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student implements Serializable {    private String name;    private int age;    // 省略有参构造、无参构造、setter、getter、toString}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-序列化版本号-serialVersionUID-的作用"><a href="#2-2-序列化版本号-serialVersionUID-的作用" class="headerlink" title="2.2 序列化版本号 serialVersionUID 的作用"></a>2.2 序列化版本号 serialVersionUID 的作用</h3><ul><li>JVM 首先会通过类名来区分 Java 类，类名不同，则不是同一个类。当类名相同时，JVM 就会通过序列化版本号来区分 Java 类，如果序列化版本号相同就为同一个类，序列化版本号不同就为不同的类。</li><li>在序列化一个对象时，如果没有指定序列化版本号，后期对该类的源码进行修改并重新编译后，会导致修改前后的序列化版本号不一致，因为 JVM 会提供一个新的序列化版本号给该类对象。</li><li>此时再用以往的反序列化代码去反序列化该类的对象，就会抛出异常 java.io.InvalidClassException ，所以序列化一个类时最好指定一个序列化版本号，或者永远不修改此类。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student implements Serializable {    private static final Long serialVersionUID = 1L;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>由 JVM 提供序列化版本号的好处是，同名却不同功能的类，会有两个不同的序列化版本号，JVM 可以通过序列化版本号加以区分，缺点是一旦修改源码，会重新提供序列化版本号，导致修改前后的序列化版本号不一致，进行反序列化时会出现运行出现异常。</li><li>由 开发人员 手动提供序列化版本号的好处是，当修改了被序列化类的源码后，以往写的反序列化代码依然可以使用，如 JDK 中的 String 类。以便后期进行增强和维护不会影响使用。</li></ul><h3 id="2-3-transient-关键字"><a href="#2-3-transient-关键字" class="headerlink" title="2.3 transient 关键字"></a>2.3 transient 关键字</h3><ul><li>这个关键字表示游离的，不参与序列化的。</li><li>在序列化一个对象时，如果不希望某个属性参加序列化，可以使用 <code>transient</code> 修饰该属性。</li><li>被该关键字修饰的属性不会参与到序列化中。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Student implements Serializable {     private static final Long serialVersionUID = 1L;     private String name;    // age 字段就不会被序列化    private transient int age;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-序列化的意义与使用场"><a href="#2-4-序列化的意义与使用场" class="headerlink" title="2.4 序列化的意义与使用场"></a>2.4 序列化的意义与使用场</h3><ul><li>序列化会将内存中对象的状态转换成二进制文件保存到磁盘当中，当再次使用时会从磁盘中读取该二进制文件，将 Java 对象的状态恢复到内存中。</li><li>当你想把内存中的对象保存到磁盘文件或数据库中时可以使用序列化。</li><li>当你想在网络传输中传送 Java 对象时，可以使用序列化</li><li>当你想通过 RMI 传输对象时，可以使用序列化。</li></ul><h3 id="2-5-序列化注意事项"><a href="#2-5-序列化注意事项" class="headerlink" title="2.5 序列化注意事项"></a>2.5 序列化注意事项</h3><ul><li>序列化只会保存对象的属性状态，不会保存对象中的方法。</li><li>父类实现了 <code>Serializable </code>接口，则其子类也自动实例化了该接口，也就是说子类不用显式实现 <code>Serializable </code>接口也能参与序列化和反序列化。</li><li>一个对象 A 的实例变量引用了其他对象 B，在 A 对象实例化的过程中 ，也会序列化 B ，前提是 A、B 两个类都实现了 <code>Serializable </code>接口。</li><li>当一个类实现 <code>Serializable </code>接口时，最好手动指定一个序列化版本号(<code>serialVersionUID</code>)，避免修改源代码后导致反序列化出现异常。</li><li>当一个类对象会被多次重复使用，且一般不会对其属性做修改，就可以对其进行序列化。例如数据库操作中的实体类。</li></ul><h2 id="三、序列化的实现"><a href="#三、序列化的实现" class="headerlink" title="三、序列化的实现"></a>三、序列化的实现</h2><p>如果需要将某个对象保存到磁盘上或者通过网络传输，那么这个类应该实现<code>Serializable</code>接口或者<code>Externalizable</code>接口之一</p><h3 id="3-1-Serializable"><a href="#3-1-Serializable" class="headerlink" title="3.1 Serializable"></a>3.1 Serializable</h3><h4 id="3-1-1-普通序列化"><a href="#3-1-1-普通序列化" class="headerlink" title="3.1.1 普通序列化"></a>3.1.1 普通序列化</h4><p><code>Serializable</code> 接口是一个标记接口，不用实现任何方法，一旦实现了此接口，该类的对象就是可序列化的</p><h5 id="1-序列化步骤："><a href="#1-序列化步骤：" class="headerlink" title="1. 序列化步骤："></a>1. 序列化步骤：</h5><ol><li>创建 ObjectOutputStream 输出流</li><li>调用 ObjectOutputStream 对象的 writeObject 输出可序列化对象</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person implements Serializable {  private static final Long serialVersionUID = 1L;      private String name;  private int age;    public Person(String name, int age) {      this.name = name;      this.age = age;  }   @Override  public String toString() {      return "Person{" +              "name='" + name + '\'' +              ", age=" + age +              '}';  }} public class WriteObject {  public static void main(String[] args) {      try (          //创建一个ObjectOutputStream输出流          ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.txt"))) {          //将对象序列化到文件          Person person = new Person("zhangsan", 22);          oos.writeObject(person);      } catch (Exception e) {          e.printStackTrace();      }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>序列化后的文件结果如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305122202257.png" alt="image-20230512220158141"></p><p>可以看到，序列化后的文件中存储了 Person 实例的地址（也可以看到包名），字段信息与值。（乱码的我也不知道）</p><h5 id="2-反序列化步骤："><a href="#2-反序列化步骤：" class="headerlink" title="2. 反序列化步骤："></a>2. 反序列化步骤：</h5><ol><li>创建 ObjectInputStream 输入流</li><li>调用 ObjectInputStream 对象的 readObject() 得到序列化的对象</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person implements Serializable {  private static final Long serialVersionUID = 1L;    private String name;  private int age;  public Person(String name, int age) {      System.out.println("用来检测反序列化时是否调用构造方法");      this.name = name;      this.age = age;  }   @Override  public String toString() {      return "Person{" +              "name='" + name + '\'' +              ", age=" + age +              '}';  }} public class ReadObject {  public static void main(String[] args) {      try (          //创建一个ObjectInputStream输入流          ObjectInputStream ois = new ObjectInputStream(new FileInputStream("person.txt"))) {          Person brady = (Person) ois.readObject();          System.out.println(brady);      } catch (Exception e) {          e.printStackTrace();      }  }}//输出结果//Person{name='zhangsan', age=22}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>反序列化结果如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305122208782.png" alt="image-20230512220842738"></p><p>可以看到<strong>反序列化并不会调用类的构造方法</strong>，反序列的对象是由 JVM 自己生成的对象，不通过构造方法生成</p><h4 id="3-1-2-同一对象序列化多次的机制"><a href="#3-1-2-同一对象序列化多次的机制" class="headerlink" title="3.1.2 同一对象序列化多次的机制"></a>3.1.2 同一对象序列化多次的机制</h4><p>问题：同一个对象序列化多次，会将这个对象序列化多次吗？答案是否定的</p><p>Java 序列化同一个对象时，并不会将次对象序列化多次得到多个对象，Java 序列化算法如下：</p><ol><li>所有保存到磁盘的对象都有一个序列化编码号</li><li>当程序试图序列化一个对象时，会先检查此对象是否已经序列化过，只有此对象从未（在此虚拟机）被序列化过，才会将此对象序列化为字节序列输出。</li><li>如果此对象已经序列化过，则直接输出编号即可</li></ol><h4 id="3-1-3-Java-序列化算法潜在的问题"><a href="#3-1-3-Java-序列化算法潜在的问题" class="headerlink" title="3.1.3 Java 序列化算法潜在的问题"></a>3.1.3 Java 序列化算法潜在的问题</h4><p>由于java序利化算法不会重复序列化同一个对象，只会记录已序列化对象的编号。如果序列化一个可变对象（对象内的内容可更改）后，更改了对象内容，再次序列化，并不会再次将此对象转换为字节序列，而只是保存序列化编号。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class WriteObject {    public static void main(String[] args) {        try (            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.txt"));            ObjectInputStream ios = new ObjectInputStream(new FileInputStream("person.txt"))) {            //第一次序列化person            Person person = new Person("张三", 23);            oos.writeObject(person);            System.out.println(person);            //修改name            person.setName("李四");            System.out.println(person);            //第二次序列化person            oos.writeObject(person);            //依次反序列化出p1、p2            Person p1 = (Person) ios.readObject();            Person p2 = (Person) ios.readObject();            System.out.println(p1 == p2);            System.out.println(p1.getName().equals(p2.getName()));        } catch (Exception e) {            e.printStackTrace();        }    }}//输出结果//Person{name='张三', age=23}//Person{name='李四', age=23}//true//true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-1-4-可选的自定义序列化"><a href="#3-1-4-可选的自定义序列化" class="headerlink" title="3.1.4 可选的自定义序列化"></a>3.1.4 可选的自定义序列化</h4><h5 id="1-transient-关键字"><a href="#1-transient-关键字" class="headerlink" title="1. transient 关键字"></a>1. transient 关键字</h5><p>使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是默认值。对于引用类型，值是null；基本类型，值是0；boolean类型，值是false。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person implements Serializable {   //不需要序列化名字与年龄   private transient String name;   private transient int age;   private int height;   private transient boolean singlehood;   public Person(String name, int age) {       this.name = name;       this.age = age;   }   //省略get,set方法} public class TransientTest {   public static void main(String[] args) throws Exception {       try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.txt"));            ObjectInputStream ios = new ObjectInputStream(new FileInputStream("person.txt"))) {           Person person = new Person("9龙", 23);           person.setHeight(185);           System.out.println(person);           oos.writeObject(person);           Person p1 = (Person)ios.readObject();           System.out.println(p1);       }   }}//输出结果//Person{name='9龙', age=23', singlehood=true', height=185cm}//Person{name='null', age=0', singlehood=false', height=185cm}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-可选的自定义序列化"><a href="#2-可选的自定义序列化" class="headerlink" title="2. 可选的自定义序列化"></a>2. 可选的自定义序列化</h5><p>使用transient虽然简单，但将此属性完全隔离在了序列化之外。java提供了<strong>可选的自定义序列化。</strong>可以进行控制序列化的方式，或者对序列化数据进行编码加密等</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">private void writeObject(java.io.ObjectOutputStream out) throws IOException；private void readObject(java.io.ObjectIutputStream in) throws IOException,ClassNotFoundException;private void readObjectNoData() throws ObjectStreamException;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>通过重写<code>writeObject</code>与<code>readObject</code>方法，可以自己选择哪些属性需要序列化， 哪些属性不需要。如果writeObject使用某种规则序列化，则相应的readObject需要相反的规则反序列化，以便能正确反序列化出对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person implements Serializable {   private String name;   private int age;   //省略构造方法，get及set方法    private void writeObject(ObjectOutputStream out) throws IOException {       //将名字反转写入二进制流       out.writeObject(new StringBuffer(this.name).reverse());       out.writeInt(age);   }    private void readObject(ObjectInputStream ins) throws IOException,ClassNotFoundException{       //将读出的字符串反转恢复回来       this.name = ((StringBuffer)ins.readObject()).reverse().toString();       this.age = ins.readInt();   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当序列化流不完整时，<code>readObjectNoData()</code>方法可以用来正确地初始化反序列化的对象。例如，使用不同类接收反序列化对象，或者序列化流被篡改时，系统都会调用readObjectNoData()方法来初始化反序列化的对象。</p><h5 id="3-更彻底的自定义序列化"><a href="#3-更彻底的自定义序列化" class="headerlink" title="3. 更彻底的自定义序列化"></a>3. 更彻底的自定义序列化</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">ANY-ACCESS-MODIFIER Object writeReplace() throws ObjectStreamException;ANY-ACCESS-MODIFIER Object readResolve() throws ObjectStreamException;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><code>writeReplace</code>：在序列化时，会先调用此方法，再调用writeObject方法。此方法可将任意对象代替目标序列化对象-</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person implements Serializable {  private String name;  private int age;  //省略构造方法，get及set方法   private Object writeReplace() throws ObjectStreamException {      ArrayList&lt;Object&gt; list = new ArrayList&lt;&gt;(2);      list.add(this.name);      list.add(this.age);      return list;  }    public static void main(String[] args) throws Exception {      try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.txt"));           ObjectInputStream ios = new ObjectInputStream(new FileInputStream("person.txt"))) {          Person person = new Person("9龙", 23);          oos.writeObject(person);          ArrayList list = (ArrayList)ios.readObject();          System.out.println(list);      }  }}//输出结果//[9龙, 23]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>readResolve</code>：反序列化时替换反序列化出的对象，反序列化出来的对象被立即丢弃。此方法在readeObject后调用</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Person implements Serializable {    private String name;    private int age;    //省略构造方法，get及set方法     private Object readResolve() throws ObjectStreamException{        return new ("brady", 23);    }    public static void main(String[] args) throws Exception {        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("person.txt"));             ObjectInputStream ios = new ObjectInputStream(new FileInputStream("person.txt"))) {            Person person = new Person("9龙", 23);            oos.writeObject(person);            HashMap map = (HashMap)ios.readObject();            System.out.println(map);        }    }}//输出结果//{brady=23}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>readResolve常用来反序列单例类，保证单例类的唯一性。</p><blockquote><p>注意：readResolve与writeReplace的访问修饰符可以是private、protected、public，如果父类重写了这两个方法，子类都需要根据自身需求重写，这显然不是一个好的设计。通常建议对于final修饰的类重写readResolve方法没有问题；否则，重写readResolve使用private修饰。</p></blockquote><h3 id="3-2-Externalizable：强制自定义序列化"><a href="#3-2-Externalizable：强制自定义序列化" class="headerlink" title="3.2 Externalizable：强制自定义序列化"></a>3.2 Externalizable：强制自定义序列化</h3><p>通过实现<code>Externalizable</code>接口，必须实现<code>writeExternal</code>、<code>readExternal</code>方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Externalizable extends java.io.Serializable {     void writeExternal(ObjectOutput out) throws IOException;     void readExternal(ObjectInput in) throws IOException, ClassNotFoundException;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ExPerson implements Externalizable {     private String name;    private int age;    //注意，必须加上pulic 无参构造器    public ExPerson() {    }     public ExPerson(String name, int age) {        this.name = name;        this.age = age;    }     @Override    public void writeExternal(ObjectOutput out) throws IOException {        //将name反转后写入二进制流        StringBuffer reverse = new StringBuffer(name).reverse();        System.out.println(reverse.toString());        out.writeObject(reverse);        out.writeInt(age);    }     @Override    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {        //将读取的字符串反转后赋值给name实例变量        this.name = ((StringBuffer) in.readObject()).reverse().toString();        System.out.println(name);        this.age = in.readInt();    }     public static void main(String[] args) throws IOException, ClassNotFoundException {        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("ExPerson.txt"));             ObjectInputStream ois = new ObjectInputStream(new FileInputStream("ExPerson.txt"))) {            oos.writeObject(new ExPerson("brady", 23));            ExPerson ep = (ExPerson) ois.readObject();            System.out.println(ep);        }    }}//输出结果//ydarb//brady//ExPerson{name='brady', age=23}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>==注意：==</p><p>Externalizable接口不同于Serializable接口，实现此接口必须实现接口中的两个方法实现自定义序列化，这是强制性的；特别之处是必须提供pulic的无参构造器，因为在反序列化的时候需要反射创建对象。</p></blockquote><h3 id="2-3-两种序列化对比"><a href="#2-3-两种序列化对比" class="headerlink" title="2.3 两种序列化对比"></a>2.3 两种序列化对比</h3><table><thead><tr><th>实现Serializable接口</th><th>实现Externalizable接口</th></tr></thead><tbody><tr><td>系统自动存储必要的信息</td><td>程序员决定存储哪些信息</td></tr><tr><td>Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td><td>必须实现接口内的两个方法</td></tr><tr><td>性能略差</td><td>性能略好</td></tr></tbody></table><p>虽然Externalizable接口带来了一定的性能提升，但变成复杂度也提高了，所以一般通过实现Serializable接口进行序列化。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ详解</title>
      <link href="/tur-study/2023/05/10/MQ/RocketMQ%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/05/10/MQ/RocketMQ%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>官网：<a href="https://rocketmq.apache.org/zh/">https://rocketmq.apache.org/zh/</a></p></blockquote><h1 id="RocketMQ-极简入门"><a href="#RocketMQ-极简入门" class="headerlink" title="RocketMQ 极简入门"></a>RocketMQ 极简入门</h1><h2 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h2><p><a href="https://rocketmq.apache.org/">RocketMQ</a> 是阿里巴巴在 2012 年开源的分布式消息中间件，目前已经捐赠给 Apache 软件基金会，并于 2017 年 9 月 25 日成为  Apache  的顶级项目。作为经历过多次阿里巴巴双十一这种“超级工程”的洗礼并有稳定出色表现的国产中间件，以其高性能、低延时和高可靠等特性近年来已经也被越来越多的国内企业使用。</p><p>如下是 RocketMQ 产生的原因：</p><blockquote><p>淘宝内部的交易系统使用了淘宝自主研发的 Notify 消息中间件，使用 MySQL 作为消息存储媒介，可完全水平扩容。</p><p>为了进一步降低成本，我们认为存储部分可以进一步优化。2011 年初，Linkin 开源了 Kafka 这个优秀的消息中间件，淘宝中间件团队在对 Kafka 做过充分 Review 之后， Kafka 无限消息堆积，高效的持久化速度吸引了我们。</p><p>但是，同时发现这个消息系统主要定位于日志传输，对于使用在淘宝交易、订单、充值等场景下还有诸多特性不满足，为此我们重新用 Java 语言编写了 RocketMQ ，定位于非日志的可靠消息传输（日志场景也 OK）。</p><p>目前 RocketMQ 在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理， binglog 分发等场景。</p></blockquote><p>RocketMQ 是一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。同时，广泛应用于多个领域，包括异步通信解耦、企业解决方案、金融支付、电信、电子商务、快递物流、广告营销、社交、即时通信、移动应用、手游、视频、物联网、车联网等。</p><p>具有以下特点：</p><ul><li>能够保证严格的消息顺序</li><li>提供丰富的消息拉取模式</li><li>高效的订阅者水平扩展能力</li><li>实时的消息订阅机制</li><li>亿级消息堆积能力</li></ul><h3 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h3><ul><li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md">概念(Concept)</a>：介绍 RocketMQ 的基本概念模型。</li><li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/features.md">特性(Features)</a>：介绍 RocketMQ 实现的功能特性。</li></ul><h3 id="1-2-整体架构"><a href="#1-2-整体架构" class="headerlink" title="1.2 整体架构"></a>1.2 整体架构</h3><p><img src="/tur-study/../../../../../AppData/Roaming/Typora/typora-user-images/image-20230510203238445.png" alt="image-20230510203238445"></p><ul><li>生产（Producer）：负责产生消息，生产者相消息服务器发送由业务应用程序系统生成的消息</li><li>消费者（Consumer）：负责消费消息，消费者Con消息服务拉取信息并将其输入用户应用程序</li><li>消息服务器（Broker）：是消息存储中心，主要作用时接收来自 Producer 的消息并存储，Consumer 从这里读取消息</li><li>名称服务器（NameServer）：用来保存 Broker 相关 Topic 等元信息，并提供给 Producer、Consumer 查找 Broker 信息</li></ul><h3 id="1-3-整体流程"><a href="#1-3-整体流程" class="headerlink" title="1.3 整体流程"></a>1.3 整体流程</h3><p><img src="/tur-study/../../../../../AppData/Roaming/Typora/typora-user-images/image-20230510203808207.png" alt="image-20230510203808207"></p><ul><li><p>1、启动 <strong>Namesrv</strong>，Namesrv起 来后监听端口，等待 Broker、Producer、Consumer 连上来，相当于一个路由控制中心。</p></li><li><p>2、<strong>Broker</strong> 启动，跟所有的 Namesrv 保持长连接，定时发送心跳包。</p><blockquote><p>心跳包中，包含当前 Broker 信息(IP+端口等)以及存储所有 Topic 信息。 注册成功后，Namesrv 集群中就有 Topic 跟 Broker 的映射关系。</p></blockquote><ul><li>3、收发消息前，先创建 Topic 。创建 Topic 时，需要指定该 Topic 要存储在哪些 Broker上。也可以在发送消息时自动创建Topic。</li></ul></li><li><p>4、<strong>Producer</strong> 发送消息。</p><blockquote><p>启动时，先跟 Namesrv 集群中的其中一台建立长连接，并从Namesrv 中获取当前发送的 Topic 存在哪些 Broker 上，然后跟对应的 Broker 建立长连接，直接向 Broker 发消息。</p></blockquote></li><li><p>5、<strong>Consumer</strong> 消费消息。</p><blockquote><p>Consumer 跟 Producer 类似。跟其中一台 Namesrv 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，开始消费消息。</p></blockquote></li></ul><h2 id="二、单机部署"><a href="#二、单机部署" class="headerlink" title="二、单机部署"></a>二、单机部署</h2><blockquote><p>可以参考 <a href="https://rocketmq.apache.org/zh/docs/quickStart/01quickstart/">Apache RocketMQ —— Quick Start</a></p></blockquote><p>RocketMQ 最小化的单机环境包括一个 RocketMQ NameSrv 和 Broker 服务</p><h3 id="2-1-下载与安装"><a href="#2-1-下载与安装" class="headerlink" title="2.1 下载与安装"></a>2.1 下载与安装</h3><p>RocketMQ 所有的发布版本见 <a href="https://rocketmq.apache.org/zh/release-notes">https://rocketmq.apache.org/zh/release-notes</a></p><p>RocketMQ 的安装包分为两种，二进制包和源码包。二进制包是已经编译完成后可以直接运行的，源码包是需要编译后运行的。</p><blockquote><p>==注意：==使用源码安装 RocketMQ 时，要求系统先安装好如下软件：</p><ul><li>JDK 8+</li><li>Maven 3.2.X+</li></ul></blockquote><p>这里演示通过 Binary 版本，即二进制版本来安装 RocketMQ。在Linux Centos7 中操作</p><h4 id="2-1-1-安装步骤"><a href="#2-1-1-安装步骤" class="headerlink" title="2.1.1 安装步骤"></a>2.1.1 安装步骤</h4><ol><li>下载二进制安装包</li><li>解压安装包</li><li>进入安装目录</li></ol><h4 id="2-1-2目录介绍"><a href="#2-1-2目录介绍" class="headerlink" title="2.1.2目录介绍"></a>2.1.2目录介绍</h4><ul><li>bin：启动脚本，包括 shell 脚本和 CMD 脚本</li><li>conf：实例配置文件，包括 broker 配置文件、logback 配置文件等</li><li>lib：依赖 jar 包，包括 Netty、commons-lang、FastJSON 等</li></ul><h3 id="2-2-启动-RocketMQ"><a href="#2-2-启动-RocketMQ" class="headerlink" title="2.2 启动 RocketMQ"></a>2.2 启动 RocketMQ</h3><h4 id="2-2-1-启动-NameSrv"><a href="#2-2-1-启动-NameSrv" class="headerlink" title="2.2.1 启动 NameSrv"></a>2.2.1 启动 NameSrv</h4><p>启动一个 RocketMQ NameSrv 服务，命令行操作如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nohup sh bin/mqnamesrv &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动完成，查看日志：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 查看 Namesrv 日志。$ tail -f ~/logs/rocketmqlogs/namesrv.log# 出现如下日志则表示启动成功2023-05-03 12:58:04 INFO main - The Name Server boot success. serializeType=JSON<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下，NameSrv 日志文件的地址为 <code>~/logs/rocketmqlogs/namesrv.log</code>。如果想要自定义，可以通过 <code>conf/logback_namesrv.xml</code> 配置文件来进行修改。</p><h4 id="2-2-2-启动-Broker"><a href="#2-2-2-启动-Broker" class="headerlink" title="2.2.2 启动 Broker"></a>2.2.2 启动 Broker</h4><p>在 <code>conf</code> 目录下，RocketMQ 提供了多种 Broker 的配置文件：</p><ul><li><code>broker.conf</code> ：单主，异步刷盘。</li><li><code>2m/</code> ：双主，异步刷盘。</li><li><code>2m-2s-async/</code> ：两主两从，异步复制，异步刷盘。</li><li><code>2m-2s-sync/</code> ：两主两从，同步复制，异步刷盘。</li><li><code>dledger/</code> ：<a href="https://github.com/apache/rocketmq/blob/master/docs/cn/dledger/deploy_guide.md">Dledger 集群</a>，至少三节点。</li></ul><p>只启动一个 RocketMQ Broker 服务时，使用 <code>broker.conf</code> 配置文件。命令行操作如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">nohup sh bin/mqbroker -c conf/broker.conf  -n 127.0.0.1:9876 &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>通过 <code>-c</code> 参数，配置读取的主 Broker 配置。</p></li><li><p>通过 <code>-n</code> 参数，设置 RocketMQ Namesrv 地址</p></li><li><p>RocketMQ 默认的虚拟机内存较大，启动 Broker 如果因为内存不足失败，可以修改 <code>bin/runbroker.sh</code> 脚本，将 Broker JVM 内存调小，示例如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">JAVA_OPT="${JAVA_OPT} -server -Xms4g -Xmx4g -Xmn2g"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p>启动完成，查看日志：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">tail -f ~/logs/rocketmqlogs/broker.log2023-05-03 14:27:07 INFO main - The broker[broker-a, 192.168.3.44:10911] boot success. serializeType=JSON and name server is 127.0.0.1:9876<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-3-测试-RocketMQ"><a href="#2-3-测试-RocketMQ" class="headerlink" title="2.3 测试 RocketMQ"></a>2.3 测试 RocketMQ</h3><h4 id="2-3-1-发动消息测试"><a href="#2-3-1-发动消息测试" class="headerlink" title="2.3.1 发动消息测试"></a>2.3.1 发动消息测试</h4><p>通过使用 <code>bin/tools.sh</code> 工具类，实现测试发送消息。命令行操作如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> 设置 Namesrv 服务器的地址export NAMESRV_ADDR=127.0.0.1:9876# 执行生产者 Producer 发送测试消息sh bin/tools.sh org.apache.rocketmq.example.quickstart.Producer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果发送成功，会看到大量成功的发送日志。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SendResult [sendStatus=SEND_OK, msgId=FE800000000000004F2B5386138462F500000D7163610D67E7F100F4, offsetMsgId=C0A8032C00002A9F000000000000D7EE, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-a, queueId=0], queueOffset=61]SendResult [sendStatus=SEND_OK, msgId=FE800000000000004F2B5386138462F500000D7163610D67E7F200F5, offsetMsgId=C0A8032C00002A9F000000000000D8D1, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-a, queueId=1], queueOffset=61]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>通过发送结果为 <code>sendStatus=SEND_OK</code> 状态，说明消息都发送成功了。</li></ul><h4 id="2-3-2-测试消费消息"><a href="#2-3-2-测试消费消息" class="headerlink" title="2.3.2 测试消费消息"></a>2.3.2 测试消费消息</h4><p>通过使用 <code>bin/tools.sh</code> 工具类，实现测试消费消息。命令行操作如下：</p><pre class="line-numbers language-none"><code class="language-none"># 设置 Namesrv 服务器的地址export NAMESRV_ADDR=127.0.0.1:9876# 执行消费者 Consumer 消费测试消息sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果消费成功，会看到大量成功的消费日志。</p><pre class="line-numbers language-none"><code class="language-none">ConsumeMessageThread_4 Receive New Messages: [MessageExt [queueId=2, storeSize=227, queueOffset=131, sysFlag=0, bornTimestamp=1575354513732, bornHost=/192.168.3.44:55510, storeTimestamp=1575354513733, storeHost=/192.168.3.44:10911, msgId=C0A8032C00002A9F000000000001D1FC, commitLogOffset=119292, bodyCRC=1549304357, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message{topic='TopicTest', flag=0, properties={MIN_OFFSET=0, MAX_OFFSET=145, CONSUME_START_TIME=1575354867104, UNIQ_KEY=FE800000000000004F2B5386138462F500000D7163610D67E944020E, CLUSTER=DefaultCluster, WAIT=true, TAGS=TagA}, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 53, 50, 54], transactionId='null'}]]ConsumeMessageThread_3 Receive New Messages: [MessageExt [queueId=2, storeSize=227, queueOffset=130, sysFlag=0, bornTimestamp=1575354513729, bornHost=/192.168.3.44:55510, storeTimestamp=1575354513729, storeHost=/192.168.3.44:10911, msgId=C0A8032C00002A9F000000000001CE70, commitLogOffset=118384, bodyCRC=1530218044, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message{topic='TopicTest', flag=0, properties={MIN_OFFSET=0, MAX_OFFSET=145, CONSUME_START_TIME=1575354867103, UNIQ_KEY=FE800000000000004F2B5386138462F500000D7163610D67E941020A, CLUSTER=DefaultCluster, WAIT=true, TAGS=TagA}, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 53, 50, 50], transactionId='null'}]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>通过 <code>ConsumeMessageThread_4</code> 和 <code>ConsumeMessageThread_3</code> 线程名，我们可以看出，目前是进行并发消费消息。</li></ul><h2 id="三、集群部署"><a href="#三、集群部署" class="headerlink" title="三、集群部署"></a>三、集群部署</h2><h2 id="四、RocketMQ-Console-控制台"><a href="#四、RocketMQ-Console-控制台" class="headerlink" title="四、RocketMQ Console 控制台"></a>四、RocketMQ Console 控制台</h2><p>在 RocketMQ 拓展项目(<a href="https://github.com/apache/rocketmq-externals">rocketmq-externals</a>) 中，包含了 <a href="https://github.com/apache/rocketmq-externals/tree/master/rocketmq-console">RocketMQ Console</a> 项目，是 RocketMQ 的图形化管理控制台，提供 Broker 集群信息查看，Topic 管理，Producer、Consumer 信息展示，消息查询等等常用功能。</p><p>虽然说，我们也可以使用 RocketMQ 提供的 <a href="http://rocketmq.apache.org/docs/cli-admin-tool/">CLI Admin Tool</a> 工具，实现上述的查询与管理的功能，但是命令行的方式对操作人员的要求稍高一些。当然，在 RocketMQ Console 无法满足我们更精细化的管理的需求的时候，我们还是会使用 CLI Admin Tool 工具。</p><h3 id="4-1-克隆代码"><a href="#4-1-克隆代码" class="headerlink" title="4.1 克隆代码"></a>4.1 克隆代码</h3><p>将 <a href="https://github.com/apache/rocketmq-externals">rocketmq-externals</a> （develop分支下才有 rocketmq-console 项目）仓库的代码，克隆到本地。操作流程如下：</p><pre class="line-numbers language-none"><code class="language-none"># 克隆代码$ git clone https://github.com/apache/rocketmq-externals.git# 进入 Console 目录$ cd rocketmq-console<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-配置文件"><a href="#4-2-配置文件" class="headerlink" title="4.2 配置文件"></a>4.2 配置文件</h3><p>如果需要自定义 RocketMQ Console 的配置，可以进入该项目下的 <code>src/main/resources/</code> 目录下，进行相应的配置文件修改。例如说，设置 RocketMQ Namesrv 地址，开启 RocketMQ Console 的登录访问。</p><p>这里，我们修改 <code>src/main/resources/application.properties</code> 配置文件，通过设置 <code>rocketmq.config.namesrvAddr=127.0.0.1:9876</code> 配置项，设置 RocketMQ Namesrv 的地址。</p><h3 id="4-3-编译源码"><a href="#4-3-编译源码" class="headerlink" title="4.3 编译源码"></a>4.3 编译源码</h3><p>使用 Maven 编译 RocketMQ Console 源码。命令行操作如下：</p><pre class="line-numbers language-none"><code class="language-none"># 编译$ mvn clean package -Dmaven.test.skip=true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="4-4-启动控制台"><a href="#4-4-启动控制台" class="headerlink" title="4.4 启动控制台"></a>4.4 启动控制台</h3><p>直接以 <code>jar</code> 的方式，启动控制台。注意，控制台使用 8080 端口。命令行操作如下：</p><pre class="line-numbers language-none"><code class="language-none">nohup java -jar target/rocketmq-console-ng-1.0.1.jar &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动完成后，查看日志。</p><pre class="line-numbers language-none"><code class="language-none">$ tail -f nohup.out[2023-05-03 16:05:19.349]  INFO Tomcat started on port(s): 8080 (http)[2023-05-03 16:05:19.354]  INFO Started App in 5.341 seconds (JVM running for 6.104)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>当看到如上日志，说明 Console 控制台启动完成。</li></ul><p>浏览器访问 <code>http://localhost:8080/</code> 就可以看到控制台界面了</p><h2 id="五、简单示例"><a href="#五、简单示例" class="headerlink" title="五、简单示例"></a>五、简单示例</h2><h3 id="5-1-Producer"><a href="#5-1-Producer" class="headerlink" title="5.1 Producer"></a>5.1 Producer</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// Producer.javapublic class Producer {    public static void main(String[] args) throws MQClientException, InterruptedException {        /*         * Instantiate with a producer group name.         */        // &lt;1.1&gt; 创建 DefaultMQProducer 对象        DefaultMQProducer producer = new DefaultMQProducer("please_rename_unique_group_name");        // &lt;1.2&gt; 设置 RocketMQ Namesrv 地址        producer.setNamesrvAddr("127.0.0.1:9876");        /*         * Specify name server addresses.         * &lt;p/&gt;         *         * Alternatively, you may specify name server addresses via exporting environmental variable: NAMESRV_ADDR         * &lt;pre&gt;         * {@code         * producer.setNamesrvAddr("name-server1-ip:9876;name-server2-ip:9876");         * }         * &lt;/pre&gt;         */        /*         * Launch the instance.         */        // &lt;1.3&gt; 启动 producer 生产者        producer.start();    // 2. 使用 Producer 发送 100 条消息            for (int i = 0; i &lt; 1000; i++) {            try {                /*                 * Create a message instance, specifying topic, tag and message body.                 */                // &lt;2.1&gt; 创建 Message 消息                Message msg = new Message("TopicTest" /* Topic */,                    "TagA" /* Tag */,                    ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */                );                /*                 * Call send message to deliver message to one of brokers.                 */                // &lt;2.2&gt; 同步发送消息                SendResult sendResult = producer.send(msg);                // &lt;2.3&gt; 打印发送结果                System.out.printf("%s%n", sendResult);            } catch (Exception e) {                e.printStackTrace();                Thread.sleep(1000);            }        }        /*         * Shut down once the producer instance is not longer in use.         */        // &lt;3&gt; 关闭 producer 生产者        producer.shutdown();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>&lt;1&gt;</code></p><p> 处，初始化一个 Producer 生产者。</p><ul><li><code>&lt;1.1&gt;</code> 处，创建 DefaultMQProducer 对象，这里设置的生产者分组是 <code>"please_rename_unique_group_name"</code> 。</li><li><code>&lt;1.2&gt;</code> 处，设置 设置 <code>producer</code> 的 RocketMQ Namesrv 地址。</li><li><code>&lt;1.3&gt;</code> 处，启动 <code>producer</code> 生产者。</li></ul></li><li><p><code>&lt;2&gt;</code></p><p> 处，使用 Producer 发送 1000 条消息。</p><ul><li><code>&lt;2.1&gt;</code> 处，创建 Message 消息。这里设置了其 Topic 为 <code>"TopicTest"</code>，Tag 为 <code>TagA</code>、消息体 Body 为 <code>"Hello RocketMQ"</code> 的二进制数组。</li><li><code>&lt;2.2&gt;</code> 处，调用生产者的  <code>#send(Message msg)</code> 方法，<strong>同步</strong>发送消息，等待发送结果。RocketMQ Producer 一共有三种发送消息的方式，除了我们这里看到的同步发送消息之外，还有<strong>异步</strong>发送消息(可见 <a href="https://github.com/apache/rocketmq/blob/master/example/src/main/java/org/apache/rocketmq/example/simple/AsyncProducer.java">AsyncProducer</a> 示例)，和 <strong>Oneway</strong> 发送消息。</li><li><code>&lt;2.3&gt;</code> 处，打印发送结果。</li></ul></li><li><p><code>&lt;3&gt;</code> 处，关闭 <code>producer</code> 生产者。</p></li></ul><p>执行 <code>#main(args)</code> 方法，开始发送消息。在控制台上，可以看到如下内容：</p><pre class="line-numbers language-none"><code class="language-none"># 发送日志，省略另外 999 条日志SendResult [sendStatus=SEND_OK, msgId=240E00E0F0931BB3FCEC071C1CDE61A8000018B4AAC20E79E06A03E7, offsetMsgId=C0A82BF000002A9F000000000008EE72, messageQueue=MessageQueue [topic=TopicTest, brokerName=broker-a, queueId=0], queueOffset=645]# 关闭 Producer 日志19:27:48.339 [NettyClientSelector_1] INFO  RocketmqRemoting - closeChannel: close the connection to remote address[127.0.0.1:9876] result: true19:27:48.340 [NettyClientSelector_1] INFO  RocketmqRemoting - closeChannel: close the connection to remote address[192.168.43.240:10911] result: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-Consumer"><a href="#5-2-Consumer" class="headerlink" title="5.2 Consumer"></a>5.2 Consumer</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// Consumer.javapublic class Consumer {    public static void main(String[] args) throws InterruptedException, MQClientException {        /*         * Instantiate with specified consumer group name.         */        // &lt;1&gt; 创建 DefaultMQPushConsumer 对象        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer("please_rename_unique_group_name_4");        // &lt;2&gt; 设置 RocketMQ Namesrv 地址        consumer.setNamesrvAddr("127.0.0.1:9876");        /*         * Specify name server addresses.         * &lt;p/&gt;         *         * Alternatively, you may specify name server addresses via exporting environmental variable: NAMESRV_ADDR         * &lt;pre&gt;         * {@code         * consumer.setNamesrvAddr("name-server1-ip:9876;name-server2-ip:9876");         * }         * &lt;/pre&gt;         */        /*         * Specify where to start in case the specified consumer group is a brand new one.         */        // &lt;3&gt; 设置消费进度，从 Topic 最初位置开始        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);        /*         * Subscribe one more more topics to consume.         */        // &lt;4&gt; 订阅 TopicTest 主题        consumer.subscribe("TopicTest", "*");        /*         *  Register callback to execute on arrival of messages fetched from brokers.         */        // &lt;5&gt; 添加消息监听器        consumer.registerMessageListener(new MessageListenerConcurrently() {            @Override            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs,                ConsumeConcurrentlyContext context) {                System.out.printf("%s Receive New Messages: %s %n", Thread.currentThread().getName(), msgs);                // 返回成功                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;            }        });        /*         *  Launch the consumer instance.         */        // &lt;6&gt; 启动 producer 消费者        consumer.start();        // 打印 Consumer 启动完成        System.out.printf("Consumer Started.%n");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>&lt;1&gt;</code> 处，创建 DefaultMQPushConsumer 对象，这里设置的消费者分组是 <code>"please_rename_unique_group_name"</code> 。注意，消费者分组的概念：</p><blockquote><p>FROM <a href="https://github.com/apache/rocketmq/blob/master/docs/cn/concept.md">概念(Concept)</a></p><p>同一类 Consumer 的集合，这类 Consumer 通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。</p><p>要注意的是，消费者组的消费者实例必须订阅完全相同的 Topic 。</p><p>RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。 * 在集群消费下，同一条消息<strong>只</strong>会被<strong>相同</strong>消费者分组的<strong>一个</strong>消费者所消费。 * 在广播消费下，同一条消息会被<strong>相同</strong>消费者分组的<strong>所有</strong>消费者所消费。 * 在当前示例里，我们采用的是 DefaultMQPushConsumer 的默认消费方式，集群消费。</p></blockquote></li><li><p><code>&lt;2&gt;</code> 处，设置 <code>consumer</code> 的 RocketMQ Namesrv 地址。</p></li><li><p><code>&lt;3&gt;</code> 处，设置一个<strong>新的</strong>消费集群，初始的消费进度。目前有三个选项：</p><ul><li><code>CONSUME_FROM_FIRST_OFFSET</code> ：每个 Topic 队列的第一条消息。</li><li><code>CONSUME_FROM_LAST_OFFSET</code> ：每个 Topic 队列的最后一条消息。</li><li><code>CONSUME_FROM_TIMESTAMP</code> ：每个 Topic 队列的指定时间开始的消息。</li><li>==注意==，只针对<strong>新的</strong>消费集群。如果一个集群每个 Topic 已经有消费进度，则继续使用该消费进度。</li></ul></li><li><p><code>&lt;4&gt;</code> 处，设置订阅 <code>"TopicTest"</code> 主题的消息。有一定一定要注意！！！<strong>消费者组的消费者实例必须订阅完全相同的 Topic + Tag</strong> 。</p></li><li><p><code>&lt;5&gt;</code> 处，添加消息监听器。这里我们采用的是 <a href="https://github.com/apache/rocketmq/blob/master/client/src/main/java/org/apache/rocketmq/client/consumer/listener/MessageListenerConcurrently.java">MessageListenerConcurrently</a> <strong>并发</strong>消费消息的监听器。如果需要实现<strong>顺序</strong>消费消息，需要使用 <a href="https://github.com/apache/rocketmq/blob/master/client/src/main/java/org/apache/rocketmq/client/consumer/listener/MessageListenerOrderly.java">MessageListenerOrderly</a> <strong>顺序</strong>消费的监听器。</p></li><li><p><code>&lt;6&gt;</code> 处，启动 <code>consumer</code> 消费者。此时，Consumer 就开始正式的消费消息啦。。</p></li></ul><p>执行 <code>#main(args)</code> 方法，开始消费消息。在控制台上，可以看到如下内容：</p><pre class="line-numbers language-none"><code class="language-none"># 消费者启动成功Consumer Started.# 消费内容ConsumeMessageThread_1 Receive New Messages: [MessageExt [queueId=2, storeSize=225, queueOffset=645, sysFlag=0, bornTimestamp=1575373846053, bornHost=/192.168.43.240:52717, storeTimestamp=1575373846058, storeHost=/192.168.43.240:10911, msgId=C0A82BF000002A9F000000000008EF55, commitLogOffset=585557, bodyCRC=613185359, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message{topic='TopicTest', flag=0, properties={MIN_OFFSET=0, MAX_OFFSET=646, CONSUME_START_TIME=1575373846067, UNIQ_KEY=240E00E0F0931BB3FCEC071C1CDE61A8000018B4AAC20E8EE6250000, CLUSTER=DefaultCluster, WAIT=true, TAGS=TagA}, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 48], transactionId='null'}]]ConsumeMessageThread_2 Receive New Messages: [MessageExt [queueId=3, storeSize=225, queueOffset=645, sysFlag=0, bornTimestamp=1575373846060, bornHost=/192.168.43.240:52717, storeTimestamp=1575373846061, storeHost=/192.168.43.240:10911, msgId=C0A82BF000002A9F000000000008F036, commitLogOffset=585782, bodyCRC=1401636825, reconsumeTimes=0, preparedTransactionOffset=0, toString()=Message{topic='TopicTest', flag=0, properties={MIN_OFFSET=0, MAX_OFFSET=646, CONSUME_START_TIME=1575373846067, UNIQ_KEY=240E00E0F0931BB3FCEC071C1CDE61A8000018B4AAC20E8EE62C0001, CLUSTER=DefaultCluster, WAIT=true, TAGS=TagA}, body=[72, 101, 108, 108, 111, 32, 82, 111, 99, 107, 101, 116, 77, 81, 32, 49], transactionId='null'}]]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>通过 <code>ConsumeMessageThread_1</code> 和 <code>ConsumeMessageThread_2</code> 线程名，我们可以看出，目前是进行并发消费消息。</li></ul><hr><h1 id="Spring-Cloud-Alibaba-消息队列-RocketMQ-入门"><a href="#Spring-Cloud-Alibaba-消息队列-RocketMQ-入门" class="headerlink" title="Spring Cloud Alibaba 消息队列 RocketMQ 入门"></a>Spring Cloud Alibaba 消息队列 RocketMQ 入门</h1><p>Spring Cloud 中整合 RocketMQ 使用 Spring Cloud Alibaba 提供的 Spring Cloud Stream RocketMQ 组件，基于 Spring Cloud Stream 的编程模型，接入 RocketMQ 作为消息中间件，实现消息驱动的微服务</p><h2 id="一、Spring-Cloud-Stream-介绍"><a href="#一、Spring-Cloud-Stream-介绍" class="headerlink" title="一、Spring Cloud Stream 介绍"></a>一、Spring Cloud Stream 介绍</h2><p>Spring Cloud Stream 是一个用于构建基于<strong>消息</strong>的微服务应用框架，使用 <code>Spring Integration</code>与 <code>Broker </code>进行连接。</p><p>Spring Cloud Stream 提供了消息中间件的<strong>统一抽象</strong>，推出了<code> publish-subscribe</code>、<code>consumer groups</code>、<code>partition </code>这些统一的概念。</p><p>Spring Cloud Stream 内部有两个概念：**<code>Binder</code>** 和 **<code>Binding</code>**。</p><h3 id="1-1-Binder"><a href="#1-1-Binder" class="headerlink" title="1.1 Binder"></a>1.1 Binder</h3><p>Binder 跟消息中间件集成的组件，用来创建对应的 Binding。各种消息中间件都有自己 Binder 的具体实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Binder&lt;T,     C extends ConsumerProperties, // 消费者配置    P extends ProducerProperties&gt; { // 生产者配置        // 创建消费者的 Binding    Binding&lt;T&gt; bindConsumer(String name, String group, T inboundBindTarget, C consumerProperties);    // 创建生产者的 Binding    Binding&lt;T&gt; bindProducer(String name, T outboundBindTarget, P producerProperties);    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Kafka 实现了 <a href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka/blob/master/spring-cloud-stream-binder-kafka/src/main/java/org/springframework/cloud/stream/binder/kafka/KafkaMessageChannelBinder.java">KafkaMessageChannelBinder</a></li><li>RabbitMQ 实现了 <a href="https://github.com/spring-cloud/spring-cloud-stream-binder-rabbit/blob/master/spring-cloud-stream-binder-rabbit/src/main/java/org/springframework/cloud/stream/binder/rabbit/RabbitMessageChannelBinder.java">RabbitMessageChannelBinder</a></li><li>RocketMQ 实现了 <a href="https://github.com/alibaba/spring-cloud-alibaba/blob/master/spring-cloud-stream-binder-rocketmq/src/main/java/com/alibaba/cloud/stream/binder/rocketmq/RocketMQMessageChannelBinder.java">RocketMQMessageChannelBinder</a></li></ul><h3 id="1-2-Binding"><a href="#1-2-Binding" class="headerlink" title="1.2 Binding"></a>1.2 Binding</h3><p>包括 <code>Input Binding</code> 和 <code>Output Binding</code>。Binding 在消息中间件与应用程序提供的 Provider 和  Consumer 之间提供了一个桥梁，实现了开发者只需使用应用程序的 Provider 或 Consumer  生产或消费数据即可，屏蔽了开发者与底层消息中间件的接触。</p><p>最终整体交互如下图所示：</p><p><img src="/tur-study/../../../../../AppData/Roaming/Typora/typora-user-images/image-20230510224642530.png" alt="image-20230510224642530"></p><h2 id="二、快速入门"><a href="#二、快速入门" class="headerlink" title="二、快速入门"></a>二、快速入门</h2><hr><h1 id="Spring-Cloud-Bus-RocketMQ-入门"><a href="#Spring-Cloud-Bus-RocketMQ-入门" class="headerlink" title="Spring Cloud Bus RocketMQ 入门"></a>Spring Cloud Bus RocketMQ 入门</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Spring Cloud Bus 是<strong>事件、消息总线</strong>，用于在集群（例如，配置变化事件）中传播状态变化，可与 Spring Cloud Config 联合实现热部署。</p><p>Spring 内置了事件机制，可以实现 <strong>JVM 进程内</strong>的事件发布与监听。但是如果想要<strong>跨 JVM 进程</strong>的事件发布与监听，此时它就无法满足我们的诉求了</p><p>因此，Spring Cloud Bus 在 Spring 事件机制的基础之上进行<strong>拓展</strong>，结合 RabbitMQ、Kafka、RocketMQ 等等消息队列作为事件的<strong>“传输器”</strong>，通过发送事件（消息）到消息队列上，从而广播到订阅该事件（消息）的所有节点上。最终如下图所示：</p><p><img src="/tur-study/../../../../../AppData/Roaming/Typora/typora-user-images/image-20230511083927660.png" alt="image-20230511083927660"></p><p>Spring Cloud Bus 定义了 <a href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/event/RemoteApplicationEvent.java">RemoteApplicationEvent</a> 类，远程的 ApplicationEvent 的抽象基类。核心代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, property = "type")@JsonIgnoreProperties("source") // &lt;2&gt;public abstract class RemoteApplicationEvent extends ApplicationEvent { // &lt;1&gt;private final String originService;private final String destinationService;private final String id;// ... 省略一大撮代码}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>显然，我们使用 Spring Cloud Bus 发送的自定义事件，必须要<strong>继承</strong> RemoteApplicationEvent 类。</p><ul><li><p><code>&lt;1&gt;</code> 处，继承 Spring 事件机制定义的 <a href="https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/ApplicationEvent.java">ApplicationEvent</a> 抽象基类。</p></li><li><p><code>&lt;2&gt;</code> 处，通过 Jackson 的 <code>@JsonIgnoreProperties</code> 注解，设置忽略继承自 ApplicationEvent 的 <code>source</code> 属性，避免序列化问题。</p></li><li><p><code>id</code> 属性，事件编号。一般情况下，RemoteApplicationEvent 会使用 <code>UUID.randomUUID().toString()</code> 代码，自动生成 UUID 即可。</p></li><li><p><code>originService</code> 属性，来源服务。Spring Cloud Bus 提供好了 <a href="https://github.com/spring-cloud/spring-cloud-bus/blob/master/spring-cloud-bus/src/main/java/org/springframework/cloud/bus/ServiceMatcher.java"><code>ServiceMatcher#getServiceId()</code></a> 方法，获取服务编号作为 <code>originService</code> 属性的值。</p><blockquote><p>友情提示：这个属性非常关键</p></blockquote></li><li><p><code>destinationService</code> 属性，目标服务。该属性的格式是 <code>{服务名}:{服务实例编号}</code>。</p><blockquote><p>举个板栗：</p><ul><li>如果想要广播给所有服务的所有实例，则设置为 <code>**:**</code>。</li><li>如果想要广播给 <code>users</code> 服务的所有实例，则设置为 <code>users:**</code>。</li><li>如如果想要广播给 <code>users</code> 服务的指定实例，则设置为 <code>users:bc6d27d7-dc0f-4386-81fc-0b3363263a15</code>。</li></ul></blockquote></li></ul><h2 id="二、快速入门-1"><a href="#二、快速入门-1" class="headerlink" title="二、快速入门"></a>二、快速入门</h2>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo 详解</title>
      <link href="/tur-study/2023/05/08/SpringCloud/Dubbo%20%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/05/08/SpringCloud/Dubbo%20%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-架构演进"><a href="#1-架构演进" class="headerlink" title="1. 架构演进"></a>1. 架构演进</h2><p>![image-20221127164204041](../../../../编程学习笔记/Java中间键&amp;服务框架/分布式开发框架/分布式开发框架 Dubbo.assets/image-20221127164204041.png)</p><h3 id="1-1-单体架构"><a href="#1-1-单体架构" class="headerlink" title="1.1 单体架构"></a>1.1 单体架构</h3><p>![image-20221127164311844](../../../../编程学习笔记/Java中间键&amp;服务框架/分布式开发框架/分布式开发框架 Dubbo.assets/image-20221127164311844.png)</p><h5 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h5><ul><li>简单：开发部署都很方便，小型项目首选</li></ul><h5 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h5><ul><li>项目启动慢</li><li>可靠性差</li><li>可伸缩性差</li><li>扩展性和可维护性差</li><li>性能低</li></ul><h3 id="1-2-垂直架构"><a href="#1-2-垂直架构" class="headerlink" title="1.2 垂直架构"></a>1.2 垂直架构</h3><p>![image-20221127164632920](../../../../编程学习笔记/Java中间键&amp;服务框架/分布式开发框架/分布式开发框架 Dubbo.assets/image-20221127164632920.png)</p><p>垂直架构是将单体架构中的多个模块拆分为多个独立的项目，形成多个独立的单体架构</p><p>垂直架构存在的问题：</p><ul><li>重复功能太多</li></ul><h3 id="1-3-分布式架构"><a href="#1-3-分布式架构" class="headerlink" title="1.3 分布式架构"></a>1.3 分布式架构</h3><p>![image-20221127164919197](../../../../编程学习笔记/Java中间键&amp;服务框架/分布式开发框架/分布式开发框架 Dubbo.assets/image-20221127164919197.png)</p><p>分布式架构：在垂直架构的基础上，将公共业务模块提取出来，作为独立的服务供其他调用者消费，以实现服务的共享和重用</p><p><code>RPC</code>：Remote Procedure Call 远程过程调用。有非常多的协议和技术来都实现了RPC的过程。比如：HTTP REST风格，Java RMI规范、WebService SOAP协议、Hession等等</p><p>分布式架构存在的问题：</p><ul><li>服务提供方一旦产生变更，所有消费方都需要变更</li></ul><h3 id="1-4-SOA-架构"><a href="#1-4-SOA-架构" class="headerlink" title="1.4 SOA 架构"></a>1.4 SOA 架构</h3><p>![image-20221127165848506](../../../../编程学习笔记/Java中间键&amp;服务框架/分布式开发框架/分布式开发框架 Dubbo.assets/image-20221127165848506.png)</p><ul><li><p>SOA（Service-Oriented Architecture，面向服务的架构）是一个组件模型，将应用程序的不同功能那个单元（服务）进行拆分，并通过这些服务之间定义良好的接口和契约联系起来</p></li><li><p>ESB（Enterparise Service Bus，企业服务总线），服务中介，主要提供了一个服务与服务之间的交互</p><p>ESB 包含的功能如：负载均衡、流量控制、加密处理、服务监控、异常处理、监控告急等</p></li></ul><h3 id="1-5-微服务架构"><a href="#1-5-微服务架构" class="headerlink" title="1.5 微服务架构"></a>1.5 微服务架构</h3><p>![image-20221127183302621](../../../../编程学习笔记/Java中间键&amp;服务框架/分布式开发框架/分布式开发框架 Dubbo.assets/image-20221127183302621.png)</p><p>微服务架构是在 SOA 上的升华，微服务架构强调的一个重点是“业务需要彻底的组件化和服务化”，原有的单个业务系统会拆分为多个可以独立开发、设计、运行的小应用，这些小应用之间通过服务完成交互和集成</p><p>微服务架构 = 80%的SOA服务架构思想 + 100%的组件化架构思想 + 80%的领域建模思想</p><p>特点</p><ul><li>服务实现组件化：开发者可以自由选择开发技术，也不需要协调其他团队</li><li>服务之间交互一般使用 REST API</li><li>去中心化：每个微服务有自己私有的数据库持久化业务数据</li><li>自动化部署：把应用拆分为一个一个独立的单个服务，方便自动化部署、测试、运维</li></ul><blockquote><ul><li>Dubbo 是 SOA 时代的产物</li><li>SpringCloud 是微服务时代的产物</li></ul></blockquote><h2 id="2-Dubbo-概述"><a href="#2-Dubbo-概述" class="headerlink" title="2. Dubbo 概述"></a>2. Dubbo 概述</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p><code>Dubbo</code>是阿里巴巴开源的基于 Java 的高性能<code>RPC</code>（一种远程调用） 分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及<code>SOA</code>服务治理方案。</p><p>每天为2千多个服务提供大于30亿次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点以及别的公司的业务中。</p><p>简单的说，Dubbo就是个服务框架，如果没有分布式的需求，其实是不需要用的，只有在分布式的时候，才有Dubbo这样的分布式服务框架的需求。</p><p>并且本质上是个远程服务调用的分布式框架（告别<code>Web Service</code>模式中的<code>WSdl</code>，以服务者与消费者的方式在Dubbo上注册）</p><p>其核心部分包含：</p><ol><li><strong>远程通讯</strong>：提供对多种基于长连接的<code>NIO</code>框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。</li><li><strong>集群容错</strong>：提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li><strong>自动发现</strong>：基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器</li></ol><h3 id="2-2-RPC-简介"><a href="#2-2-RPC-简介" class="headerlink" title="2.2 RPC 简介"></a>2.2 RPC 简介</h3><p><code>RPC</code>(Remote Procedure Call Protocol)：远程过程调用</p><p>两台服务器A、B，分别部署不同的应用a,b。当A服务器想要调用B服务器上应用b提供的函数或方法的时候，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义传达调用的数据。<br>说白了，就是你在你的机器上写了一个程序，我这边是无法直接调用的，这个时候就出现了一个远程服务调用的概念。</p><p>RPC是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。<br>RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p><h3 id="2-3-RPC-需要解决的问题"><a href="#2-3-RPC-需要解决的问题" class="headerlink" title="2.3 RPC 需要解决的问题"></a>2.3 RPC 需要解决的问题</h3><h4 id="2-3-1-通讯问题"><a href="#2-3-1-通讯问题" class="headerlink" title="2.3.1 通讯问题"></a>2.3.1 通讯问题</h4><p>通讯问题：主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</p><h4 id="2-3-2-寻址问题"><a href="#2-3-2-寻址问题" class="headerlink" title="2.3.2 寻址问题"></a>2.3.2 寻址问题</h4><p>寻址问题：A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。</p><h4 id="2-3-3-序列化与反序列化"><a href="#2-3-3-序列化与反序列化" class="headerlink" title="2.3.3 序列化与反序列化"></a>2.3.3 序列化与反序列化</h4><p>序列化 与 反序列化：当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。<br>同理，B服务器接收参数要将参数反序列化。B服务器应用调用自己的方法处理后返回的结果也要序列化给A服务器，A服务器接收也要经过反序列化的过程。</p><h3 id="2-3-Dubbo作用"><a href="#2-3-Dubbo作用" class="headerlink" title="2.3 Dubbo作用"></a>2.3 Dubbo作用</h3><h4 id="2-3-1-为什么使用-Dubbo"><a href="#2-3-1-为什么使用-Dubbo" class="headerlink" title="2.3.1 为什么使用 Dubbo"></a>2.3.1 为什么使用 Dubbo</h4><p>因为是阿里开源项目，国内很多互联网公司都在用，已经经过很多线上考验。内部使用了Netty、Zookeeper，保证了高性能高可用性。</p><ul><li>使用Dubbo可以将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，可用于提高业务复用灵活扩展，使前端应用能更快速的响应多变的市场需求。</li><li>分布式架构可以承受更大规模的并发流量</li></ul><h4 id="2-3-2-Dubbo-能做什么"><a href="#2-3-2-Dubbo-能做什么" class="headerlink" title="2.3.2 Dubbo 能做什么"></a>2.3.2 Dubbo 能做什么</h4><ol><li>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。</li><li>软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。</li><li>服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。</li></ol><p>Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。</p><h3 id="2-4-Dubbo-与-Spring-Cloud-区别"><a href="#2-4-Dubbo-与-Spring-Cloud-区别" class="headerlink" title="2.4 Dubbo 与 Spring Cloud 区别"></a>2.4 Dubbo 与 Spring Cloud 区别</h3><ol><li>通信方式不同：Dubbo 使用的是 RPC 通信，而Spring Cloud 使用的是HTTP RESTFul方式。</li><li>组成不一样：<ul><li>dubbo的服务注册中心为Zookeerper，服务监控中心为dubbo-monitor，无消息总线、服务跟踪、批量任务等组件；</li><li>Spring Cloud的服务注册中心为spring-cloud netflix enruka，服务监控中心为spring-boot admin，有消息总线、数据流、服务跟踪、批量任务等组件；</li></ul></li></ol><h2 id="3-Dubbo-架构"><a href="#3-Dubbo-架构" class="headerlink" title="3. Dubbo 架构"></a>3. Dubbo 架构</h2><p>![image-20221206095523653](../../../../编程学习笔记/Java中间键&amp;服务框架/分布式开发框架/分布式开发框架 Dubbo.assets/image-20221206095523653.png)</p><h3 id="3-1-节点角色说明"><a href="#3-1-节点角色说明" class="headerlink" title="3.1 节点角色说明"></a>3.1 节点角色说明</h3><ul><li>Provider：暴露服务的服务提供方</li><li>Container：服务运行容器</li><li>Consumer：调用远程服务的服务消费方</li><li>Registry：服务注册与发现中心</li><li>Monitor：统计服务的调用次数和调用时间的监控中心</li></ul><h3 id="3-2-调用关系"><a href="#3-2-调用关系" class="headerlink" title="3.2 调用关系"></a>3.2 调用关系</h3><ol><li>服务容器负责启动、加载、运行服务提供者</li><li>服务提供者在启动时，向注册中心注册自己提供的服务</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</li><li>服务消费者从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果提哦阿勇失败，再选另一台调用</li><li>服务消费者和提供者在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心</li></ol><p>那么，整个发布-订阅的过程就非常的简单了：</p><ol><li>启动容器，加载，运行服务提供者。</li><li>服务提供者在启动时，在注册中心发布注册自己提供的服务。</li><li>服务消费者在启动时，在注册中心订阅自己所需的服务。</li></ol><p>如果考虑失败或变更的情况，就需要考虑下面的过程：</p><ol><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ol><h2 id="4-Dubbo-入门案例"><a href="#4-Dubbo-入门案例" class="headerlink" title="4. Dubbo 入门案例"></a>4. Dubbo 入门案例</h2>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lombok 详解</title>
      <link href="/tur-study/2023/05/07/SpringBoot/Lombok%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/05/07/SpringBoot/Lombok%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Lombok-简介"><a href="#一、Lombok-简介" class="headerlink" title="一、Lombok 简介"></a>一、Lombok 简介</h2><blockquote><p>lombok 官网：<a href="https://projectlombok.org/">https://projectlombok.org/</a></p></blockquote><p>官方说明：<br>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p><p>Project Lombok是一个java库，它可以自动插入到您的编辑器和构建工具中，为您的java增添趣味。<br>永远不要再写另一个getter或equals方法了，只要有一个注释，你的类就有了一个功能齐全的构建器，自动化你的日志变量，等等。</p><p>Lombok简单理解就是一个Java类库，通过注解的形式帮助开发减少一些结构化代码的开发工作，提高开发效率，比如通过@Data注解，class在编译的时候会自动生成get，set，equals，hash，toString等方法，避免写大量的代码，减少了代码量，也使代码看起来更加简洁。尤其是一些对象属性需要改动的时候，每次改动都需要重新生成get，set，equals，hash，toString等方法，而使用注解则可以避免此问题。</p><h2 id="二、Lombok-的使用说明"><a href="#二、Lombok-的使用说明" class="headerlink" title="二、Lombok 的使用说明"></a>二、Lombok 的使用说明</h2><p>如果要使用 lombok，需要在开发工具中安装插件 lombok，其次在项目中引入依赖</p><h2 id="三、Lombok-的使用"><a href="#三、Lombok-的使用" class="headerlink" title="三、Lombok 的使用"></a>三、Lombok 的使用</h2><blockquote><p>lombok 官方 api 文档：<a href="https://projectlombok.org/api/">https://projectlombok.org/api/</a></p></blockquote><h3 id="3-1-NonNull"><a href="#3-1-NonNull" class="headerlink" title="3.1 @NonNull"></a>3.1 @NonNull</h3><p><code>@NonNull</code> 注解使用在<strong>属性或构造器</strong>上，lombok 会生成一个非空的声明，可用于校验参数，能够帮助避免空指针</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 1.@NonNull该注解用在属性或构造器上，Lombok会生成一个非空的声明，可用于校验参数，能帮助避免空指针。 * 参数User为null时产生异常：NullPointerException */public static String getName(@NonNull User user) {    return user.getName();}/** * 等价@NonNull */public static String getName2(User user) {    if (user == null) {throw new NullPointerException("user is marked non-null but is null");}    return user.getName();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-Getter-和-Setter"><a href="#3-2-Getter-和-Setter" class="headerlink" title="3.2 @Getter 和 @Setter"></a>3.2 @Getter 和 @Setter</h3><p><code>@Getter</code> 和<code>@Setter</code> 注解在<strong>类或字段</strong>，注解在类时为所有字段生成getter，setter方法，注解在字段上时只为该字段生成getter，setter方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@ToString(exclude = {"phone"})public class Student {    @Getter    @Setter    private String name;    /**     * 只生成set方法，且作用范围 修饰符PROTECTED     */    @Setter(AccessLevel.PROTECTED)    private int age;    /**     * 只生成get方法，且作用范围 修饰符PUBLIC     */    @Getter(AccessLevel.PUBLIC)    private String address;    @Getter    @Setter    private String phone;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-Cleanup"><a href="#3-3-Cleanup" class="headerlink" title="3.3 @Cleanup"></a>3.3 @Cleanup</h3><p><code>@Cleanup</code>这个注解用在<strong>变量前面</strong>，可以保证此变量代表的资源会被自动关闭，默认是调用资源的close()方法，如果该资源有其它关闭方法，可使用<code>@Cleanup(“methodName”)</code>来指定要调用的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) throws IOException {     @Cleanup      InputStream in = new FileInputStream(args[0]);     @Cleanup      OutputStream out = new FileOutputStream(args[1]);     byte[] b = new byte[1024];     while (true) {       int r = in.read(b);       if (r == -1) break;       out.write(b, 0, r);     } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-ToString"><a href="#3-4-ToString" class="headerlink" title="3.4 @ToString"></a>3.4 @ToString</h3><p><code>@ToString</code> 注解在类，添加toString方法。@ToString在JavaBean或类JavaBean中使用，使用此注解会自动重写对应的toStirng方法，默认情况下，会输出类名、所有属性（会按照属性定义顺序），用逗号来分割，通过callSuper参数来指定是否引用父类，<code>includeFieldNames</code>参数设为true，就能明确的输出toString()属性</p><pre class="line-numbers language-none"><code class="language-none">@ToString(exclude=”column”)意义：排除column列所对应的元素，即在生成toString方法时不包含column参数；@ToString(exclude={“column1″,”column2″})意义：排除多个column列所对应的元素，其中间用英文状态下的逗号进行分割，即在生成toString方法时不包含多个column参数；@ToString(of=”column”)意义：只生成包含column列所对应的元素的参数的toString方法，即在生成toString方法时只包含column参数；；@ToString(of={“column1″,”column2”})意义：只生成包含多个column列所对应的元素的参数的toString方法，其中间用英文状态下的逗号进行分割，即在生成toString方法时只包含多个column参数；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-EqualsAndHashCode"><a href="#3-5-EqualsAndHashCode" class="headerlink" title="3.5 @EqualsAndHashCode"></a>3.5 @EqualsAndHashCode</h3><p><code>@EqualsAndHashCode</code> 注解在类，生成hashCode和equals方法。@EqualsAndHashCode默认情况下，会使用所有非静态（non-static）和非瞬态（non-transient）属性来生成equals和hasCode，也能通过<code>exclude</code>注解来排除一些属性</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@EqualsAndHashCode(exclude={"id", "shape"})public class EqualsAndHashCodeExample {  private transient int transientVar = 10;  private String name;  private double score;  private Shape shape = new Square(5, 10);  private String[] tags;  private int id;    public String getName() {    return this.name;  }    @EqualsAndHashCode(callSuper=true)  public static class Square extends Shape {    private final int width, height;        public Square(int width, int height) {      this.width = width;      this.height = height;    }  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-NoArgsConstructor、-RequiredArgsConstructor和-AllArgsConstructor"><a href="#3-6-NoArgsConstructor、-RequiredArgsConstructor和-AllArgsConstructor" class="headerlink" title="3.6 @NoArgsConstructor、@RequiredArgsConstructor和@AllArgsConstructor"></a>3.6 @NoArgsConstructor、@RequiredArgsConstructor和@AllArgsConstructor</h3><p>这三个注解都是用在类上的，</p><ul><li>NoArgsConstructor 注解在类生成无参的构造方法。</li><li>@RequiredArgsConstructor 注解在类，为类中需要特殊处理的字段生成构造方法，比如final和被@NonNull注解的字段。</li><li>@AllArgsConstructor 注解在类，生成包含类中所有字段的构造方法。</li></ul><p>三个注解都可以指定生成的构造方法的访问权限，同时，第二个注解还可以用<code>@RequiredArgsConstructor(staticName=”methodName”)</code>的形式生成一个指定名称的静态方法，返回一个调用相应的构造方法产生的对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RequiredArgsConstructor(staticName = "myShape")@AllArgsConstructor(access = AccessLevel.PROTECTED)@NoArgsConstructorpublic class Shape {    private int x;    @NonNull    private double y;    @NonNull    private String name;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-7-Data"><a href="#3-7-Data" class="headerlink" title="3.7 @Data"></a>3.7 @Data</h3><p><code>@Data</code> 注解在类，生成setter/getter、equals、canEqual、hashCode、toString方法，如为final属性，则不会为该属性生成setter方法。</p><p>特别注意：Lombok的@Data注解生成的EqualsAndHashCode默认不支持父类在使用Lombok过程中，如果对于各种注解的底层原理不理解的话，很容易产生意想不到的结果。举一个简单的例子：我们知道，当我们使用@Data定义一个类的时候，会自动帮我们生成equals()方法 。但是如果只使用了@Data，而不使用@EqualsAndHashCode(callSuper=true)的话，会默认是@EqualsAndHashCode(callSuper=false)，这时候生成的equals()方法只会比较子类的属性，不会考虑从父类继承的属性，无论父类属性访问权限是否开放，这就可能得到意想不到的结果。以下是测试验证。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@NoArgsConstructor@AllArgsConstructorpublic class User {    private String name;}@Datapublic class UserCustomer extends User {    private String customerId;}@Data@EqualsAndHashCode(callSuper = true)public class UserEmployee extends User{    private String empId;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LombokDataTest {    public static void main(String[] args) {        //1.@Data默认@EqualsAndHashCode(callSuper = false)        compareUserCustomerWithCallSuperFalse();        System.out.println("--------------------------------");        //2.@Data指定@EqualsAndHashCode(callSuper = true)        compareUserEmployeeWithCallSuperFalse();    }    /**     * 2.@Data指定@EqualsAndHashCode(callSuper = true)     */    private static void compareUserEmployeeWithCallSuperFalse() {        UserEmployee userEmployee = new UserEmployee();        userEmployee.setName("jerry");        userEmployee.setEmpId("123");        UserEmployee userEmployee2 = new UserEmployee();        userEmployee2.setName("jerry");        userEmployee2.setEmpId("123456");        UserEmployee userEmployee3 = new UserEmployee();        userEmployee3.setName("jerry2");        userEmployee3.setEmpId("123");        //false，父类中的Name相同，子类中的EmpId不同，可以校验出来        System.out.println("【userEmployee】：" + userEmployee.toString());        System.out.println("【userEmployee2】：" + userEmployee2.toString());        System.out.println("【userEmployee3】：" + userEmployee3.toString());        System.out.println("【userEmployee &amp; userEmployee2】：" + userEmployee.equals(userEmployee2));        //false，父类中的Name不同，子类中的EmpId相同，可以校验出来        System.out.println("【userEmployee &amp; userEmployee3】：" + userEmployee.equals(userEmployee3));    }    /**     * 1.@Data默认@EqualsAndHashCode(callSuper = false)     */    private static void compareUserCustomerWithCallSuperFalse() {        UserCustomer userCustomer = new UserCustomer();        userCustomer.setName("jerry");        userCustomer.setCustomerId("123");        UserCustomer userCustomer2 = new UserCustomer();        userCustomer2.setName("jerry");        userCustomer2.setCustomerId("123456");        UserCustomer userCustomer3 = new UserCustomer();        userCustomer3.setName("jerry2");        userCustomer3.setCustomerId("123");        System.out.println("【userCustomer】：" + userCustomer.toString());        System.out.println("【userCustomer2】：" + userCustomer2.toString());        System.out.println("【userCustomer3】：" + userCustomer3.toString());        //false，父类中的Name相同，子类中的customerId不同，可以校验出来        System.out.println("【userCustomer &amp; userCustomer2】：" + userCustomer.equals(userCustomer2));        //true，父类中的Name不同，子类中的customerId相同，无法校验出来        System.out.println("【userCustomer &amp; userCustomer3】：" + userCustomer.equals(userCustomer3));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-8-SneakyThrows"><a href="#3-8-SneakyThrows" class="headerlink" title="3.8 @SneakyThrows"></a>3.8 @SneakyThrows</h3><p><code>@SneakyThrows</code>这个注解用在方法上，可以将方法中的代码用try-catch语句包裹起来，捕获异常并在catch中用Lombok.sneakyThrow(e)把异常抛出，可以使用.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SneakyThrows implements Runnable {    @SneakyThrows(UnsupportedEncodingException.class)    public String utf8ToString(byte[] bytes) {        return new String(bytes, "UTF-8");    }     @SneakyThrows    public void run() {        throw new Throwable();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-9-Synchronized"><a href="#3-9-Synchronized" class="headerlink" title="3.9 @Synchronized"></a>3.9 @Synchronized</h3><p><code>@Synchronized</code>这个注解用在类方法或者实例方法上，效果和synchronized关键字相同，区别在于锁对象不同，对于类方法和实例方法，synchronized关键字的锁对象分别是类的class对象和this对象，而@Synchronized得锁对象分别是私有静态final对象LOCK和私有final对象lock，当然，也可以自己指定锁对象</p><h3 id="3-10-Slf4j"><a href="#3-10-Slf4j" class="headerlink" title="3.10 @Slf4j"></a>3.10 @Slf4j</h3><p>@Slf4j 注解在类，生成log变量，严格意义来说是常量。private static final Logger log = LoggerFactory.getLogger(UserController.class);</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-Plus 注解</title>
      <link href="/tur-study/2023/05/06/MybatisPlus/Mybatis-Plus%20%E6%B3%A8%E8%A7%A3/"/>
      <url>/tur-study/2023/05/06/MybatisPlus/Mybatis-Plus%20%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="TableField"><a href="#TableField" class="headerlink" title="@TableField"></a>@TableField</h2><p><strong>描述：字段注解，非主键</strong></p><table><thead><tr><th align="left">属性</th><th align="left">类型</th><th align="left">必须指定</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">value</td><td align="left">String</td><td align="left">否</td><td align="left">“”</td><td align="left">数据库字段名</td></tr><tr><td align="left">exist</td><td align="left">boolean</td><td align="left">否</td><td align="left">true</td><td align="left">是否为数据库表字段</td></tr><tr><td align="left">condition</td><td align="left">String</td><td align="left">否</td><td align="left">“”</td><td align="left">字段 <code>where</code> 实体查询比较条件，有值设置则按设置的值为准，没有则为默认全局的 `%s=#</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Mybatis-Plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis-Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mapstruct 的使用</title>
      <link href="/tur-study/2023/05/05/SpringBoot/mapstruct%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/05/05/SpringBoot/mapstruct%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mapstruct 是一个 Java 注释处理器，用于生成类型安全的 bean 映射类。 </p><p>使用 MapStruct 要做的仅仅是：</p><ul><li>定义一个映射器接口</li><li>在该接口声明任何必需的映射方法</li></ul><p>在编译期间，Mapstruct 将生成此接口的实现，此实现使用简单的 Java 方法调用源对象和目标对象之间进行映射，既没有反射或类似内容。与手动编写映射代码相比，Mapstruct 通过生成繁琐且易于出错的代码来节省时间，遵循配置方法上的约定，Mapstruct 使用合理的默认值，但在配置或实现特殊行为时不加理会</p><p>与动态映射框架相比，Mapstruct 具有以下优点：</p><ul><li>通过使用普通方法调用（setter、getter）而不是泛着来快速执行</li><li>编译时类型安全性：只能映射相互映射的对象和属性，不能将 entity 实体类 意外映射到 suctomer DTO 等</li><li>如果有以下问题，编译时会抛出异常<ul><li>映射不完整，即并非所有目标属性都被映射</li><li>映射不正确，即找不到正确的映射方法或类型转换</li></ul></li><li>可以通过 freemarker 定制化开发</li></ul><p>下面是 Mapstruct 的使用步骤</p><h2 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h2><p>Mapstruct 是基于 JSR269 的 Java 注释处理器，因此可以在命令行构建（javac、Ant、Maven等）以及IDE中使用</p><p>Mapstruct 包含以下工件：</p><ol><li><code>org.mapstruct:mapstruct</code>：包含必需的注释，例如：<code>@Mapping</code></li><li><code>org.mapstruct:mapstruct-processor</code>:包含注释处理器，该注释处理器生成映射器实现</li></ol><blockquote><p>注：以下步骤均在Maven项目中进行</p></blockquote><h4 id="1-mapstruct-依赖："><a href="#1-mapstruct-依赖：" class="headerlink" title="1. mapstruct 依赖："></a>1. mapstruct 依赖：</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- mapstruct 高性能对象映射--&gt;</span>                         <span class="token comment">&lt;!-- mapstruct 核心 --&gt;</span>                             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>                                          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.mapstruct<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mapstruct<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${mapstruct.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>                                     <span class="token comment">&lt;!-- mapstruct 编译 --&gt;</span>                             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>                                          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.mapstruct<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mapstruct-processor<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>${mapstruct.version}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>                                     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-lombok-依赖"><a href="#2-lombok-依赖" class="headerlink" title="2. lombok 依赖"></a>2. lombok 依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- lombok --&gt;</span>                          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>                                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.projectlombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lombok<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>                            <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-下载插件"><a href="#3-下载插件" class="headerlink" title="3. 下载插件"></a>3. 下载插件</h4><blockquote><p>插件不是必需的，但很好用</p></blockquote><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305052022590.png" alt="image-20230505201732634"></p><p>插件使用：在参数上， <code>Ctrl+鼠标左键</code> 能够进入参数所在类的文件</p><h2 id="2-映射器定义"><a href="#2-映射器定义" class="headerlink" title="2. 映射器定义"></a>2. 映射器定义</h2><h3 id="2-1-基本映射"><a href="#2-1-基本映射" class="headerlink" title="2.1 基本映射"></a>2.1 基本映射</h3><p>要创建映射器，主要使用所需的映射方法定义一个 Java 接口，并用注解 <code>@Mapper</code> 对其标注，Mapstruct 代码生成器便会自动对该接口进行映射。</p><p>在生成的方法实现中，源类型的所有可读属性都将被复制到目标类型的响应属性中：</p><ol><li>当一个属性与其目标实体对应的名称相同时，它将被隐式映射</li><li>当属性在目标实体中具有不同的名称时，可以通过 <code>@Mapping</code> 注解指定其名称</li></ol><blockquote><p>==注意：==</p><ul><li>如果不指定 <code>@Mapping</code> ，则默认映射name相同的field</li><li>如果映射的对象 field name 不一样，通过 <code>@Mapping</code> 置顶</li><li>忽略字段加 <code>@Mapping#ignore = true</code></li></ul></blockquote><p>示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Person {    String describe;    private String id;    private String name;    private int age;    private BigDecimal source;    private double height;    private Date createTime;}@Datapublic class PersonDTO {    String describe;    private Long id;    private String personName;    private String age;    private String source;    private String height;    }// mapper@Mapperpublic interface PersonMapper {    PersonMapper INSTANCT = Mappers.getMapper(PersonMapper.class);@Mapping(target = "name", source = "personName")@Mapping(target = "id", ignore = true) // 忽略id，不进行映射    PersonDTO conver(Person person);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>生成的实现类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> public class PersonMapperImpl implements PersonMapper {    public PersonMapperImpl() {    }    public PersonDTO conver(Person person) {        if (person == null) {            return null;        } else {            PersonDTO personDTO = new PersonDTO();            personDTO.setDescribe(person.getDescribe());            if (person.getId() != null) {                personDTO.setId(Long.parseLong(person.getId()));            }            personDTO.setPersonName(person.getName());            personDTO.setAge(String.valueOf(person.getAge()));            if (person.getSource() != null) {                personDTO.setSource(person.getSource().toString());            }            personDTO.setHeight(String.valueOf(person.getHeight()));            return personDTO;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-指定默认值"><a href="#2-2-指定默认值" class="headerlink" title="2.2 指定默认值"></a>2.2 指定默认值</h3><p>在<code>@Mapper</code>接口类里面的转换方法上添加<code>@Mapping</code>注解<br> <code>target() </code>必须添加，<code>source()</code>可以不添加，则直接使用<code>defaultValue</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapping(target = "describe", source = "describe", defaultValue = "默认值")PersonDTO conver(Person person);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>生成的impl：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">...if (person.getDescribe() != null) {    personDTO.setDescribe(person.getDescribe()); } else {     personDTO.setDescribe("默认值"); } ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-使用表达式"><a href="#2-3-使用表达式" class="headerlink" title="2.3 使用表达式"></a>2.3 使用表达式</h3><p>目前java是唯一受支持的语言，表达式必须以Java表达式的形式给出</p><blockquote><p>==注意：== 这个属性不能与source()、defaultValue()、defaultExpression()、qualifiedBy()、qualifiedByName()或constant()一起使用。</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapping(target = "describe", source = "describe", defaultValue = "默认值")@Mapping(target = "createTime",expression = "java(new java.util.Date())")PersonDTO conver(Person person);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>默认表达式<code>@Mapping#defaultExpression()</code>是默认值和表达式的组合。仅当source属性为null时才使用它们</p></blockquote><h3 id="2-4-dateFormat"><a href="#2-4-dateFormat" class="headerlink" title="2.4 dateFormat()"></a>2.4 dateFormat()</h3><p>如果属性从字符串映射到日期，则该格式字符串可由SimpleDateFormat处理，反之亦然。当映射枚举常量时，将忽略所有其他属性类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">....@Mapping(target = "createTime" ,source = "createTime", dateFormat = "yyyy-MM-dd")PersonDTO conver(Person person);...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>impl:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">try {if (person.getCreateTime() != null) {    personDTO.setCreateTime((new SimpleDateFormat("yyyy-MM-dd")).parse(person.getCreateTime()));}} catch (ParseException var4) {    throw new RuntimeException(var4);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-组合映射"><a href="#2-5-组合映射" class="headerlink" title="2.5 组合映射"></a>2.5 组合映射</h3><h4 id="2-5-1-多个源对象"><a href="#2-5-1-多个源对象" class="headerlink" title="2.5.1 多个源对象"></a>2.5.1 多个源对象</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class BasicEntity {    private Date createTime;    private String createBy;    private Date updateTime;    private String updateBy;    private int _ROW;}@Mapper(uses =DateFormtUtil.class)public interface PersonMapper {    PersonMapper INSTANCT = Mappers.getMapper(PersonMapper.class);    @Mapping(target = "personName",source = "name")    PersonDTO conver(Person person);    @Mapping(target = "createTime",source = "basicEntity.createTime")    PersonDTO combinationConver(Person personC, BasicEntity basicEntity);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-2-使用其他值"><a href="#2-5-2-使用其他值" class="headerlink" title="2.5.2 使用其他值"></a>2.5.2 使用其他值</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">...@Mapping(target = "id", source = "id")PersonDTO mapTo(Person person, String id);...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>虽然Person和PersonDTO有相同的id字段，但是映射器会使用mapTo方法里面的id参数。</p></blockquote><h3 id="2-6-嵌套映射"><a href="#2-6-嵌套映射" class="headerlink" title="2.6 嵌套映射"></a>2.6 嵌套映射</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Datapublic class Person {...private Child personChild;...}@Datapublic class PersonDTO {...    private Child child;    ...}// mapper@Mapper(uses =DateFormtUtil.class)public interface PersonMapper {    PersonMapper INSTANCT = Mappers.getMapper(PersonMapper.class);    @Mapping(target = "child", source = "personChild")    PersonDTO conver(Person person);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>如果field name一样则不需要指定@Mapping</p></blockquote><h3 id="2-7-numberFormat"><a href="#2-7-numberFormat" class="headerlink" title="2.7 numberFormat()"></a>2.7 numberFormat()</h3><p>如果带注释的方法从数字映射到字符串，则使用DecimalFormat将格式字符串作为可处理的格式。反之亦然。对于所有其他元素类型，将被忽略。从基本2.1 基本映射可以看出，number类型与字符串直接的转换是通过valueOf()，如果字符串格式不正确会抛出<code>java.lang.NumberFormatException</code>异常,例如：Integer.valueOf(“10.2”)使用numberFormat()之后DecimalFormat格式转换，还是会抛出<code>NFE</code>异常</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// mapper....@Mapping(target = "age",source = "age", numberFormat = "#0.00")PersonDTO conver(Person person);...// impplpersonDTO.setAge((new DecimalFormat("#0.00")).format((long)person.getAge()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-8-逆映射"><a href="#2-8-逆映射" class="headerlink" title="2.8 逆映射"></a>2.8 逆映射</h3><p>在双向映射的情况下，例如从实体到DTO以及从DTO到实体，前向方法和反向方法的映射规则通常是相似的，并且可以通过切换source和来简单地反转target。</p><p>使用注释<code>@InheritInverseConfiguration</code>表示方法应继承相应反向方法的反向配置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">....@Mapping(target = "age",source = "age", numberFormat = "#0.00")PersonDTO conver(Person person);@InheritInverseConfigurationPerson conver(PersonDTO dto);...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-9-继承与共享配置"><a href="#2-9-继承与共享配置" class="headerlink" title="2.9 继承与共享配置"></a>2.9 继承与共享配置</h3><h4 id="2-9-1-继承配置"><a href="#2-9-1-继承配置" class="headerlink" title="2.9.1 继承配置"></a>2.9.1 继承配置</h4><p>方法级配置注解，例如<code>@Mapping，@BeanMapping，@IterableMapping</code>，等等，都可以继承从一个映射方法的类似使用注释方法<code>@InheritConfiguration</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapper public interface CarMapper {         @Mapping(target = "numberOfSeats", source = "seatCount")        Car carDtoToCar(CarDto car);             @InheritConfiguration        void carDtoIntoCar(CarDto carDto, @MappingTarget Car car); }123456789<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的示例声明了一种<code>carDtoToCar()</code>具有配置的映射方法，该配置定义了应如何映射<code>numberOfSeats</code>类型中的属性<code>Car</code>。在现有Instance实例上执行映射的update方法Car需要相同的配置才能成功映射所有属性。通过声明<code>@InheritConfiguration</code>该方法，MapStruct可以搜索继承候选，以应用继承自该方法的注释。</p><p>如果所有类型的<strong>A</strong>（源类型和结果类型）都可以分配给<strong>B</strong>的相应类型，则一个方法<strong>A</strong>可以从另一种方法<strong>B</strong>继承配置。<br> 如果可以使用多个方法作为继承的源，则必须在注释中指定方法名称：@InheritConfiguration( name = “carDtoToCar” )。</p><p>一种方法，可以使用==@InheritConfiguration==和覆盖或通过另外施加修改的配置<code>@Mapping，@BeanMapping</code>等等。</p><h4 id="2-9-2-共享配置"><a href="#2-9-2-共享配置" class="headerlink" title="2.9.2 共享配置"></a>2.9.2 共享配置</h4><p>MapStruct提供了通过指向带注释的中央接口来定义共享配置的可能性<code>@MapperConfig</code>。为了使映射器使用共享配置，需要在<code>@Mapper#config</code>属性中定义配置接口。</p><p>该<code>@MapperConfig</code>注释具有相同的属性<code>@Mapper</code>注释。任何未通过via指定的属性<code>@Mapper</code>都将从共享配置中继承。中指定@Mapper的属性优先于通过引用的配置类指定的属性。列表属性例如<code>uses</code>可以简单组合：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@MapperConfig(unmappedTargetPolicy = ReportingPolicy.ERROR ) public interface CentralConfig { }@Mapper(config = CentralConfig.class } ) // Effective configuration: // @Mapper(uses = { CustomMapperViaMapper.class, CustomMapperViaMapperConfig.class },//     unmappedTargetPolicy = ReportingPolicy.ERROR // ) public interface SourceTargetMapper {  ... } 12345678910<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>共享配置config，配置一些检查策略<br> 例如：</p><ol><li>unmappedSourcePolicy()、unmappedTargetPolicy() : 源或者目标没有标注映射的属性怎么报告</li><li>typeConversionPolicy() :应该报告如何进行有损(缩小)转换，例如:long到integer的转换。</li><li>collectionMappingStrategy(): 集合类型映射策略<br> 其他的，请阅读源码</li></ol><h2 id="3-使用自定义方法"><a href="#3-使用自定义方法" class="headerlink" title="3. 使用自定义方法"></a>3. 使用自定义方法</h2><h3 id="3-1-自定义类型转换方法"><a href="#3-1-自定义类型转换方法" class="headerlink" title="3.1 自定义类型转换方法"></a>3.1 自定义类型转换方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DateMapper {    public String asString(Date date) {        return date != null ? new SimpleDateFormat( "yyyy-MM-dd" )            .format( date ) : null;    }    public Date asDate(String date) {        try {            return date != null ? new SimpleDateFormat( "yyyy-MM-dd" )                .parse( date ) : null;        }        catch ( ParseException e ) {            throw new RuntimeException( e );        }    }}123456789101112131415161718<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mapper:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapper(uses=DateMapper.class)public interface PersonMapper{  PersonMapper INSTANCT = Mappers.getMapper(PersonMapper.class);  PersonDTO conver(Person person);}123456<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>impl:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PersonMapperImpl implements PersonMapper {    private final DateMapper dateMapper = new DateMapper();    public PersonMapperImpl() {    }    public PersonDTO conver(Person person) {      ....      personDTO.setCreateTime(this.dateMapper.asDate(person.getCreateTime()));  ...      return personDTO;           }}12345678910111213141516<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在进行类型转换的时候直接调用改转换方法<br> <code>@Mapper#uses</code>可以使用多个类</p><h3 id="3-2-使用-Qualifier"><a href="#3-2-使用-Qualifier" class="headerlink" title="3.2 使用@Qualifier"></a>3.2 使用<code>@Qualifier</code></h3><p><code>@Qualifier</code>标记的自定义注解标记的方法，必须有输入, 否则编译时会抛出异常</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DateFormtUtil {    @DateFormat    public static String dateToString(Date date){        return date == null ? "": new SimpleDateFormat("yyyy-MM-dd").format(date);    }    @Qualifier    @Target(ElementType.METHOD)    @Retention(RetentionPolicy.CLASS)    public @interface DateFormat{}}1234567891011121314<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mapper:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapper(uses =DateFormtUtil.class)public interface PersonMapper {    PersonMapper INSTANCT = Mappers.getMapper(PersonMapper.class);    @Mapping(target = "createTime",source = "createTime",qualifiedBy = DateFormat.class)    PersonDTO conver(Person person);}12345678910<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-使用-namd"><a href="#3-3-使用-namd" class="headerlink" title="3.3 使用@namd"></a>3.3 使用@namd</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DateFormtUtil {    @Named("dateToString")    public static String dateToString(Date date){        return date == null ? "": new SimpleDateFormat("yyyy-MM-dd").format(date);    }}12345678<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mapper:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapper(uses =DateFormtUtil.class)public interface PersonMapper {    PersonMapper INSTANCT = Mappers.getMapper(PersonMapper.class);   @Mapping(target = "createTime",source = "createTime",qualifiedByName = "dateToString")    PersonDTO conver(Person person);}123456789<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>效果跟<code>@Qualifier</code>是一样的</strong></p><h2 id="4-集合映射"><a href="#4-集合映射" class="headerlink" title="4.集合映射"></a>4.集合映射</h2><p><code>MapStruct</code>有<code>CollectionMappingStrategy</code>，与可能的值：<code>ACCESSOR_ONLY，SETTER_PREFERRED，ADDER_PREFERRED</code>和T<code>ARGET_IMMUTABLE</code>。</p><p>在下表中，破折号-表示属性名称。接下来，尾部s表示复数形式。该表解释了这些选项以及它们是如何施加到存在/不存在的<code>set-s，add-s</code>和/或<code>get-s</code>在目标对象上的方法：</p><table><thead><tr><th>选项</th><th>仅目标set-s可用</th><th>仅目标add-可用</th><th>既可以set-s/add-</th><th>没有set-s/add-</th><th>现有目标<code>（@TargetType）</code></th></tr></thead><tbody><tr><td><code>ACCESSOR_ONLY</code></td><td>set-s</td><td>get-s</td><td>set-s</td><td>get-s</td><td>get-s</td></tr><tr><td><code>SETTER_PREFERRED</code></td><td>set-s</td><td>add-</td><td>set-s</td><td>get-s</td><td>get-s</td></tr><tr><td><code>ADDER_PREFERRED</code></td><td>set-s</td><td>add-</td><td>add-</td><td>get-s</td><td>get-s</td></tr><tr><td><code>TARGET_IMMUTABLE</code></td><td>set-s</td><td>exception</td><td>set-s</td><td>exception</td><td>set-s</td></tr></tbody></table><h2 id="5-集成到-spring"><a href="#5-集成到-spring" class="headerlink" title="5.集成到 spring"></a>5.集成到 spring</h2><p>在<code>@Mapper#componentModel</code> 中指定依赖注入框架</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Mapper(componentModel = "spring")public interface ModelMapper {    ModelMapper INSTANT = Mappers.getMapper(ModelMapper.class);    ModelVO conver(Model model);}// 直接在类中使用Autowired注入就行了@RestControllerclass MapperSpringController {    @Autowired    ModelMapper modelMapper;    @GetMapping("/get")    ModelVO getModle(){       Model model = new Model();       model.setId("123456");       model.setName("张三");       model.setCreate(new Date());       return modelMapper.conver(model);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-高级运用"><a href="#6-高级运用" class="headerlink" title="6. 高级运用"></a>6. 高级运用</h2><h3 id="6-1-spi的运用"><a href="#6-1-spi的运用" class="headerlink" title="6.1 spi的运用"></a>6.1 spi的运用</h3><p><a href="https://mapstruct.org/documentation/stable/reference/html/#using-spi">官方文档 关于spi的运用描述</a></p><h3 id="6-2-freemarker生成代码"><a href="#6-2-freemarker生成代码" class="headerlink" title="6.2 freemarker生成代码"></a>6.2 freemarker生成代码</h3><p><a href="https://github.com/mapstruct/mapstruct-examples/tree/master/mapstruct-mapper-repo">github链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解</title>
      <link href="/tur-study/2023/05/03/SpringBoot/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/"/>
      <url>/tur-study/2023/05/03/SpringBoot/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="1-自定义注解的定义"><a href="#1-自定义注解的定义" class="headerlink" title="1. 自定义注解的定义"></a>1. 自定义注解的定义</h3><h4 id="1-1-自定义注解的规则"><a href="#1-1-自定义注解的规则" class="headerlink" title="1.1 自定义注解的规则"></a>1.1 自定义注解的规则</h4><ol><li><code>Annotation </code>型定义为 <code>@interface</code>，所有的 Annotation 会自动实现 <code>java.lang.Annotation</code> 这一接口，并且不能再去继承别的类或者实现接口</li><li>参数成功只能是 <code>public 或默认(default)</code> 这两个访问权限修饰</li><li>参数成员只能用基本类型<code>byte,short,char,int,long,float,double,boolean</code>八种基本数据类型和<code>String、Enum、Class、annotations</code>等数据类型,以及这一些类型的数组</li><li>要获取类方法和字段的注解信息，必须通过Java的<font color="red">反射</font>技术来获取 Annotation对象,因为你除此之外没有别的获取注解对象的方法</li><li>注解也可以没有定义成员, 不过这样注解就没啥用了</li></ol><h4 id="1-2-如何自定义注解"><a href="#1-2-如何自定义注解" class="headerlink" title="1.2 如何自定义注解"></a>1.2 如何自定义注解</h4><p>对注解有了一个基本的认识：<strong>注解其实就是一种标记，可以在程序代码中的关键节点（类、方法、变量、参数、包）上打上这些标记，然后程序在编译时或运行时可以检测到这些标记从而执行一些特殊操作</strong>。因此可以得出自定义注解使用的基本流程：</p><ul><li>第一步，定义注解——相当于定义标记；</li><li>第二步，配置注解——把标记打在需要用到的程序代码中；</li><li>第三步，解析注解——在编译期或运行时检测到标记，并进行特殊操作。</li></ul><h3 id="2-注解的分类"><a href="#2-注解的分类" class="headerlink" title="2. 注解的分类"></a>2. 注解的分类</h3><h4 id="2-1-jdk-基本注解"><a href="#2-1-jdk-基本注解" class="headerlink" title="2.1 jdk 基本注解"></a>2.1 jdk 基本注解</h4><ul><li><code>@Override</code>：重写</li><li><code>@Deprecated</code>：已过时</li><li><code>@SuppressWarnings(value="unchecked")</code>：压制编辑器警告</li></ul><h4 id="2-2-JDK-元注解"><a href="#2-2-JDK-元注解" class="headerlink" title="2.2 JDK 元注解"></a>2.2 JDK 元注解</h4><blockquote><p>元注解用于修饰其他注解</p></blockquote><ul><li><p><code>@Retention</code>：定义注解的保留策略</p><ul><li><code>@Retention(RetentionPolicy.SOURCE)</code>：注解进存在于源码中，在class字节码文件中不包含</li><li><code>@Retention(RetentionPolicy.CLASS)</code>：默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>：胡姐会在class字节码文件中存在，在运行可以通过反射获取到</li></ul></li><li><p><code>@Target</code>：置顶被修饰的 Annotation 可以放置的位置，即被修饰的目标</p><p>可选的值有：</p><ul><li><code>@Target(ElementType.TYPE) </code>：接口、类</li><li><code>@Target(ElementType.FIELD)    </code>：属性</li><li><code>@Target(ElementType.METHOD)</code>：方法</li><li><code>@Target(ElementType.PARAMETER)</code>：方法参数</li><li><code>@Target(ElementType.CONSTRUCTOR)</code>：构造函数</li><li><code>@Target(ElementType.LOCAL_VARIABLE)   </code>：局部变量</li><li><code>@Target(ElementType.ANNOTATION_TYPE)</code> ：注解</li><li><code>@Target(ElementType.PACKAGE)  </code>：包</li></ul><blockquote><p>注：可以指定多个位置，例如： <code>@Target({ElementType.METHOD, ElementType.TYPE})</code>，也就是此注解可以在方法和类上面使用</p></blockquote></li><li><p><code>@Inherited</code>：指定被修饰的 Annotation 将具有继承性</p></li><li><p><code>@Documented</code>：指定被修饰的 Annotation 可以被 javadoc 工具提取成文档</p></li></ul><h4 id="2-3-自定义注解"><a href="#2-3-自定义注解" class="headerlink" title="2.3 自定义注解"></a>2.3 自定义注解</h4><h3 id="3-自定义注解的开发"><a href="#3-自定义注解的开发" class="headerlink" title="3. 自定义注解的开发"></a>3. 自定义注解的开发</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Documented@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation {    String value() default "";    String messsge() default "aaaaaaaa";}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot Redis 入门</title>
      <link href="/tur-study/2023/05/03/Redis/SpringBoot%20Redis%20%E5%85%A5%E9%97%A8/"/>
      <url>/tur-study/2023/05/03/Redis/SpringBoot%20Redis%20%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在 Spring 的生态中，使用 <code>Spring Data Redis</code> 来实现对 Redis 的数据访问，Spring Data Redis 封装了市面上常见的 Java Redis 工具库（Jedis、Lettuce等）的 API 操作</p><p>调用链路图如下：</p><p><img src="C:\Users\18517\AppData\Roaming\Typora\typora-user-images\image-20230514085926351.png" alt="image-20230514085926351"></p><ul><li><p>对于下层，Spring Data Redis 提供了统一的操作模板（后文中，我们会看到是 RedisTemplate 类），封装了 Jedis、Lettuce 的 API 操作，访问 Redis 数据。所以，<strong>实际上，Spring Data Redis 内置真正访问的实际是 Jedis、Lettuce 等 API 操作</strong>。</p></li><li><p>对于上层，开发者学习如何使用 Spring Data Redis 即可，而无需关心 Jedis、Lettuce 的 API  操作。甚至，未来如果我们想将 Redis 访问从 Jedis 迁移成 Lettuce 来，无需做任何的变动。</p></li><li><p>目前，Spring Data Redis 暂时只支持 Jedis、Lettuce 的内部封装，而 Redisson 是由 <a href="https://github.com/redisson/redisson/tree/master/redisson-spring-data">redisson-spring-data</a> 来提供</p></li></ul><h2 id="二、快速入门"><a href="#二、快速入门" class="headerlink" title="二、快速入门"></a>二、快速入门</h2><blockquote><p>在 <code>spring-boot-starter-data-redis</code> 项目 2.X 中，默认使用 Lettuce 作为 Java Redis 工具库。对于 Jedis 和 Lettuce 的对比选择，参阅：<a href="https://github.com/spring-projects/spring-session/issues/789">Jedis 和 Lettuce</a></p></blockquote><h3 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h3><h4 id="2-1-1-引入依赖"><a href="#2-1-1-引入依赖" class="headerlink" title="2.1.1 引入依赖"></a>2.1.1 引入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.7.11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencyManagement</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>fastjson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.0.25<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.fasterxml.jackson.core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jackson-databind<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-配置文件"><a href="#2-1-2-配置文件" class="headerlink" title="2.1.2 配置文件"></a>2.1.2 配置文件</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  # 对应 RedisProperties 类  redis:    host: 127.0.0.1    port: 6379    password: # Redis 服务器密码，默认为空。生产中，一定要设置 Redis 密码！    database: 0 # Redis 数据库号，默认为 0 。    timeout: 0 # Redis 连接超时时间，单位：毫秒。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-3-简单测试"><a href="#2-1-3-简单测试" class="headerlink" title="2.1.3 简单测试"></a>2.1.3 简单测试</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestpublic class Test1 {    @Autowired    private StringRedisTemplate stringRedisTemplate;    @Test    void testStringKey() {        stringRedisTemplate.opsForValue().set("zhangsan", "lisi");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-RedisTemplate"><a href="#2-2-RedisTemplate" class="headerlink" title="2.2 RedisTemplate"></a>2.2 RedisTemplate</h3><p><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/core/RedisTemplate.java"><code>org.springframework.data.redis.core.RedisTemplate</code></a> 类，提供 Redis 操作模板 API 。核心属性如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// RedisTemplate.java// 省略了一些不重要的属性。// &lt;1&gt; 序列化相关属性@SuppressWarnings("rawtypes") private @Nullable RedisSerializer keySerializer = null;@SuppressWarnings("rawtypes") private @Nullable RedisSerializer valueSerializer = null;@SuppressWarnings("rawtypes") private @Nullable RedisSerializer hashKeySerializer = null;@SuppressWarnings("rawtypes") private @Nullable RedisSerializer hashValueSerializer = null;private RedisSerializer&lt;String&gt; stringSerializer = RedisSerializer.string();// &lt;2&gt; Lua 脚本执行器private @Nullable ScriptExecutor&lt;K&gt; scriptExecutor;// &lt;3&gt; 常见数据结构操作类// cache singleton objects (where possible)private @Nullable ValueOperations&lt;K, V&gt; valueOps;private @Nullable ListOperations&lt;K, V&gt; listOps;private @Nullable SetOperations&lt;K, V&gt; setOps;private @Nullable ZSetOperations&lt;K, V&gt; zSetOps;private @Nullable GeoOperations&lt;K, V&gt; geoOps;private @Nullable HyperLogLogOperations&lt;K, V&gt; hllOps;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>&lt;1&gt;</code> 处，看到了四个序列化相关的属性，用于 KEY 和 VALUE 的序列化。<ul><li>例如说，我们在使用 POJO 对象存储到 Redis 中，一般情况下，会使用 JSON 方式序列化成字符串，存储到 Redis 中。</li><li>在上文中，我们看到了 <a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/core/StringRedisTemplate.java"><code>org.springframework.data.redis.core.StringRedisTemplate</code></a> 类，它继承 RedisTemplate 类，使用 <a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/serializer/StringRedisSerializer.java"><code>org.springframework.data.redis.serializer.StringRedisSerializer</code></a> 字符串序列化方式。直接点开 <code>StringRedisSerializer </code>源码，看下它的构造方法，瞬间明明白白。</li></ul></li><li><code>&lt;2&gt;</code> 处，Lua 脚本执行器，提供 <a href="http://redis.cn/commands.html#scripting">Redis scripting</a> API 操作。</li><li><code>&lt;3&gt;</code> 处，Redis 常见数据结构操作类。<ul><li><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/core/ValueOperations.java">ValueOperations</a> 类，提供 <a href="http://redis.cn/commands.html#string">Redis String</a> API 操作。</li><li><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/core/ListOperations.java">ListOperations</a> 类，提供 <a href="http://redis.cn/commands.html#list">Redis List</a> API 操作。</li><li><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/core/SetOperations.java">SetOperations</a> 类，提供 <a href="http://redis.cn/commands.html#set">Redis Set</a> API 操作。</li><li><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/core/ZSetOperations.java">ZSetOperations</a> 类，提供 <a href="http://redis.cn/commands.html#sorted_set">Redis ZSet(Sorted Set)</a> API 操作。</li><li><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/core/GeoOperations.java">GeoOperations</a> 类，提供 <a href="http://redis.cn/commands.html#geo">Redis Geo</a> API 操作。</li><li><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/core/HyperLogLogOperations.java">HyperLogLogOperations</a> 类，提供 <a href="http://redis.cn/commands.html#hyperloglog">Redis HyperLogLog</a> API 操作。</li></ul></li></ul><h2 id="三、-序列化"><a href="#三、-序列化" class="headerlink" title="三、 序列化"></a>三、 序列化</h2><h3 id="3-1-RedisSerializer"><a href="#3-1-RedisSerializer" class="headerlink" title="3.1 RedisSerializer"></a>3.1 RedisSerializer</h3><p><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/serializer/RedisSerializer.java"><code>org.springframework.data.redis.serializer.RedisSerializer</code></a> 接口，Redis 序列化接口，用于 Redis KEY 和 VALUE 的序列化</p><p>简化源码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// RedisSerializer.javapublic interface RedisSerializer&lt;T&gt; {@Nullablebyte[] serialize(@Nullable T t) throws SerializationException;@NullableT deserialize(@Nullable byte[] bytes) throws SerializationException;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>定义对象 <code>&lt;T&gt;</code> 和二进制数组的在转换</li><li>Redis Client 传递给 Redis Server 的 KEY、VALUE 都是二进制数组的</li></ul><p>RedisSerializer 的实现类如下图：</p><p><img src="/tur-study/../../../../../AppData/Roaming/Typora/typora-user-images/image-20230514095009655.png" alt="image-20230514095009655"></p><p>主要分成四类：</p><ul><li>JDK 序列化方式</li><li>String 序列化方式</li><li>JSON 序列化方式</li><li>XML 序列化方式</li></ul><h4 id="3-1-1-JDK-序列化方式"><a href="#3-1-1-JDK-序列化方式" class="headerlink" title="3.1.1 JDK 序列化方式"></a>3.1.1 JDK 序列化方式</h4><p><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/serializer/JdkSerializationRedisSerializer.java"><code>org.springframework.data.redis.serializer.JdkSerializationRedisSerializer</code></a> ，默认情况下，RedisTemplate 使用该数据列化方式。具体的，可以看看 <a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/core/RedisTemplate.java"><code>RedisTemplate#afterPropertiesSet()</code></a> 方法，在 RedisTemplate 未设置序列化的情况下，使用 <code>JdkSerializationRedisSerializer </code>作为序列化实现。在 Spring Boot 自动化配置 RedisTemplate Bean 对象时，就未设置。</p><p><img src="/tur-study/../../../../../AppData/Roaming/Typora/typora-user-images/image-20230514095713405.png" alt="image-20230514095713405"></p><p>但是绝大多数情况下，几乎一定，我们不会使用 JdkSerializationRedisSerializer 进行序列化。具体为什么看哪下面的测试。</p><p>JDK 序列化测试：使用 RedisTemplate 而不是用 StringRedisTemplate，默认使用 JDK 序列化</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestpublic class Test1 {        @Autowired    private RedisTemplate redisTemplate;        @Test    void testStringKey() {        redisTemplate.opsForValue().set("jdk", "ceshi");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行测试方法后，在 Redis 控制台的数据如下：</p><p><img src="/tur-study/../../../../../AppData/Roaming/Typora/typora-user-images/image-20230514100226871.png" alt="image-20230514100226871"></p><p>可以看到 KEY、VALUE 的前面都有一串16进制字符，这串字符就是标志位 + 字符串长度 + 字符串内容。由 <a href="https://github.com/JetBrains/jdk8u_jdk/blob/master/src/share/classes/java/io/ObjectOutputStream.java#L1301-L1311"><code>ObjectOutputStream#writeString(String str, boolean unshared)</code></a> 添加的</p><p>这对于通过 KEY 去查询、阅读 VALUE 都有点困难。所以，不使用 JDK 序列化方式</p><h4 id="3-1-2-String-序列化方式"><a href="#3-1-2-String-序列化方式" class="headerlink" title="3.1.2 String 序列化方式"></a>3.1.2 String 序列化方式</h4><p><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/serializer/StringRedisSerializer.java"><code>org.springframework.data.redis.serializer.StringRedisSerializer</code></a> ，字符串和二进制数组的<strong>直接</strong>转换。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// StringRedisSerializer.javaprivate final Charset charset;@Overridepublic String deserialize(@Nullable byte[] bytes) {return (bytes == null ? null : new String(bytes, charset));}@Overridepublic byte[] serialize(@Nullable String string) {return (string == null ? null : string.getBytes(charset));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>绝大多数情况下，我们 KEY 和 VALUE 都会使用这种序列化方案</strong>。而 VALUE 的序列化和反序列化，自己在逻辑调用 JSON 方法去序列化</p><h4 id="3-1-3-JSON-序列化方式"><a href="#3-1-3-JSON-序列化方式" class="headerlink" title="3.1.3 JSON 序列化方式"></a>3.1.3 JSON 序列化方式</h4><p><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/serializer/GenericJackson2JsonRedisSerializer.java"><code>org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer</code></a> ，使用 Jackson 实现 JSON 的序列化方式，并且从 Generic 单词可以看出，是支持所有类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// GenericJackson2JsonRedisSerializer.javapublic GenericJackson2JsonRedisSerializer(@Nullable String classPropertyTypeName) {this(new ObjectMapper());// simply setting {@code mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS)} does not help here since we need// the type hint embedded for deserialization using the default typing feature.mapper.registerModule(new SimpleModule().addSerializer(new NullValueSerializer(classPropertyTypeName)));// &lt;1&gt;if (StringUtils.hasText(classPropertyTypeName)) {mapper.enableDefaultTypingAsProperty(DefaultTyping.NON_FINAL, classPropertyTypeName);// &lt;2&gt;} else {mapper.enableDefaultTyping(DefaultTyping.NON_FINAL, As.PROPERTY);}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>&lt;1&gt;</code> 处，如果传入了 <code>classPropertyTypeName</code> 属性，就是使用使用传入对象的 <code>classPropertyTypeName</code> 属性对应的值，作为默认类型（Default Typing）。</li><li><code>&lt;2&gt;</code> 处，如果未传入 <code>classPropertyTypeName</code> 属性，则使用传入对象的类全名，作为默认类型（Default Typing）。</li></ul><p>Jackson 通过 Default Typing ，会在字符串多冗余一个类型，这样反序列化就知道具体的类型了，示例如下：</p><p><img src="/tur-study/../../../../../AppData/Roaming/Typora/typora-user-images/image-20230514111457309.png" alt="image-20230514111457309"></p><p><code>@class</code> 属性看似完美解决了反序列化后的对象类型，但是带来 JSON 字符串占用变大，所以实际项目中，我们也并不会采用 <code>Jackson2JsonRedisSerializer </code>类。</p><p><a href="https://github.com/spring-projects/spring-data-redis/blob/master/src/main/java/org/springframework/data/redis/serializer/GenericJackson2JsonRedisSerializer.java"><code>org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer</code></a> ，使用 Jackson 实现 JSON 的序列化方式，并且显示指定 <code>&lt;T&gt;</code> 类型。代码如下：</p><pre class="line-numbers language-none"><code class="language-none">// Jackson2JsonRedisSerializer.javapublic class Jackson2JsonRedisSerializer&lt;T&gt; implements RedisSerializer&lt;T&gt; {    // ... 省略不重要的代码    public static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;    /**     * 指定类型，和 &lt;T&gt; 要一致。     */    private final JavaType javaType;    private ObjectMapper objectMapper = new ObjectMapper();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为 Jackson2JsonRedisSerializer 序列化类里已经声明了类型，所以序列化的 JSON 字符串，无需在存储一个 <code>@class</code> 属性，用于存储类型。</p><p>但是如果使用 Jackson2JsonRedisSerializer  作为序列化实现类，那么如果我们类型比较多，岂不是每个类型都要定义一个 RedisTemplate Bean  了？！所以实际场景下，我们也并不会使用 Jackson2JsonRedisSerializer 类</p><p><a href="https://github.com/alibaba/fastjson/blob/master/src/main/java/com/alibaba/fastjson/support/spring/GenericFastJsonRedisSerializer.java"><code>com.alibaba.fastjson.support.spring.GenericFastJsonRedisSerializer</code></a> ，使用 FastJSON 实现 JSON 的序列化方式，和 GenericJackson2JsonRedisSerializer 一致</p><blockquote><p>注意，GenericFastJsonRedisSerializer 不是 Spring Data Redis 内置实现，而是由于 FastJSON 自己实现。</p></blockquote><p><a href="https://github.com/alibaba/fastjson/blob/master/src/main/java/com/alibaba/fastjson/support/spring/FastJsonRedisSerializer.java"><code>com.alibaba.fastjson.support.spring.FastJsonRedisSerializer</code></a> ，使用 FastJSON 实现 JSON 的序列化方式，和 Jackson2JsonRedisSerializer 一致</p><blockquote><p>注意，GenericFastJsonRedisSerializer 不是 Spring Data Redis 内置实现，而是由于 FastJSON 自己实现。</p></blockquote><h4 id="3-1-4-XML-序列化方式"><a href="#3-1-4-XML-序列化方式" class="headerlink" title="3.1.4 XML 序列化方式"></a>3.1.4 XML 序列化方式</h4><p>loading…</p><h3 id="3-2-配置序列化方式"><a href="#3-2-配置序列化方式" class="headerlink" title="3.2 配置序列化方式"></a>3.2 配置序列化方式</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class RedisConfiguration {    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {        // 创建 RedisTemplate 对象        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        // 设置 RedisConnection 工厂。😈 它就是实现多种 Java Redis 客户端接入的秘密工厂。感兴趣的胖友，可以自己去撸下。        template.setConnectionFactory(factory);        // 使用 String 序列化方式，序列化 KEY 。        template.setKeySerializer(RedisSerializer.string());        // 使用 JSON 序列化方式（库是 Jackson ），序列化 VALUE 。        template.setValueSerializer(RedisSerializer.json());        return template;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>RedisSerializer#string()</code> 静态方法，返回的就是使用 UTF-8 编码的 StringRedisSerializer 对象。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// RedisSerializer.javastatic RedisSerializer&lt;String&gt; string() {return StringRedisSerializer.UTF_8;}// StringRedisSerializer.javapublic static final StringRedisSerializer ISO_8859_1 = new StringRedisSerializer(StandardCharsets.ISO_8859_1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>RedisSerializer#json()</code> 静态方法，返回 GenericJackson2JsonRedisSerializer 对象。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// RedisSerializer.javastatic RedisSerializer&lt;Object&gt; json() {return new GenericJackson2JsonRedisSerializer();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-自定义-RedisSerializer-实现类"><a href="#3-3-自定义-RedisSerializer-实现类" class="headerlink" title="3.3 自定义 RedisSerializer 实现类"></a>3.3 自定义 RedisSerializer 实现类</h3><h2 id="四、其他功能"><a href="#四、其他功能" class="headerlink" title="四、其他功能"></a>四、其他功能</h2><h3 id="4-1-Pipeline"><a href="#4-1-Pipeline" class="headerlink" title="4.1 Pipeline"></a>4.1 Pipeline</h3><h3 id="4-2-Session"><a href="#4-2-Session" class="headerlink" title="4.2 Session"></a>4.2 Session</h3>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式--行为型模式</title>
      <link href="/tur-study/2023/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/tur-study/2023/05/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式分为：</p><ul><li>模板方法模式</li><li>策略模式</li><li>命令模式</li><li>职责链模式</li><li>状态模式</li><li>观察者模式</li><li>中介者模式</li><li>迭代器模式</li><li>访问者模式</li><li>备忘录模式</li><li>解释器模式</li></ul><p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。</p><h2 id="一、模板方法模式"><a href="#一、模板方法模式" class="headerlink" title="一、模板方法模式"></a>一、模板方法模式</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p><p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p><p><strong>定义：</strong></p><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><h3 id="1-2-结构"><a href="#1-2-结构" class="headerlink" title="1.2 结构"></a>1.2 结构</h3><p>模板方法（Template Method）模式包含以下主要角色：</p><ul><li><p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p><ul><li><p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p></li><li><p>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：</p><ul><li><p>抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。</p></li><li><p>具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p></li><li><p>钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p><p>一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。</p></li></ul></li></ul></li><li><p>具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p></li></ul><h3 id="1-3-案例实现"><a href="#1-3-案例实现" class="headerlink" title="1.3 案例实现"></a>1.3 案例实现</h3><p>【例】炒菜</p><p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152029707.png" alt="模板方法模式"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class AbstractClass {        public final void cookProcess() {        //第一步：倒油        this.pourOil();        //第二步：热油        this.heatOil();        //第三步：倒蔬菜        this.pourVegetable();        //第四步：倒调味料        this.pourSauce();        //第五步：翻炒        this.fry();    }    public void pourOil() {        System.out.println("倒油");    }    //第二步：热油是一样的，所以直接实现    public void heatOil() {        System.out.println("热油");    }    //第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）    public abstract void pourVegetable();    //第四步：倒调味料是不一样    public abstract void pourSauce();    //第五步：翻炒是一样的，所以直接实现    public void fry(){        System.out.println("炒啊炒啊炒到熟啊");    }}public class ConcreteClass_BaoCai extends AbstractClass {    @Override    public void pourVegetable() {        System.out.println("下锅的蔬菜是包菜");    }    @Override    public void pourSauce() {        System.out.println("下锅的酱料是辣椒");    }}public class ConcreteClass_CaiXin extends AbstractClass {    @Override    public void pourVegetable() {        System.out.println("下锅的蔬菜是菜心");    }    @Override    public void pourSauce() {        System.out.println("下锅的酱料是蒜蓉");    }}public class Client {    public static void main(String[] args) {        //炒手撕包菜        ConcreteClass_BaoCai baoCai = new ConcreteClass_BaoCai();        baoCai.cookProcess();        //炒蒜蓉菜心        ConcreteClass_CaiXin caiXin = new ConcreteClass_CaiXin();        caiXin.cookProcess();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：为防止恶意操作，一般模板方法都加上 <code>final </code>关键词。</p></blockquote><h3 id="1-4-优缺点"><a href="#1-4-优缺点" class="headerlink" title="1.4 优缺点"></a>1.4 优缺点</h3><p><strong>优点：</strong></p><ul><li><p>提高代码复用性</p><p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p></li><li><p>实现了反向控制</p><p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p></li></ul><p><strong>缺点：</strong></p><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li></ul><h3 id="1-5-使用场景"><a href="#1-5-使用场景" class="headerlink" title="1.5 使用场景"></a>1.5 使用场景</h3><ul><li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li></ul><h3 id="1-6-JDK-源码解析"><a href="#1-6-JDK-源码解析" class="headerlink" title="1.6 JDK 源码解析"></a>1.6 JDK 源码解析</h3><p>InputStream类就使用了模板方法模式。在InputStream类中定义了多个 <code>read()</code> 方法，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class InputStream implements Closeable {    //抽象方法，要求子类必须重写    public abstract int read() throws IOException;    public int read(byte b[]) throws IOException {        return read(b, 0, b.length);    }    public int read(byte b[], int off, int len) throws IOException {        if (b == null) {            throw new NullPointerException();        } else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) {            throw new IndexOutOfBoundsException();        } else if (len == 0) {            return 0;        }        int c = read(); //调用了无参的read方法，该方法是每次读取一个字节数据        if (c == -1) {            return -1;        }        b[off] = (byte)c;        int i = 1;        try {            for (; i &lt; len ; i++) {                c = read();                if (c == -1) {                    break;                }                b[off + i] = (byte)c;            }        } catch (IOException ee) {        }        return i;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面代码可以看到，无参的 <code>read()</code> 方法是抽象方法，要求子类必须实现。而 <code>read(byte b[])</code> 方法调用了 <code>read(byte b[], int off, int len)</code> 方法，所以在此处重点看的方法是带三个参数的方法。 </p><p>在该方法中第18行、27行，可以看到调用了无参的抽象的 <code>read()</code> 方法。</p><p>总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。</p><h2 id="二、策略模式"><a href="#二、策略模式" class="headerlink" title="二、策略模式"></a>二、策略模式</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152034277.png" alt="image-20200210143039168"></p><p><strong>定义：</strong></p><p>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p><h3 id="2-2-结构"><a href="#2-2-结构" class="headerlink" title="2.2 结构"></a>2.2 结构</h3><p>策略模式的主要角色如下：</p><ul><li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><h3 id="2-3-案例实现"><a href="#2-3-案例实现" class="headerlink" title="2.3 案例实现"></a>2.3 案例实现</h3><p>【例】促销活动</p><p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152035980.png" alt="策略模式"></p><p>代码如下：</p><p>定义百货公司所有促销活动的共同接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Strategy {    void show();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//为春节准备的促销活动Apublic class StrategyA implements Strategy {    public void show() {        System.out.println("买一送一");    }}//为中秋准备的促销活动Bpublic class StrategyB implements Strategy {    public void show() {        System.out.println("满200元减50元");    }}//为圣诞准备的促销活动Cpublic class StrategyC implements Strategy {    public void show() {        System.out.println("满1000元加一元换购任意200元以下商品");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SalesMan {                            //持有抽象策略角色的引用                                  private Strategy strategy;                                                                    public SalesMan(Strategy strategy) {               this.strategy = strategy;                  }                                                                                             //向客户展示促销活动                                    public void salesManShow(){                        strategy.show();                           }                                          }                                              <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-优缺点"><a href="#2-4-优缺点" class="headerlink" title="2.4 优缺点"></a>2.4 优缺点</h3><p><strong>优点：</strong></p><ul><li><p>策略类之间可以自由切换</p><p>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p></li><li><p>易于扩展</p><p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p></li><li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</p></li></ul><p><strong>缺点：</strong></p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><h3 id="2-5-使用场景"><a href="#2-5-使用场景" class="headerlink" title="2.5 使用场景"></a>2.5 使用场景</h3><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li></ul><h3 id="2-6-源码解析"><a href="#2-6-源码解析" class="headerlink" title="2.6 源码解析"></a>2.6 源码解析</h3><p><code>Comparator</code> 中的策略模式。在Arrays类中有一个 <code>sort()</code> 方法，如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Arrays{    public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) {        if (c == null) {            sort(a);        } else {            if (LegacyMergeSort.userRequested)                legacyMergeSort(a, c);            else                TimSort.sort(a, 0, a.length, c, null, 0, 0);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Arrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class demo {    public static void main(String[] args) {        Integer[] data = {12, 2, 3, 2, 4, 5, 1};        // 实现降序排序        Arrays.sort(data, new Comparator&lt;Integer&gt;() {            public int compare(Integer o1, Integer o2) {                return o2 - o1;            }        });        System.out.println(Arrays.toString(data)); //[12, 5, 4, 3, 2, 2, 1]    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的 <code>compare()</code> 方法吗？让我们继续查看TimSort类的 <code>sort()</code> 方法，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">class TimSort&lt;T&gt; {    static &lt;T&gt; void sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c,                         T[] work, int workBase, int workLen) {        assert c != null &amp;&amp; a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;        int nRemaining  = hi - lo;        if (nRemaining &lt; 2)            return;  // Arrays of size 0 and 1 are always sorted        // If array is small, do a "mini-TimSort" with no merges        if (nRemaining &lt; MIN_MERGE) {            int initRunLen = countRunAndMakeAscending(a, lo, hi, c);            binarySort(a, lo, hi, lo + initRunLen, c);            return;        }        ...    }               private static &lt;T&gt; int countRunAndMakeAscending(T[] a, int lo, int hi,Comparator&lt;? super T&gt; c) {        assert lo &lt; hi;        int runHi = lo + 1;        if (runHi == hi)            return 1;        // Find end of run, and reverse range if descending        if (c.compare(a[runHi++], a[lo]) &lt; 0) { // Descending            while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &lt; 0)                runHi++;            reverseRange(a, lo, runHi);        } else {                              // Ascending            while (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - 1]) &gt;= 0)                runHi++;        }        return runHi - lo;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码中最终会跑到 <code>countRunAndMakeAscending()</code> 这个方法中。我们可以看见，只用了compare方法，所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。</p><h2 id="三、命令模式"><a href="#三、命令模式" class="headerlink" title="三、命令模式"></a>三、命令模式</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>日常生活中，我们出去吃饭都会遇到下面的场景。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152040399.png" alt="image-20200211130313251"></p><p><strong>定义：</strong></p><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p><h3 id="3-2-结构"><a href="#3-2-结构" class="headerlink" title="3.2 结构"></a>3.2 结构</h3><p>命令模式包含以下主要角色：</p><ul><li>抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。</li><li>具体命令（Concrete  Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li><li>实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li><li>调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li></ul><h3 id="3-3-案例实现"><a href="#3-3-案例实现" class="headerlink" title="3.3 案例实现"></a>3.3 案例实现</h3><p>将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。</p><p>服务员： 就是调用者角色，由她来发起命令。</p><p>资深大厨： 就是接收者角色，真正命令执行的对象。</p><p>订单： 命令中包含订单。</p><p>类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152042840.png" alt="命令模式"></p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Command {    void execute();//只需要定义一个统一的执行方法}public class OrderCommand implements Command {    //持有接受者对象    private SeniorChef receiver;    private Order order;    public OrderCommand(SeniorChef receiver, Order order){        this.receiver = receiver;        this.order = order;    }    public void execute()  {        System.out.println(order.getDiningTable() + "桌的订单：");        Set&lt;String&gt; keys = order.getFoodDic().keySet();        for (String key : keys) {            receiver.makeFood(order.getFoodDic().get(key),key);        }        try {            Thread.sleep(100);//停顿一下 模拟做饭的过程        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(order.getDiningTable() + "桌的饭弄好了");    }}public class Order {    // 餐桌号码    private int diningTable;    // 用来存储餐名并记录份数    private Map&lt;String, Integer&gt; foodDic = new HashMap&lt;String, Integer&gt;();    public int getDiningTable() {        return diningTable;    }    public void setDiningTable(int diningTable) {        this.diningTable = diningTable;    }    public Map&lt;String, Integer&gt; getFoodDic() {        return foodDic;    }    public void setFoodDic(String name, int num) {        foodDic.put(name,num);    }}// 资深大厨类 是命令的Receiverpublic class SeniorChef {    public void makeFood(int num,String foodName) {        System.out.println(num + "份" + foodName);    }}public class Waitor {    private ArrayList&lt;Command&gt; commands;//可以持有很多的命令对象    public Waitor() {        commands = new ArrayList();    }        public void setCommand(Command cmd){        commands.add(cmd);    }    // 发出命令 喊 订单来了，厨师开始执行    public void orderUp() {        System.out.println("美女服务员：叮咚，大厨，新订单来了.......");        for (int i = 0; i &lt; commands.size(); i++) {            Command cmd = commands.get(i);            if (cmd != null) {                cmd.execute();            }        }    }}public class Client {    public static void main(String[] args) {        //创建2个order        Order order1 = new Order();        order1.setDiningTable(1);        order1.getFoodDic().put("西红柿鸡蛋面",1);        order1.getFoodDic().put("小杯可乐",2);        Order order2 = new Order();        order2.setDiningTable(3);        order2.getFoodDic().put("尖椒肉丝盖饭",1);        order2.getFoodDic().put("小杯雪碧",1);        //创建接收者        SeniorChef receiver=new SeniorChef();        //将订单和接收者封装成命令对象        OrderCommand cmd1 = new OrderCommand(receiver, order1);        OrderCommand cmd2 = new OrderCommand(receiver, order2);        //创建调用者 waitor        Waitor invoker = new Waitor();        invoker.setCommand(cmd1);        invoker.setCommand(cmd2);        //将订单带到柜台 并向厨师喊 订单来了        invoker.orderUp();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-优缺点"><a href="#3-4-优缺点" class="headerlink" title="3.4 优缺点"></a>3.4 优缺点</h3><p><strong>优点：</strong></p><ul><li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li><li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li><li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li><li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li></ul><p><strong>缺点：</strong></p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。</li><li>系统结构更加复杂。</li></ul><h3 id="3-5-使用场景"><a href="#3-5-使用场景" class="headerlink" title="3.5 使用场景"></a>3.5 使用场景</h3><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li></ul><h3 id="3-6-JDK-源码解析"><a href="#3-6-JDK-源码解析" class="headerlink" title="3.6 JDK 源码解析"></a>3.6 JDK 源码解析</h3><p>Runable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就是其执行方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//命令接口(抽象命令角色)public interface Runnable {public abstract void run();}//调用者public class Thread implements Runnable {    private Runnable target;        public synchronized void start() {        if (threadStatus != 0)            throw new IllegalThreadStateException();        group.add(this);        boolean started = false;        try {            start0();            started = true;        } finally {            try {                if (!started) {                    group.threadStartFailed(this);                }            } catch (Throwable ignore) {            }        }    }        private native void start0();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * jdk Runnable 命令模式 *TurnOffThread ： 属于具体 */public class TurnOffThread implements Runnable{     private Receiver receiver;         public TurnOffThread(Receiver receiver) {     this.receiver = receiver;     }     public void run() {     receiver.turnOFF();     }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 测试类 */public class Demo {     public static void main(String[] args) {         Receiver receiver = new Receiver();         TurnOffThread turnOffThread = new TurnOffThread(receiver);         Thread thread = new Thread(turnOffThread);         thread.start();     }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、责任链模式"><a href="#四、责任链模式" class="headerlink" title="四、责任链模式"></a>四、责任链模式</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p><p><strong>定义：</strong></p><p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><h3 id="4-2-结构"><a href="#4-2-结构" class="headerlink" title="4.2 结构"></a>4.2 结构</h3><p>职责链模式主要包含以下角色:</p><ul><li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li></ul><h3 id="4-3-案例实现"><a href="#4-3-案例实现" class="headerlink" title="4.3 案例实现"></a>4.3 案例实现</h3><p>现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p><p>类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152047483.png" alt="责任链模式"></p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//请假条public class LeaveRequest {    private String name;//姓名    private int num;//请假天数    private String content;//请假内容    public LeaveRequest(String name, int num, String content) {        this.name = name;        this.num = num;        this.content = content;    }    public String getName() {        return name;    }    public int getNum() {        return num;    }    public String getContent() {        return content;    }}//处理者抽象类public abstract class Handler {    protected final static int NUM_ONE = 1;    protected final static int NUM_THREE = 3;    protected final static int NUM_SEVEN = 7;    //该领导处理的请假天数区间    private int numStart;    private int numEnd;    //领导上面还有领导    private Handler nextHandler;    //设置请假天数范围 上不封顶    public Handler(int numStart) {        this.numStart = numStart;    }    //设置请假天数范围    public Handler(int numStart, int numEnd) {        this.numStart = numStart;        this.numEnd = numEnd;    }    //设置上级领导    public void setNextHandler(Handler nextHandler){        this.nextHandler = nextHandler;    }    //提交请假条    public final void submit(LeaveRequest leave){        if(0 == this.numStart){            return;        }        //如果请假天数达到该领导者的处理要求        if(leave.getNum() &gt;= this.numStart){            this.handleLeave(leave);            //如果还有上级 并且请假天数超过了当前领导的处理范围            if(null != this.nextHandler &amp;&amp; leave.getNum() &gt; numEnd){                this.nextHandler.submit(leave);//继续提交            } else {                System.out.println("流程结束");            }        }    }    //各级领导处理请假条方法    protected abstract void handleLeave(LeaveRequest leave);}//小组长public class GroupLeader extends Handler {    public GroupLeader() {        //小组长处理1-3天的请假        super(Handler.NUM_ONE, Handler.NUM_THREE);    }    @Override    protected void handleLeave(LeaveRequest leave) {        System.out.println(leave.getName() + "请假" + leave.getNum() + "天," + leave.getContent() + "。");        System.out.println("小组长审批：同意。");    }}//部门经理public class Manager extends Handler {    public Manager() {        //部门经理处理3-7天的请假        super(Handler.NUM_THREE, Handler.NUM_SEVEN);    }    @Override    protected void handleLeave(LeaveRequest leave) {        System.out.println(leave.getName() + "请假" + leave.getNum() + "天," + leave.getContent() + "。");        System.out.println("部门经理审批：同意。");    }}//总经理public class GeneralManager extends Handler {    public GeneralManager() {        //部门经理处理7天以上的请假        super(Handler.NUM_SEVEN);    }    @Override    protected void handleLeave(LeaveRequest leave) {        System.out.println(leave.getName() + "请假" + leave.getNum() + "天," + leave.getContent() + "。");        System.out.println("总经理审批：同意。");    }}//测试类public class Client {    public static void main(String[] args) {        //请假条来一张        LeaveRequest leave = new LeaveRequest("小花",5,"身体不适");        //各位领导        GroupLeader groupLeader = new GroupLeader();        Manager manager = new Manager();        GeneralManager generalManager = new GeneralManager();        groupLeader.setNextHandler(manager);//小组长的领导是部门经理        manager.setNextHandler(generalManager);//部门经理的领导是总经理        //之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。        //提交申请        groupLeader.submit(leave);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-优缺点"><a href="#4-4-优缺点" class="headerlink" title="4.4 优缺点"></a>4.4 优缺点</h3><p><strong>优点：</strong></p><ul><li><p>降低了对象之间的耦合度</p><p>该模式降低了请求发送者和接收者的耦合度。</p></li><li><p>增强了系统的可扩展性</p><p>可以根据需要增加新的请求处理类，满足开闭原则。</p></li><li><p>增强了给对象指派职责的灵活性</p><p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p></li><li><p>责任链简化了对象之间的连接</p><p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</p></li><li><p>责任分担</p><p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p></li></ul><p><strong>缺点：</strong></p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li></ul><h3 id="4-5-源码解析"><a href="#4-5-源码解析" class="headerlink" title="4.5 源码解析"></a>4.5 源码解析</h3><p>在javaWeb应用开发中，FilterChain是职责链（过滤器）模式的典型应用，以下是Filter的模拟实现分析:</p><ul><li><p>模拟web请求Request以及web响应Response</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Request{ }public interface Response{ }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>模拟web过滤器Filter</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Filter {public void doFilter(Request req,Response res,FilterChain c);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>模拟实现具体过滤器  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FirstFilter implements Filter {    @Override    public void doFilter(Request request, Response response, FilterChain chain) {        System.out.println("过滤器1 前置处理");        // 先执行所有request再倒序执行所有response        chain.doFilter(request, response);        System.out.println("过滤器1 后置处理");    }}public class SecondFilter  implements Filter {    @Override    public void doFilter(Request request, Response response, FilterChain chain) {        System.out.println("过滤器2 前置处理");        // 先执行所有request再倒序执行所有response        chain.doFilter(request, response);        System.out.println("过滤器2 后置处理");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>模拟实现过滤器链FilterChain  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class FilterChain {    private List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;();    private int index = 0;    // 链式调用    public FilterChain addFilter(Filter filter) {        this.filters.add(filter);        return this;    }    public void doFilter(Request request, Response response) {        if (index == filters.size()) {            return;        }        Filter filter = filters.get(index);        index++;        filter.doFilter(request, response, this);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Client {    public static void main(String[] args) {        Request  req = null;        Response res = null ;        FilterChain filterChain = new FilterChain();        filterChain.addFilter(new FirstFilter()).addFilter(new SecondFilter());        filterChain.doFilter(req,res);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="五、状态模式"><a href="#五、状态模式" class="headerlink" title="五、状态模式"></a>五、状态模式</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>【例】通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。</p><p>类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152055400.png" alt="状态模式前"></p><p>不用状态模式的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface ILift {    //电梯的4个状态    //开门状态    public final static int OPENING_STATE = 1;    //关门状态    public final static int CLOSING_STATE = 2;    //运行状态    public final static int RUNNING_STATE = 3;    //停止状态    public final static int STOPPING_STATE = 4;    //设置电梯的状态    public void setState(int state);    //电梯的动作    public void open();    public void close();    public void run();    public void stop();}public class Lift implements ILift {    private int state;    @Override    public void setState(int state) {        this.state = state;    }    //执行关门动作    @Override    public void close() {        switch (this.state) {            case OPENING_STATE:                System.out.println("电梯关门了。。。");//只有开门状态可以关闭电梯门，可以对应电梯状态表来看                this.setState(CLOSING_STATE);//关门之后电梯就是关闭状态了                break;            case CLOSING_STATE:                //do nothing //已经是关门状态，不能关门                break;            case RUNNING_STATE:                //do nothing //运行时电梯门是关着的，不能关门                break;            case STOPPING_STATE:                //do nothing //停止时电梯也是关着的，不能关门                break;        }    }    //执行开门动作    @Override    public void open() {        switch (this.state) {            case OPENING_STATE://门已经开了，不能再开门了                //do nothing                break;            case CLOSING_STATE://关门状态，门打开:                System.out.println("电梯门打开了。。。");                this.setState(OPENING_STATE);                break;            case RUNNING_STATE:                //do nothing 运行时电梯不能开门                break;            case STOPPING_STATE:                System.out.println("电梯门开了。。。");//电梯停了，可以开门了                this.setState(OPENING_STATE);                break;        }    }    //执行运行动作    @Override    public void run() {        switch (this.state) {            case OPENING_STATE://电梯不能开着门就走                //do nothing                break;            case CLOSING_STATE://门关了，可以运行了                System.out.println("电梯开始运行了。。。");                this.setState(RUNNING_STATE);//现在是运行状态                break;            case RUNNING_STATE:                //do nothing 已经是运行状态了                break;            case STOPPING_STATE:                System.out.println("电梯开始运行了。。。");                this.setState(RUNNING_STATE);                break;        }    }    //执行停止动作    @Override    public void stop() {        switch (this.state) {            case OPENING_STATE: //开门的电梯已经是是停止的了(正常情况下)                //do nothing                break;            case CLOSING_STATE://关门时才可以停止                System.out.println("电梯停止了。。。");                this.setState(STOPPING_STATE);                break;            case RUNNING_STATE://运行时当然可以停止了                System.out.println("电梯停止了。。。");                this.setState(STOPPING_STATE);                break;            case STOPPING_STATE:                //do nothing                break;        }    }}public class Client {    public static void main(String[] args) {        Lift lift = new Lift();        lift.setState(ILift.STOPPING_STATE);//电梯是停止的        lift.open();//开门        lift.close();//关门        lift.run();//运行        lift.stop();//停止    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>问题分析：</p><ul><li>使用了大量的switch…case这样的判断（if…else也是一样)，使程序的可阅读性变差。</li><li>扩展性很差。如果新加了断电的状态，我们需要修改上面判断逻辑</li></ul><p><strong>定义：</strong></p><p>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p><h3 id="5-2-结构"><a href="#5-2-结构" class="headerlink" title="5.2 结构"></a>5.2 结构</h3><p>状态模式包含以下主要角色。</p><ul><li>环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li><li>具体状态（Concrete  State）角色：实现抽象状态所对应的行为。</li></ul><h3 id="5-3-案例实现"><a href="#5-3-案例实现" class="headerlink" title="5.3 案例实现"></a>5.3 案例实现</h3><p>对上述电梯的案例使用状态模式进行改进。类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152057360.png" alt="状态模式"></p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//抽象状态类public abstract class LiftState {    //定义一个环境角色，也就是封装状态的变化引起的功能变化    protected Context context;    public void setContext(Context context) {        this.context = context;    }    //电梯开门动作    public abstract void open();    //电梯关门动作    public abstract void close();    //电梯运行动作    public abstract void run();    //电梯停止动作    public abstract void stop();}//开启状态public class OpenningState extends LiftState {    //开启当然可以关闭了，我就想测试一下电梯门开关功能    @Override    public void open() {        System.out.println("电梯门开启...");    }    @Override    public void close() {        //状态修改        super.context.setLiftState(Context.closeingState);        //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作        super.context.getLiftState().close();    }    //电梯门不能开着就跑，这里什么也不做    @Override    public void run() {        //do nothing    }    //开门状态已经是停止的了    @Override    public void stop() {        //do nothing    }}//运行状态public class RunningState extends LiftState {    //运行的时候开电梯门？你疯了！电梯不会给你开的    @Override    public void open() {        //do nothing    }    //电梯门关闭？这是肯定了    @Override    public void close() {//虽然可以关门，但这个动作不归我执行        //do nothing    }    //这是在运行状态下要实现的方法    @Override    public void run() {        System.out.println("电梯正在运行...");    }    //这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了    @Override    public void stop() {        super.context.setLiftState(Context.stoppingState);        super.context.stop();    }}//停止状态public class StoppingState extends LiftState {    //停止状态，开门，那是要的！    @Override    public void open() {        //状态修改        super.context.setLiftState(Context.openningState);        //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作        super.context.getLiftState().open();    }    @Override    public void close() {//虽然可以关门，但这个动作不归我执行        //状态修改        super.context.setLiftState(Context.closeingState);        //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作        super.context.getLiftState().close();    }    //停止状态再跑起来，正常的很    @Override    public void run() {        //状态修改        super.context.setLiftState(Context.runningState);        //动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作        super.context.getLiftState().run();    }    //停止状态是怎么发生的呢？当然是停止方法执行了    @Override    public void stop() {        System.out.println("电梯停止了...");    }}//关闭状态public class ClosingState extends LiftState {    @Override    //电梯门关闭，这是关闭状态要实现的动作    public void close() {        System.out.println("电梯门关闭...");    }    //电梯门关了再打开，逗你玩呢，那这个允许呀    @Override    public void open() {        super.context.setLiftState(Context.openningState);        super.context.open();    }    //电梯门关了就跑，这是再正常不过了    @Override    public void run() {        super.context.setLiftState(Context.runningState);        super.context.run();    }    //电梯门关着，我就不按楼层    @Override    public void stop() {        super.context.setLiftState(Context.stoppingState);        super.context.stop();    }}//环境角色public class Context {    //定义出所有的电梯状态    public final static OpenningState openningState = new OpenningState();//开门状态，这时候电梯只能关闭    public final static ClosingState closeingState = new ClosingState();//关闭状态，这时候电梯可以运行、停止和开门    public final static RunningState runningState = new RunningState();//运行状态，这时候电梯只能停止    public final static StoppingState stoppingState = new StoppingState();//停止状态，这时候电梯可以开门、运行    //定义一个当前电梯状态    private LiftState liftState;    public LiftState getLiftState() {        return this.liftState;    }    public void setLiftState(LiftState liftState) {        //当前环境改变        this.liftState = liftState;        //把当前的环境通知到各个实现类中        this.liftState.setContext(this);    }    public void open() {        this.liftState.open();    }    public void close() {        this.liftState.close();    }    public void run() {        this.liftState.run();    }    public void stop() {        this.liftState.stop();    }}//测试类public class Client {    public static void main(String[] args) {        Context context = new Context();        context.setLiftState(new ClosingState());        context.open();        context.close();        context.run();        context.stop();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4-优缺点"><a href="#5-4-优缺点" class="headerlink" title="5.4 优缺点"></a>5.4 优缺点</h3><p><strong>优点：</strong></p><ul><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li></ul><p><strong>缺点：</strong></p><ul><li>状态模式的使用必然会增加系统类和对象的个数。 </li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对”开闭原则”的支持并不太好。</li></ul><h3 id="5-5-使用场景"><a href="#5-5-使用场景" class="headerlink" title="5.5 使用场景"></a>5.5 使用场景</h3><ul><li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li><li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li></ul><h2 id="六、观察者模式"><a href="#六、观察者模式" class="headerlink" title="六、观察者模式"></a>六、观察者模式</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><strong>定义：</strong></p><p>又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><h3 id="6-2-结构"><a href="#6-2-结构" class="headerlink" title="6.2 结构"></a>6.2 结构</h3><p>在观察者模式中有如下角色：</p><ul><li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li><li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li><li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><h3 id="6-3-案例发现"><a href="#6-3-案例发现" class="headerlink" title="6.3 案例发现"></a>6.3 案例发现</h3><p>【例】微信公众号</p><p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p><p>类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152117752.png" alt="观察者模式"></p><p>代码如下：</p><p>定义抽象观察者类，里面定义一个更新的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Observer {    void update(String message);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>定义具体观察者类，微信用户是观察者，里面实现了更新的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class WeixinUser implements Observer {    // 微信用户名    private String name;    public WeixinUser(String name) {        this.name = name;    }    @Override    public void update(String message) {        System.out.println(name + "-" + message);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义抽象主题类，提供了attach、detach、notify三个方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Subject {    //增加订阅者    public void attach(Observer observer);    //删除订阅者    public void detach(Observer observer);        //通知订阅者更新消息    public void notify(String message);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SubscriptionSubject implements Subject {    //储存订阅公众号的微信用户    private List&lt;Observer&gt; weixinUserlist = new ArrayList&lt;Observer&gt;();    @Override    public void attach(Observer observer) {        weixinUserlist.add(observer);    }    @Override    public void detach(Observer observer) {        weixinUserlist.remove(observer);    }    @Override    public void notify(String message) {        for (Observer observer : weixinUserlist) {            observer.update(message);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端程序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Client {    public static void main(String[] args) {        SubscriptionSubject mSubscriptionSubject=new SubscriptionSubject();        //创建微信用户        WeixinUser user1=new WeixinUser("孙悟空");        WeixinUser user2=new WeixinUser("猪悟能");        WeixinUser user3=new WeixinUser("沙悟净");        //订阅公众号        mSubscriptionSubject.attach(user1);        mSubscriptionSubject.attach(user2);        mSubscriptionSubject.attach(user3);        //公众号更新发出消息给订阅的微信用户        mSubscriptionSubject.notify("传智黑马的专栏更新了");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-4-优缺点"><a href="#6-4-优缺点" class="headerlink" title="6.4 优缺点"></a>6.4 优缺点</h3><p><strong>优点：</strong></p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】</li></ul><p><strong>缺点：</strong></p><ul><li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时</li><li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li></ul><h3 id="6-5-使用场景"><a href="#6-5-使用场景" class="headerlink" title="6.5 使用场景"></a>6.5 使用场景</h3><ul><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li></ul><h3 id="6-6-源码解析"><a href="#6-6-源码解析" class="headerlink" title="6.6 源码解析"></a>6.6 源码解析</h3><p>在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</p><p><strong>1，Observable类</strong></p><p>Observable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。</p><ul><li><p>void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。</p></li><li><p>void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。</p></li><li><p>void setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。</p></li></ul><p><strong>2，Observer 接口</strong></p><p>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。</p><p>【例】警察抓小偷</p><p>警察抓小偷也可以使用观察者模式来实现，警察是观察者，小偷是被观察者。代码如下：</p><p>小偷是一个被观察者，所以需要继承Observable类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Thief extends Observable {    private String name;    public Thief(String name) {        this.name = name;    }        public void setName(String name) {        this.name = name;    }    public String getName() {        return name;    }    public void steal() {        System.out.println("小偷：我偷东西了，有没有人来抓我！！！");        super.setChanged(); //changed  = true        super.notifyObservers();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>警察是一个观察者，所以需要让其实现Observer接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Policemen implements Observer {    private String name;    public Policemen(String name) {        this.name = name;    }    public void setName(String name) {        this.name = name;    }    public String getName() {        return name;    }    @Override    public void update(Observable o, Object arg) {        System.out.println("警察：" + ((Thief) o).getName() + "，我已经盯你很久了，你可以保持沉默，但你所说的将成为呈堂证供！！！");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Client {    public static void main(String[] args) {        //创建小偷对象        Thief t = new Thief("隔壁老王");        //创建警察对象        Policemen p = new Policemen("小李");        //让警察盯着小偷        t.addObserver(p);        //小偷偷东西        t.steal();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="七、中介者模式"><a href="#七、中介者模式" class="headerlink" title="七、中介者模式"></a>七、中介者模式</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><p>一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。</p><p>如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152123953.png" alt="image-20200214110924010"></p><p><strong>定义：</strong></p><p>又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p><h3 id="7-2-结构"><a href="#7-2-结构" class="headerlink" title="7.2 结构"></a>7.2 结构</h3><p>中介者模式包含以下主要角色：</p><ul><li><p>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p></li><li><p>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</p></li><li><p>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p></li><li><p>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p></li></ul><h3 id="7-3-案例实现"><a href="#7-3-案例实现" class="headerlink" title="7.3 案例实现"></a>7.3 案例实现</h3><p>【例】租房</p><p>现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者。</p><p>类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152126773.png" alt="中介者模式"></p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//抽象中介者public abstract class Mediator {    //申明一个联络方法    public abstract void constact(String message,Person person);}//抽象同事类public abstract class Person {    protected String name;    protected Mediator mediator;    public Person(String name,Mediator mediator){        this.name = name;        this.mediator = mediator;    }}//具体同事类 房屋拥有者public class HouseOwner extends Person {    public HouseOwner(String name, Mediator mediator) {        super(name, mediator);    }    //与中介者联系    public void constact(String message){        mediator.constact(message, this);    }    //获取信息    public void getMessage(String message){        System.out.println("房主" + name +"获取到的信息：" + message);    }}//具体同事类 承租人public class Tenant extends Person {    public Tenant(String name, Mediator mediator) {        super(name, mediator);    }    //与中介者联系    public void constact(String message){        mediator.constact(message, this);    }    //获取信息    public void getMessage(String message){        System.out.println("租房者" + name +"获取到的信息：" + message);    }}//中介机构public class MediatorStructure extends Mediator {    //首先中介结构必须知道所有房主和租房者的信息    private HouseOwner houseOwner;    private Tenant tenant;    public HouseOwner getHouseOwner() {        return houseOwner;    }    public void setHouseOwner(HouseOwner houseOwner) {        this.houseOwner = houseOwner;    }    public Tenant getTenant() {        return tenant;    }    public void setTenant(Tenant tenant) {        this.tenant = tenant;    }    public void constact(String message, Person person) {        if (person == houseOwner) {          //如果是房主，则租房者获得信息            tenant.getMessage(message);        } else {       //反正则是房主获得信息            houseOwner.getMessage(message);        }    }}//测试类public class Client {    public static void main(String[] args) {        //一个房主、一个租房者、一个中介机构        MediatorStructure mediator = new MediatorStructure();        //房主和租房者只需要知道中介机构即可        HouseOwner houseOwner = new HouseOwner("张三", mediator);        Tenant tenant = new Tenant("李四", mediator);        //中介结构要知道房主和租房者        mediator.setHouseOwner(houseOwner);        mediator.setTenant(tenant);        tenant.constact("需要租三室的房子");        houseOwner.constact("我这有三室的房子，你需要租吗？");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-4-优缺点"><a href="#7-4-优缺点" class="headerlink" title="7.4 优缺点"></a>7.4 优缺点</h3><p><strong>优点：</strong></p><ul><li><p>松散耦合</p><p>中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。</p></li><li><p>集中控制交互</p><p>多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。</p></li><li><p>一对多关联转变为一对一的关联</p><p>没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。</p></li></ul><p><strong>缺点：</strong></p><p>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p><h3 id="6-7-5-使用场景"><a href="#6-7-5-使用场景" class="headerlink" title="6.7.5 使用场景"></a>6.7.5 使用场景</h3><ul><li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li><li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li></ul><h2 id="八、迭代器模式"><a href="#八、迭代器模式" class="headerlink" title="八、迭代器模式"></a>八、迭代器模式</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8.1 概述"></a>8.1 概述</h3><p><strong>定义：</strong></p><p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 </p><h3 id="8-2-结构"><a href="#8-2-结构" class="headerlink" title="8.2 结构"></a>8.2 结构</h3><p>迭代器模式主要包含以下角色：</p><ul><li><p>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。</p></li><li><p>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</p></li><li><p>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。</p></li><li><p>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</p></li></ul><h3 id="8-3-案例发现"><a href="#8-3-案例发现" class="headerlink" title="8.3 案例发现"></a>8.3 案例发现</h3><p>【例】定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现，涉及到的类如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152134028.png" alt="迭代器模式"></p><p>代码如下：</p><p>定义迭代器接口，声明hasNext、next方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface StudentIterator {    boolean hasNext();    Student next();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>定义具体的迭代器类，重写所有的抽象方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StudentIteratorImpl implements StudentIterator {    private List&lt;Student&gt; list;    private int position = 0;    public StudentIteratorImpl(List&lt;Student&gt; list) {        this.list = list;    }    @Override    public boolean hasNext() {        return position &lt; list.size();    }    @Override    public Student next() {        Student currentStudent = list.get(position);        position ++;        return currentStudent;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface StudentAggregate {    void addStudent(Student student);    void removeStudent(Student student);    StudentIterator getStudentIterator();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义具体的容器类，重写所有的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StudentAggregateImpl implements StudentAggregate {    private List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();  // 学生列表    @Override    public void addStudent(Student student) {        this.list.add(student);    }    @Override    public void removeStudent(Student student) {        this.list.remove(student);    }    @Override    public StudentIterator getStudentIterator() {        return new StudentIteratorImpl(list);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="8-4-优缺点"><a href="#8-4-优缺点" class="headerlink" title="8.4 优缺点"></a>8.4 优缺点</h3><p><strong>优点：</strong></p><ul><li>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li><li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足 “开闭原则” 的要求。</li></ul><p><strong>缺点：</strong></p><p>增加了类的个数，这在一定程度上增加了系统的复杂性。</p><h3 id="8-5-使用场景"><a href="#8-5-使用场景" class="headerlink" title="8.5 使用场景"></a>8.5 使用场景</h3><ul><li>当需要为聚合对象提供多种遍历方式时。</li><li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li><li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li></ul><h3 id="8-6-JDK-源码解析"><a href="#8-6-JDK-源码解析" class="headerlink" title="8.6 JDK 源码解析"></a>8.6 JDK 源码解析</h3><p>迭代器模式在JAVA的很多集合类中被广泛应用，接下来看看JAVA源码中是如何使用迭代器模式的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();Iterator&lt;String&gt; iterator = list.iterator(); //list.iterator()方法返回的肯定是Iterator接口的子实现类对象while (iterator.hasNext()) {    System.out.println(iterator.next());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>看完这段代码是不是很熟悉，与我们上面代码基本类似。单列集合都使用到了迭代器，我们以ArrayList举例来说明</p><ul><li>List：抽象聚合类</li><li>ArrayList：具体的聚合类</li><li>Iterator：抽象迭代器</li><li>list.iterator()：返回的是实现了 <code>Iterator</code> 接口的具体迭代器对象</li></ul><p>具体的来看看 ArrayList的代码实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {        public Iterator&lt;E&gt; iterator() {        return new Itr();    }        private class Itr implements Iterator&lt;E&gt; {        int cursor;       // 下一个要返回元素的索引        int lastRet = -1; // 上一个返回元素的索引        int expectedModCount = modCount;        Itr() {}        //判断是否还有元素        public boolean hasNext() {            return cursor != size;        }        //获取下一个元素        public E next() {            checkForComodification();            int i = cursor;            if (i &gt;= size)                throw new NoSuchElementException();            Object[] elementData = ArrayList.this.elementData;            if (i &gt;= elementData.length)                throw new ConcurrentModificationException();            cursor = i + 1;            return (E) elementData[lastRet = i];        }        ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这部分代码还是比较简单，大致就是在 <code>iterator</code> 方法中返回了一个实例化的 <code>Iterator</code> 对象。Itr是一个内部类，它实现了 <code>Iterator</code> 接口并重写了其中的抽象方法。</p><blockquote><p>注意： </p><p>​当我们在使用JAVA开发的时候，想使用迭代器模式的话，只要让我们自己定义的容器类实现<code>java.util.Iterable</code>并实现其中的iterator()方法使其返回一个 <code>java.util.Iterator</code> 的实现类就可以了。</p></blockquote><h2 id="九、访问者模式"><a href="#九、访问者模式" class="headerlink" title="九、访问者模式"></a>九、访问者模式</h2><h3 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h3><p><strong>定义：</strong></p><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p><h3 id="9-2-结构"><a href="#9-2-结构" class="headerlink" title="9.2 结构"></a>9.2 结构</h3><p>访问者模式包含以下主要角色:</p><ul><li>抽象访问者（Visitor）角色：定义了对每一个元素<code>（Element）</code>访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。</li><li>具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。</li><li>抽象元素（Element）角色：定义了一个接受访问者的方法（<code>accept</code>），其意义是指，每一个元素都要可以被访问者访问。</li><li>具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li><li>对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（<code>Element</code>），并且可以迭代这些元素，供访问者访问。</li></ul><h3 id="9-3-案例实现"><a href="#9-3-案例实现" class="headerlink" title="9.3 案例实现"></a>9.3 案例实现</h3><p>【例】给宠物喂食</p><p>宠物分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。</p><ul><li>访问者角色：给宠物喂食的人</li><li>具体访问者角色：主人、其他人</li><li>抽象元素角色：动物抽象类</li><li>具体元素角色：宠物狗、宠物猫</li><li>结构对象角色：主人家</li></ul><p>类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152140883.png" alt="访问者模式"></p><p>代码如下：</p><p>创建抽象访问者接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Person {    void feed(Cat cat);    void feed(Dog dog);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建不同的具体访问者角色（主人和其他人），都需要实现 <code>Person</code>接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Owner implements Person {    @Override    public void feed(Cat cat) {        System.out.println("主人喂食猫");    }    @Override    public void feed(Dog dog) {        System.out.println("主人喂食狗");    }}public class Someone implements Person {    @Override    public void feed(Cat cat) {        System.out.println("其他人喂食猫");    }    @Override    public void feed(Dog dog) {        System.out.println("其他人喂食狗");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义抽象节点 – 宠物</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Animal {    void accept(Person person);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>定义实现<code>Animal</code>接口的 具体节点（元素）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Dog implements Animal {    @Override    public void accept(Person person) {        person.feed(this);        System.out.println("好好吃，汪汪汪！！！");    }}public class Cat implements Animal {    @Override    public void accept(Person person) {        person.feed(this);        System.out.println("好好吃，喵喵喵！！！");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义对象结构，此案例中就是主人的家</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Home {    private List&lt;Animal&gt; nodeList = new ArrayList&lt;Animal&gt;();    public void action(Person person) {        for (Animal node : nodeList) {            node.accept(person);        }    }    //添加操作    public void add(Animal animal) {        nodeList.add(animal);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Client {    public static void main(String[] args) {        Home home = new Home();        home.add(new Dog());        home.add(new Cat());        Owner owner = new Owner();        home.action(owner);        Someone someone = new Someone();        home.action(someone);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="9-4-优缺点"><a href="#9-4-优缺点" class="headerlink" title="9.4 优缺点"></a>9.4 优缺点</h3><p><strong>优点：</strong></p><ul><li><p>扩展性好</p><p>在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</p></li><li><p>复用性好</p><p>通过访问者来定义整个对象结构通用的功能，从而提高复用程度。</p></li><li><p>分离无关行为</p><p>通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。</p></li></ul><p><strong>缺点：</strong></p><ul><li><p>对象结构变化很困难</p><p>在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</p></li><li><p>违反了依赖倒置原则</p><p>访问者模式依赖了具体类，而没有依赖抽象类。</p></li></ul><h3 id="9-5-使用场景"><a href="#9-5-使用场景" class="headerlink" title="9.5  使用场景"></a>9.5  使用场景</h3><ul><li><p>对象结构相对稳定，但其操作算法经常变化的程序。</p></li><li><p>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</p></li></ul><h3 id="9-6-扩展"><a href="#9-6-扩展" class="headerlink" title="9.6 扩展"></a>9.6 扩展</h3><p>访问者模式用到了一种双分派的技术。</p><h4 id="9-6-1-分派"><a href="#9-6-1-分派" class="headerlink" title="9.6.1 分派"></a>9.6.1 分派</h4><p>变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。比如 <code>Map map = new HashMap()</code> ，map变量的静态类型是 <code>Map</code> ，实际类型是 <code>HashMap</code> 。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。</p><p><strong>静态分派(Static Dispatch)</strong> 发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。</p><p><strong>动态分派(Dynamic Dispatch)</strong> 发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。</p><h4 id="9-6-2-动态分派："><a href="#9-6-2-动态分派：" class="headerlink" title="9.6.2 动态分派："></a>9.6.2 动态分派：</h4><p>通过方法的重写支持动态分派。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Animal {    public void execute() {        System.out.println("Animal");    }}public class Dog extends Animal {    @Override    public void execute() {        System.out.println("dog");    }}public class Cat extends Animal {     @Override    public void execute() {        System.out.println("cat");    }}public class Client {   public static void main(String[] args) {        Animal a = new Dog();        a.execute();                Animal a1 = new Cat();        a1.execute();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码的结果大家应该直接可以说出来，这不就是多态吗！运行执行的是子类中的方法。</p><p>Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。</p><h4 id="9-6-3-静态分派："><a href="#9-6-3-静态分派：" class="headerlink" title="9.6.3 静态分派："></a>9.6.3 静态分派：</h4><p>通过方法重载支持静态分派。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Animal {}public class Dog extends Animal {}public class Cat extends Animal {}public class Execute {    public void execute(Animal a) {        System.out.println("Animal");    }    public void execute(Dog d) {        System.out.println("dog");    }    public void execute(Cat c) {        System.out.println("cat");    }}public class Client {    public static void main(String[] args) {        Animal a = new Animal();        Animal a1 = new Dog();        Animal a2 = new Cat();        Execute exe = new Execute();        exe.execute(a);        exe.execute(a1);        exe.execute(a2);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152146143.png" alt="image-20200214215446638"></p><p>这个结果可能出乎一些人的意料了，为什么呢？</p><p><strong>重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。</strong></p><h4 id="9-6-4-双分派"><a href="#9-6-4-双分派" class="headerlink" title="9.6.4 双分派"></a>9.6.4 双分派</h4><p>所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Animal {    public void accept(Execute exe) {        exe.execute(this);    }}public class Dog extends Animal {    public void accept(Execute exe) {        exe.execute(this);    }}public class Cat extends Animal {    public void accept(Execute exe) {        exe.execute(this);    }}public class Execute {    public void execute(Animal a) {        System.out.println("animal");    }    public void execute(Dog d) {        System.out.println("dog");    }    public void execute(Cat c) {        System.out.println("cat");    }}public class Client {    public static void main(String[] args) {        Animal a = new Animal();        Animal d = new Dog();        Animal c = new Cat();        Execute exe = new Execute();        a.accept(exe);        d.accept(exe);        c.accept(exe);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在上面代码中，客户端将Execute对象做为参数传递给Animal类型的变量调用的方法，这里完成第一次分派，这里是方法重写，所以是动态分派，也就是执行实际类型中的方法，同时也<code>将自己this作为参数传递进去，这里就完成了第二次分派</code>，这里的Execute类中有多个重载的方法，而传递进行的是this，就是具体的实际类型的对象。</p><p>说到这里，我们已经明白双分派是怎么回事了，但是它有什么效果呢？就是可以实现方法的动态绑定，我们可以对上面的程序进行修改。</p><p>运行结果如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152148344.png" alt="image-20200426233931693"></p><p><strong>双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动态的，所以重载就是动态的了。</strong></p><h2 id="十、备忘录模式"><a href="#十、备忘录模式" class="headerlink" title="十、备忘录模式"></a>十、备忘录模式</h2><h3 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h3><p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如 Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 浏览器 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p><p><strong>定义：</strong></p><p>又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</p><h3 id="10-2-结构"><a href="#10-2-结构" class="headerlink" title="10.2 结构"></a>10.2 结构</h3><p>备忘录模式的主要角色如下：</p><ul><li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li><li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li><li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li></ul><blockquote><p>备忘录有两个等效的接口：</p><ul><li><strong>窄接口</strong>：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。</li><li><strong>宽接口</strong>：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</li></ul></blockquote><h3 id="10-3-案例实现"><a href="#10-3-案例实现" class="headerlink" title="10.3 案例实现"></a>10.3 案例实现</h3><p>【例】游戏挑战BOSS</p><p>游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。</p><p>要实现上述案例，有两种方式：</p><ul><li>“白箱”备忘录模式</li><li>“黑箱”备忘录模式</li></ul><h4 id="10-3-1-白箱备忘录模式"><a href="#10-3-1-白箱备忘录模式" class="headerlink" title="10.3.1 白箱备忘录模式"></a>10.3.1 白箱备忘录模式</h4><p>备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152153232.png" alt="白箱备忘录模式"></p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//游戏角色类public class GameRole {    private int vit; //生命力    private int atk; //攻击力    private int def; //防御力    //初始化状态    public void initState() {        this.vit = 100;        this.atk = 100;        this.def = 100;    }    //战斗    public void fight() {        this.vit = 0;        this.atk = 0;        this.def = 0;    }    //保存角色状态    public RoleStateMemento saveState() {        return new RoleStateMemento(vit, atk, def);    }    //回复角色状态    public void recoverState(RoleStateMemento roleStateMemento) {        this.vit = roleStateMemento.getVit();        this.atk = roleStateMemento.getAtk();        this.def = roleStateMemento.getDef();    }    public void stateDisplay() {        System.out.println("角色生命力：" + vit);        System.out.println("角色攻击力：" + atk);        System.out.println("角色防御力：" + def);    }    public int getVit() {        return vit;    }    public void setVit(int vit) {        this.vit = vit;    }    public int getAtk() {        return atk;    }    public void setAtk(int atk) {        this.atk = atk;    }    public int getDef() {        return def;    }    public void setDef(int def) {        this.def = def;    }}//游戏状态存储类(备忘录类)public class RoleStateMemento {    private int vit;    private int atk;    private int def;    public RoleStateMemento(int vit, int atk, int def) {        this.vit = vit;        this.atk = atk;        this.def = def;    }    public int getVit() {        return vit;    }    public void setVit(int vit) {        this.vit = vit;    }    public int getAtk() {        return atk;    }    public void setAtk(int atk) {        this.atk = atk;    }    public int getDef() {        return def;    }    public void setDef(int def) {        this.def = def;    }}//角色状态管理者类public class RoleStateCaretaker {    private RoleStateMemento roleStateMemento;    public RoleStateMemento getRoleStateMemento() {        return roleStateMemento;    }    public void setRoleStateMemento(RoleStateMemento roleStateMemento) {        this.roleStateMemento = roleStateMemento;    }}//测试类public class Client {    public static void main(String[] args) {        System.out.println("------------大战Boss前------------");        //大战Boss前        GameRole gameRole = new GameRole();        gameRole.initState();        gameRole.stateDisplay();        //保存进度        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());        System.out.println("------------大战Boss后------------");        //大战Boss时，损耗严重        gameRole.fight();        gameRole.stateDisplay();        System.out.println("------------恢复之前状态------------");        //恢复之前状态        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());        gameRole.stateDisplay();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>分析：白箱备忘录模式是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。</p></blockquote><h4 id="10-3-2-黑箱备忘录模式"><a href="#10-3-2-黑箱备忘录模式" class="headerlink" title="10.3.2 黑箱备忘录模式"></a>10.3.2 黑箱备忘录模式</h4><p>备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将<strong>备忘录类</strong>设计成<strong>发起人类</strong>的内部成员类。</p><p>将 <code>RoleStateMemento</code> 设为 <code>GameRole</code> 的内部类，从而将 <code>RoleStateMemento</code> 对象封装在 <code>GameRole</code> 里面；在外面提供一个标识接口 <code>Memento</code> 给 <code>RoleStateCaretaker</code> 及其他对象使用。这样 <code>GameRole</code> 类看到的是 <code>RoleStateMemento</code> 所有的接口，而<code>RoleStateCaretaker</code>  及其他对象看到的仅仅是标识接口 <code>Memento</code> 所暴露出来的接口，从而维护了封装型。类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152217228.png" alt="黑箱备忘录模式"></p><p>代码如下：</p><p>窄接口<code>Memento</code>，这是一个标识接口，因此没有定义出任何的方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Memento {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>定义发起人类 <code>GameRole</code>，并在内部定义备忘录内部类 <code>RoleStateMemento</code>（该内部类设置为私有的）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/游戏角色类public class GameRole {    private int vit; //生命力    private int atk; //攻击力    private int def; //防御力    //初始化状态    public void initState() {        this.vit = 100;        this.atk = 100;        this.def = 100;    }    //战斗    public void fight() {        this.vit = 0;        this.atk = 0;        this.def = 0;    }    //保存角色状态    public Memento saveState() {        return new RoleStateMemento(vit, atk, def);    }    //回复角色状态    public void recoverState(Memento memento) {        RoleStateMemento roleStateMemento = (RoleStateMemento) memento;        this.vit = roleStateMemento.getVit();        this.atk = roleStateMemento.getAtk();        this.def = roleStateMemento.getDef();    }    public void stateDisplay() {        System.out.println("角色生命力：" + vit);        System.out.println("角色攻击力：" + atk);        System.out.println("角色防御力：" + def);    }    public int getVit() {        return vit;    }    public void setVit(int vit) {        this.vit = vit;    }    public int getAtk() {        return atk;    }    public void setAtk(int atk) {        this.atk = atk;    }    public int getDef() {        return def;    }    public void setDef(int def) {        this.def = def;    }    private class RoleStateMemento implements Memento {        private int vit;        private int atk;        private int def;        public RoleStateMemento(int vit, int atk, int def) {            this.vit = vit;            this.atk = atk;            this.def = def;        }        public int getVit() {            return vit;        }        public void setVit(int vit) {            this.vit = vit;        }        public int getAtk() {            return atk;        }        public void setAtk(int atk) {            this.atk = atk;        }        public int getDef() {            return def;        }        public void setDef(int def) {            this.def = def;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>负责人角色类 <code>RoleStateCaretaker</code> 能够得到的备忘录对象是以 <code>Memento</code> 为接口的，由于这个接口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//角色状态管理者类public class RoleStateCaretaker {    private Memento memento;    public Memento getMemento() {        return memento;    }    public void setMemento(Memento memento) {        this.memento = memento;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Client {    public static void main(String[] args) {        System.out.println("------------大战Boss前------------");        //大战Boss前        GameRole gameRole = new GameRole();        gameRole.initState();        gameRole.stateDisplay();        //保存进度        RoleStateCaretaker roleStateCaretaker = new RoleStateCaretaker();        roleStateCaretaker.setMemento(gameRole.saveState());                System.out.println("------------大战Boss后------------");        //大战Boss时，损耗严重        gameRole.fight();        gameRole.stateDisplay();        System.out.println("------------恢复之前状态------------");        //恢复之前状态        gameRole.recoverState(roleStateCaretaker.getMemento());        gameRole.stateDisplay();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="10-4-优缺点"><a href="#10-4-优缺点" class="headerlink" title="10.4 优缺点"></a>10.4 优缺点</h3><p><strong>优点：</strong></p><ul><li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li><li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li><li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li></ul><p><strong>缺点：</strong></p><ul><li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li></ul><h3 id="10-5-使用场景"><a href="#10-5-使用场景" class="headerlink" title="10.5 使用场景"></a>10.5 使用场景</h3><ul><li><p>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</p></li><li><p>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</p></li></ul><h2 id="十一、解释器模式"><a href="#十一、解释器模式" class="headerlink" title="十一、解释器模式"></a>十一、解释器模式</h2><h3 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152220984.png" alt="image-20200215220322641"></p><p>如上图，设计一个软件用来进行加减计算。我们第一想法就是使用工具类，提供对应的加法和减法的工具方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//用于两个整数相加public static int add(int a,int b){    return a + b;}//用于两个整数相加public static int add(int a,int b,int c){    return a + b + c;}//用于n个整数相加public static int add(Integer ... arr) {    int sum = 0;    for (Integer i : arr) {        sum += i;    }    return sum;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的形式比较单一、有限，如果形式变化非常多，这就不符合要求，因为加法和减法运算，两个运算符与数值可以有无限种组合方式。比如 1+2+3+4+5、1+2+3-4等等。   </p><p>显然，现在需要一种翻译识别机器，能够解析由数字以及 + - 符号构成的合法的运算序列。如果把运算符和数字都看作节点的话，能够逐个节点的进行读取解析运算，这就是解释器模式的思维。</p><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p><p>在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2” 就是这种语言的句子。</p><p>解释器就是要解析出来语句的含义。但是如何描述规则呢？</p><h4 id="2-文法（语法）规则"><a href="#2-文法（语法）规则" class="headerlink" title="2. 文法（语法）规则"></a>2. 文法（语法）规则</h4><p>文法是用于描述语言的语法结构的形式规则。</p><pre class="line-numbers language-none"><code class="language-none">expression ::= value | plus | minusplus ::= expression ‘+’ expression   minus ::= expression ‘-’ expression  value ::= integer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意： 这里的符号“::=”表示“定义为”的意思，竖线 | 表示或，左右的其中一个，引号内为字符本身，引号外为语法。</p></blockquote><p>上面规则描述为 ：</p><p>表达式可以是一个值，也可以是plus或者minus运算，而plus和minus又是由表达式结合运算符构成，值的类型为整型数。</p><h4 id="3-抽象语法树"><a href="#3-抽象语法树" class="headerlink" title="3. 抽象语法树"></a>3. 抽象语法树</h4><p>在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p><p>用树形来表示符合文法规则的句子。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152226770.png" alt="image-20200215225227616"></p><h3 id="11-2-结构"><a href="#11-2-结构" class="headerlink" title="11.2 结构"></a>11.2 结构</h3><p>解释器模式包含以下主要角色。</p><ul><li><p>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</p></li><li><p>终结符表达式（Terminal  Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</p></li><li><p>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</p></li><li><p>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</p></li><li><p>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</p></li></ul><h3 id="11-3-案例实现"><a href="#11-3-案例实现" class="headerlink" title="11.3 案例实现"></a>11.3 案例实现</h3><p>【例】设计实现加减法的软件</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152229660.png" alt="解释器模式"></p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//抽象角色AbstractExpressionpublic abstract class AbstractExpression {    public abstract int interpret(Context context);}//终结符表达式角色public class Value extends AbstractExpression {    private int value;    public Value(int value) {        this.value = value;    }    @Override    public int interpret(Context context) {        return value;    }    @Override    public String toString() {        return new Integer(value).toString();    }}//非终结符表达式角色  加法表达式public class Plus extends AbstractExpression {    private AbstractExpression left;    private AbstractExpression right;    public Plus(AbstractExpression left, AbstractExpression right) {        this.left = left;        this.right = right;    }    @Override    public int interpret(Context context) {        return left.interpret(context) + right.interpret(context);    }    @Override    public String toString() {        return "(" + left.toString() + " + " + right.toString() + ")";    }}///非终结符表达式角色 减法表达式public class Minus extends AbstractExpression {    private AbstractExpression left;    private AbstractExpression right;    public Minus(AbstractExpression left, AbstractExpression right) {        this.left = left;        this.right = right;    }    @Override    public int interpret(Context context) {        return left.interpret(context) - right.interpret(context);    }    @Override    public String toString() {        return "(" + left.toString() + " - " + right.toString() + ")";    }}//终结符表达式角色 变量表达式public class Variable extends AbstractExpression {    private String name;    public Variable(String name) {        this.name = name;    }    @Override    public int interpret(Context ctx) {        return ctx.getValue(this);    }    @Override    public String toString() {        return name;    }}//环境类public class Context {    private Map&lt;Variable, Integer&gt; map = new HashMap&lt;Variable, Integer&gt;();    public void assign(Variable var, Integer value) {        map.put(var, value);    }    public int getValue(Variable var) {        Integer value = map.get(var);        return value;    }}//测试类public class Client {    public static void main(String[] args) {        Context context = new Context();        Variable a = new Variable("a");        Variable b = new Variable("b");        Variable c = new Variable("c");        Variable d = new Variable("d");        Variable e = new Variable("e");        //Value v = new Value(1);        context.assign(a, 1);        context.assign(b, 2);        context.assign(c, 3);        context.assign(d, 4);        context.assign(e, 5);        AbstractExpression expression = new Minus(new Plus(new Plus(new Plus(a, b), c), d), e);        System.out.println(expression + "= " + expression.interpret(context));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="11-4-优缺点"><a href="#11-4-优缺点" class="headerlink" title="11.4 优缺点"></a>11.4 优缺点</h3><p><strong>优点：</strong></p><ul><li><p>易于改变和扩展文法。</p><p>由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</p></li><li><p>实现文法较为容易。</p><p>在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。</p></li><li><p>增加新的解释表达式较为方便。</p><p>如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合 “开闭原则”。</p></li></ul><p><strong>缺点：</strong></p><ul><li><p>对于复杂文法难以维护。</p><p>在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护。</p></li></ul><ul><li><p>执行效率较低。</p><p>由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。</p></li></ul><h3 id="11-5-使用场景"><a href="#11-5-使用场景" class="headerlink" title="11.5 使用场景"></a>11.5 使用场景</h3><ul><li><p>当语言的文法较为简单，且执行效率不是关键问题时。</p></li><li><p>当问题重复出现，且可以用一种简单的语言来进行表达时。</p></li><li><p>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传的实现</title>
      <link href="/tur-study/2023/05/02/SpringBoot/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/tur-study/2023/05/02/SpringBoot/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以前端用户上传图片为例</p><p>上传方式有：</p><ul><li>MinIO</li><li>阿里云</li></ul></blockquote><p>步骤如下：</p><ol><li>定义文件上传策略 <code>FileUploadStrategy</code><ul><li>上传图片</li><li>删除图片</li></ul></li><li>不同文件上传方式分别实现 <code>FileUploadStrategy</code></li><li>定义上传方式枚举<ul><li>MinIO：1</li><li>阿里云：2</li></ul></li><li>定义接口，以便前端调用</li><li>实现上传服务<ul><li>从数据库中取出上传方式（1/2）</li><li>与枚举匹配</li><li>调用 map ，map中封装不同的上传方式，键为上传类型</li><li>执行上传</li></ul></li></ol><h4 id="1-文件上传策略"><a href="#1-文件上传策略" class="headerlink" title="1. 文件上传策略"></a>1. 文件上传策略</h4>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 分布式缓存</title>
      <link href="/tur-study/2023/05/02/Redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/"/>
      <url>/tur-study/2023/05/02/Redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要介绍如何基于 Redis 集群解决单机 Redis 存在的问题</p></blockquote><p>单机 Redis 存在的四大问题：</p><p><img src="D:\百度网盘\Java资料\第4阶段—中间键&amp;服务框架\7.2022版Redis入门到精通\Redis-笔记资料\03-高级篇\讲义\01-分布式缓存\assets\image-20210725144240631.png" alt=" "></p><h2 id="一、Redis-持久化"><a href="#一、Redis-持久化" class="headerlink" title="一、Redis 持久化"></a>一、Redis 持久化</h2><p>Redis 有两种持久化方案：</p><ul><li>RDB 持久化（默认）</li><li>AOF 持久化</li></ul><h3 id="1-1-RDB-持久化"><a href="#1-1-RDB-持久化" class="headerlink" title="1.1 RDB 持久化"></a>1.1 RDB 持久化</h3><p>RDB，Redis Database Backup file（Redis 数据备份文件），也叫 Redis 数据快照。简单来说就是将内存中的所有数据都记录到磁盘中，当 Redis 实例故障后，从磁盘中读取快照文件，恢复数据。快照文件称之为 RDB 文件，默认保存在当前运行目录</p><h4 id="1-1-1-执行时机"><a href="#1-1-1-执行时机" class="headerlink" title="1.1.1 执行时机"></a>1.1.1 执行时机</h4><p>RDB 持久化在四种情况下会执行：</p><ul><li>执行 save 命令</li><li>执行 bgsave 命令</li><li>Redis 停机时</li><li>触发 RDB 条件时</li></ul><h5 id="1-save-命令"><a href="#1-save-命令" class="headerlink" title="1. save 命令"></a>1. save 命令</h5><p><img src="/tur-study/../../../../../AppData/Roaming/Typora/typora-user-images/image-20230513211450754.png" alt="RDB持久化-save命令"></p><p>save 命令会导致主进程执行 RDB，这个过程中其他命令都会被阻塞，直到 save 命令完成，只有在数据迁移时可能用到</p><h5 id="2-bgsave-命令"><a href="#2-bgsave-命令" class="headerlink" title="2. bgsave 命令"></a>2. bgsave 命令</h5><p><img src="/tur-study/../../../../../AppData/Roaming/Typora/typora-user-images/image-20230513211704071.png" alt="image-20230513211704071"></p><p>bgsave 命令执行时会开启独立进程完成 RDB，主进程可以持续处理用户请求，不受影响。即 bgsave 异步执行 RDB</p><h5 id="3-Redis-停机时"><a href="#3-Redis-停机时" class="headerlink" title="3. Redis 停机时"></a>3. Redis 停机时</h5><p>Redis停机时会执行一次save命令，实现RDB持久化。</p><h5 id="4-触发-RDB-条件"><a href="#4-触发-RDB-条件" class="headerlink" title="4. 触发 RDB 条件"></a>4. 触发 RDB 条件</h5><p>Redis 内部有触发 RDB 的机制，可以在 redis.conf 中找到，格式如下：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save "" 则表示禁用RDBsave 900 1  save 300 10  save 60 10000 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>RDB的其它配置也可以在redis.conf文件中设置：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱rdbcompression yes# RDB文件名称dbfilename dump.rdb  # 文件保存的路径目录dir ./ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-2-RDB-原理"><a href="#1-1-2-RDB-原理" class="headerlink" title="1.1.2 RDB 原理"></a>1.1.2 RDB 原理</h4><p>bgsave 开始时会 fork 主进程得到子进程，子进程共享主进程的内存数据，完成 fork 后读取内存数据并写入新的 RDB 文件，新的 RDB 文件代替旧的 RDB 文件</p><p>fork 采用的是 copt-on-write 技术：</p><ul><li>当主进程执行读写操作时，访问共享内存</li><li>当准成执行写操作时，则会拷贝一份数据，执行写操作</li></ul><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725151319695.png" alt="image-20210725151319695"></p><h4 id="1-1-3-RDB-的缺点"><a href="#1-1-3-RDB-的缺点" class="headerlink" title="1.1.3 RDB 的缺点"></a>1.1.3 RDB 的缺点</h4><ul><li>RDB 执行间隔时间长，两次 RDB 之间写入数据有丢失的风险</li><li>fork 子进程、压缩、写 RDB 文件都比较好使</li></ul><p>一旦redis非法关闭，那么会丢失最后一次持久化之后的数据。</p><p>如果数据不重要，则不必要关心。 如果数据不能允许丢失，那么要使用 aof 方式</p><h3 id="1-2-AOF-持久化"><a href="#1-2-AOF-持久化" class="headerlink" title="1.2 AOF 持久化"></a>1.2 AOF 持久化</h3><h4 id="1-2-1-AOF-原理"><a href="#1-2-1-AOF-原理" class="headerlink" title="1.2.1 AOF 原理"></a>1.2.1 AOF 原理</h4><p>AOF，Append Only File（追加文件）。Redis 处理的每一个写命令都会记录在 AOF 文件，可以看做是命令日志文件</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725151543640.png" alt="image-20210725151543640"></p><h4 id="1-2-2-AOF-配置"><a href="#1-2-2-AOF-配置" class="headerlink" title="1.2.2 AOF 配置"></a>1.2.2 AOF 配置</h4><p>AOF 默认是<strong>关闭</strong>的，需要修改 <code>redis.conf</code> 配置文件来开启 AOF</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 是否开启AOF功能，默认是noappendonly yes# AOF文件的名称appendfilename "appendonly.aof"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>AOF的命令记录的频率也可以通过 <code>redis.conf</code> 文件来配：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 表示每执行一次写命令，立即记录到AOF文件appendfsync always # 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案appendfsync everysec # 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘appendfsync no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>三种策略对比：</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725151654046.png" alt="image-20210725151654046"></p><h4 id="1-2-3-AOF-文件重写"><a href="#1-2-3-AOF-文件重写" class="headerlink" title="1.2.3 AOF 文件重写"></a>1.2.3 AOF 文件重写</h4><p>因为是记录命令，AOF 文件会比 RDB 文件大的多。而且 AOF 会记录对同一个 key 的多次写操作，但只有最后一次写操作才有意义。通过执行<code>bgrewriteaof</code>命令，可以让 AOF 文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725151729118.png" alt="image-20210725151729118"></p><p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># AOF文件比上次文件 增长超过多少百分比则触发重写auto-aof-rewrite-percentage 100# AOF文件体积最小多大以上才触发重写 auto-aof-rewrite-min-size 64mb <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-RDB-与-AOF-对比"><a href="#1-3-RDB-与-AOF-对比" class="headerlink" title="1.3 RDB 与 AOF 对比"></a>1.3 RDB 与 AOF 对比</h3><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725151940515.png" alt="image-20210725151940515"></p><h2 id="二、Redis-主从"><a href="#二、Redis-主从" class="headerlink" title="二、Redis 主从"></a>二、Redis 主从</h2><h3 id="2-1-简述"><a href="#2-1-简述" class="headerlink" title="2.1 简述"></a>2.1 简述</h3><p>持久化保证了即使redis服务重启也不会丢失数据，因为redis服务重启后会将硬盘上持久化的数据恢复到内存中，但是当redis服务器的硬盘损坏了可能会导致数据丢失，如果通过redis的主从复制机制就可以避免这种单点故障，如下图：</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725152037611.png" alt="image-20210725152037611"></p><p>说明：</p><ul><li>主redis中的数据有两个副本（replication）即从redis1和从redis2，即使一台redis服务器宕机其它两台redis服务也可以继续提供服务。</li><li>主redis中的数据和从redis上的数据保持实时同步，当主redis写入数据时通过主从复制机制会复制到两个从redis服务上。</li><li>只有一个主redis，可以有多个从redis。</li><li>主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求</li><li>一个redis可以即是主又是从</li></ul><h3 id="2-2-搭建主从架构"><a href="#2-2-搭建主从架构" class="headerlink" title="2.2 搭建主从架构"></a>2.2 搭建主从架构</h3><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。架构图如上</p><p>示例如下：</p><ol><li><p>开启三个不同端口的 Redis 实例。端口为：7001（master）,7002,7003</p></li><li><p>开启主从关系：</p></li></ol><p>开启主从关系有临时和永久两种模式</p><ul><li><p>临时：执行 replicaof 命令</p></li><li><p>永久：修改配置文件 <code>replicaof &lt;masterip&gt; &lt;masterport&gt;</code></p></li></ul><p>通过redis-cli命令连接7002，执行下面命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 连接 7002redis-cli -p 7002# 执行slaveofslaveof 192.168.150.101 7001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>通过redis-cli命令连接7003，执行下面命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 连接 7003redis-cli -p 7003# 执行slaveofslaveof 192.168.150.101 7001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>然后连接 7001节点，查看集群状态：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 连接 7001redis-cli -p 7001# 查看状态info replication<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>结果：</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/资料/assets/image-20210630201258802.png" alt="image-20210630201258802"></p><p>测试：</p><p>执行下列操作以测试：</p><ul><li><p>利用redis-cli连接7001，执行<code>set num 123</code></p></li><li><p>利用redis-cli连接7002，执行<code>get num</code>，再执行<code>set num 666</code></p></li><li><p>利用redis-cli连接7003，执行<code>get num</code>，再执行<code>set num 888</code></p></li></ul><p>可以发现，只有在7001这个master节点上可以执行写操作，7002和7003这  两个slave节点只能执行读操作。</p><h3 id="2-3-主从数据同步原理"><a href="#2-3-主从数据同步原理" class="headerlink" title="2.3 主从数据同步原理"></a>2.3 主从数据同步原理</h3><h4 id="2-3-1-全量同步"><a href="#2-3-1-全量同步" class="headerlink" title="2.3.1 全量同步"></a>2.3.1 全量同步</h4><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725152222497.png" alt="image-20210725152222497"></p><p>这里有一个问题，master如何得知salve是第一次来连接呢？？</p><p>有几个概念，可以作为判断依据：</p><ul><li><code>Replication Id</code>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li><li><code>offset</code>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li></ul><p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p><p>因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p><p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p><p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p><p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725152700914.png" alt="image-20210725152700914"></p><p>完整流程描述：</p><ul><li>slave节点请求增量同步</li><li>master节点判断replid，发现不一致，拒绝增量同步</li><li>master将完整内存数据生成RDB，发送RDB到slave</li><li>slave清空本地数据，加载master的RDB</li><li>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</li><li>slave执行接收到的命令，保持与master之间的同步</li></ul><h4 id="2-3-2-增量同步"><a href="#2-3-2-增量同步" class="headerlink" title="2.3.2 增量同步"></a>2.3.2 增量同步</h4><p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p><p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725153201086.png" alt="image-20210725153201086"></p><p>那么master怎么知道slave与自己的数据差异在哪里呢?</p><h4 id="2-3-3-repl-backlog-原理"><a href="#2-3-3-repl-backlog-原理" class="headerlink" title="2.3.3 repl_backlog 原理"></a>2.3.3 repl_backlog 原理</h4><p>master怎么知道slave与自己的数据差异在哪里呢?</p><p>这就要说到全量同步时的repl_baklog文件了。</p><p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p><p>repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725153359022.png" alt="image-20210725153359022"></p><p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</p><p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725153524190.png" alt="image-20210725153524190"></p><p>直到数组被填满：</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725153715910.png" alt="image-20210725153715910"></p><p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p><p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset： </p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725153937031.png" alt="image-20210725153937031"></p><p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725154048552.png" alt="image-20210725154048552"></p><p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p><blockquote><p>==注意：==</p><p>repl_backlog 大小有上限，写满后覆盖最早的数据，如果 slave 断开时间过久，导致尚未备份的数据被覆盖，则无法基于 log 做增量同步，只能再次全量同步</p></blockquote><h3 id="2-4-主从同步优化"><a href="#2-4-主从同步优化" class="headerlink" title="2.4 主从同步优化"></a>2.4 主从同步优化</h3><p>主从同步可以保证主从数据的一致性，非常重要。</p><p>可以从以下几个方面来优化Redis主从就集群：</p><ul><li>在<code>master</code>中配置<code>repl-diskless-sync yes</code>启用无磁盘复制，避免全量同步时的磁盘IO。</li><li>Redis 单节点上的内存占用不要太大，减少 RDB 导致的过多磁盘 IO</li><li>适当提高 <code>repl_baklog</code> 的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li><li>限制一个 master 上的 slave 节点数量，如果实在是太多 slave ，则可以采用<strong>主-从-从</strong>链式结构，减少 master 压力</li></ul><p>主从从架构图：</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725154405899.png" alt="image-20210725154405899"></p><h2 id="三、Redis-哨兵"><a href="#三、Redis-哨兵" class="headerlink" title="三、Redis 哨兵"></a>三、Redis 哨兵</h2><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p><h3 id="3-1-哨兵原理"><a href="#3-1-哨兵原理" class="headerlink" title="3.1 哨兵原理"></a>3.1 哨兵原理</h3><h4 id="3-1-1-集群结构和作用"><a href="#3-1-1-集群结构和作用" class="headerlink" title="3.1.1 集群结构和作用"></a>3.1.1 集群结构和作用</h4><p>哨兵的结构如图：</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725154528072.png" alt="image-20210725154528072"></p><p>哨兵的作用如下：</p><ul><li><strong>监控</strong>：Sentinel 会不断检查 master 和 slave 是否按预期工作</li><li><strong>自动故障恢复</strong>：如果 master 故障，Sentinel 会将一个 slave 提升为 master。当故障实例恢复后也以新的 master 为主</li><li><strong>通知</strong>：Sentinel 充当 Redis 客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给 Redis 的客户端</li></ul><h4 id="3-1-2-集群监控原理"><a href="#3-1-2-集群监控原理" class="headerlink" title="3.1.2 集群监控原理"></a>3.1.2 集群监控原理</h4><p>Sentinel基于<strong>心跳机制</strong>监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p><ul><li><p>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p></li><li><p>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p></li></ul><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725154632354.png" alt="image-20210725154632354"></p><h4 id="3-1-3-集群故障恢复原理"><a href="#3-1-3-集群故障恢复原理" class="headerlink" title="3.1.3 集群故障恢复原理"></a>3.1.3 集群故障恢复原理</h4><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p><ul><li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li><li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li><li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li><li>最后是判断slave节点的运行id大小，越小优先级越高。</li></ul><p>当选出一个新的master后，切换流程如下：</p><ul><li>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master</li><li>sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li><li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li></ul><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725154816841.png" alt="image-20210725154816841"></p><h3 id="3-2-搭建哨兵集群"><a href="#3-2-搭建哨兵集群" class="headerlink" title="3.2 搭建哨兵集群"></a>3.2 搭建哨兵集群</h3><p>loading…</p><h3 id="3-3-RedisTemplate"><a href="#3-3-RedisTemplate" class="headerlink" title="3.3 RedisTemplate"></a>3.3 RedisTemplate</h3><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p><h4 id="3-3-1-配置-Redis-Sentinel"><a href="#3-3-1-配置-Redis-Sentinel" class="headerlink" title="3.3.1 配置 Redis Sentinel"></a>3.3.1 配置 Redis Sentinel</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  redis:    sentinel:      master: mymaster      nodes:        - 192.168.150.101:27001        - 192.168.150.101:27002        - 192.168.150.101:27003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-2-配置读写分离"><a href="#3-3-2-配置读写分离" class="headerlink" title="3.3.2 配置读写分离"></a>3.3.2 配置读写分离</h4><p>添加一个新的 bean</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Beanpublic LettuceClientConfigurationBuilderCustomizer clientConfigurationBuilderCustomizer(){    return clientConfigurationBuilder -&gt; clientConfigurationBuilder.readFrom(ReadFrom.REPLICA_PREFERRED);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这个bean中配置的就是读写策略，包括四种：</p><ul><li>MASTER：从主节点读取</li><li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li><li>REPLICA：从slave（replica）节点读取</li><li>REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master</li></ul><h2 id="四、Redis-分片集群"><a href="#四、Redis-分片集群" class="headerlink" title="四、Redis 分片集群"></a>四、Redis 分片集群</h2><h3 id="4-1-搭建分片集群"><a href="#4-1-搭建分片集群" class="headerlink" title="4.1 搭建分片集群"></a>4.1 搭建分片集群</h3><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p><ul><li><p>海量数据存储问题</p></li><li><p>高并发写的问题</p></li></ul><p>使用分片集群可以解决上述问题，如图:</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725155747294.png" alt="image-20210725155747294"></p><p>分片集群特征：</p><ul><li><p>集群中有多个master，每个master保存不同数据</p></li><li><p>每个master都可以有多个slave节点</p></li><li><p>master之间通过ping监测彼此健康状态</p></li><li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p></li></ul><p>loading….</p><h3 id="4-2-散列插槽"><a href="#4-2-散列插槽" class="headerlink" title="4.2 散列插槽"></a>4.2 散列插槽</h3><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725155820320.png" alt="image-20210725155820320"></p><p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p><ul><li>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li><li>key中不包含“{}”，整个key都是有效部分</li></ul><p>例如：key是num，那么就根据num计算，如果是{redis}num，则根据redis计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p><p><img src="D:/百度网盘/Java资料/第4阶段—中间键&amp;服务框架/7.2022版Redis入门到精通/Redis-笔记资料/03-高级篇/讲义/01-分布式缓存/assets/image-20210725155850200.png" alt="image-20210725155850200"></p><p>如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到103节点。</p><p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点</p><blockquote><p>如何将同一类数据固定的保存在同一个Redis实例？</p><ul><li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li></ul></blockquote><h3 id="4-3-集群伸缩"><a href="#4-3-集群伸缩" class="headerlink" title="4.3 集群伸缩"></a>4.3 集群伸缩</h3><h3 id="4-4-转义插槽"><a href="#4-4-转义插槽" class="headerlink" title="4.4 转义插槽"></a>4.4 转义插槽</h3><h3 id="4-5-故障转移"><a href="#4-5-故障转移" class="headerlink" title="4.5 故障转移"></a>4.5 故障转移</h3><h3 id="4-6-RedisTemplate访问分片集群"><a href="#4-6-RedisTemplate访问分片集群" class="headerlink" title="4.6 RedisTemplate访问分片集群"></a>4.6 RedisTemplate访问分片集群</h3><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p><p>1）引入redis的starter依赖</p><p>2）配置分片集群地址</p><p>3）配置读写分离</p><p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  redis:    cluster:      nodes:        - 192.168.150.101:7001        - 192.168.150.101:7002        - 192.168.150.101:7003        - 192.168.150.101:8001        - 192.168.150.101:8002        - 192.168.150.101:8003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式--结构型模式</title>
      <link href="/tur-study/2023/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/tur-study/2023/05/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下 7 种：</p><ul><li>代理模式</li><li>适配器模式</li><li>装饰者模式</li><li>桥接模式</li><li>外观模式</li><li>组合模式</li><li>享元模式</li></ul><h2 id="一、代理模式"><a href="#一、代理模式" class="headerlink" title="一、代理模式"></a>一、代理模式</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><p>Java中的代理按照代理类生成时机不同又分为<font color="red">静态代理</font>和<font color="red">动态代理</font>。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有<strong>JDK代理</strong>和<strong>CGLib代理</strong>两种。</p><h3 id="1-2-结构"><a href="#1-2-结构" class="headerlink" title="1.2 结构"></a>1.2 结构</h3><p>代理（Proxy）模式分为三个角色：</p><ul><li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象的事项业务方法</li><li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象</li><li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，可以访问、控制、扩展真实主题的功能</li></ul><h3 id="1-3-静态代理"><a href="#1-3-静态代理" class="headerlink" title="1.3 静态代理"></a>1.3 静态代理</h3><p>【例】火车站卖票</p><p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151531909.png" alt="静态代理"></p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//卖票接口public interface SellTickets {    void sell();}//火车站  火车站具有卖票功能，所以需要实现SellTickets接口public class TrainStation implements SellTickets {    public void sell() {        System.out.println("火车站卖票");    }}//代售点public class ProxyPoint implements SellTickets {    private TrainStation station = new TrainStation();    public void sell() {        System.out.println("代理点收取一些服务费用");        station.sell();    }}//测试类public class Client {    public static void main(String[] args) {        ProxyPoint pp = new ProxyPoint();        pp.sell();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p><h3 id="1-4-JDK-动态代理"><a href="#1-4-JDK-动态代理" class="headerlink" title="1.4 JDK 动态代理"></a>1.4 JDK 动态代理</h3><p>Java 中提供了一个动态代理类 Proxy，Proxy 并不是代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance 方法）来获取代理对象</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//卖票接口public interface SellTickets {    void sell();}//火车站  火车站具有卖票功能，所以需要实现SellTickets接口public class TrainStation implements SellTickets {    public void sell() {        System.out.println("火车站卖票");    }}//代理工厂，用来创建代理对象public class ProxyFactory {    private TrainStation station = new TrainStation();    public SellTickets getProxyObject() {        //使用Proxy获取代理对象        /*            newProxyInstance()方法参数说明：                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口                InvocationHandler h ： 代理对象的调用处理程序         */        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),                station.getClass().getInterfaces(),                new InvocationHandler() {                    /*                        InvocationHandler中invoke方法参数说明：                            proxy ： 代理对象                            method ： 对应于在代理对象上调用的接口方法的 Method 实例                            args ： 代理对象调用接口方法时传递的实际参数                     */                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {                        System.out.println("代理点收取一些服务费用(JDK动态代理方式)");                        //执行真实对象                        Object result = method.invoke(station, args);                        return result;                    }                });        return sellTickets;    }}//测试类public class Client {    public static void main(String[] args) {        //获取代理对象        ProxyFactory factory = new ProxyFactory();                SellTickets proxyObject = factory.getProxyObject();        proxyObject.sell();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">使用了动态代理，我们思考下面问题：</font></p><ul><li><p>ProxyFactory是代理类吗？</p><p>ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">package com.sun.proxy;import com.proxy.dynamic.jdk.SellTickets;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements SellTickets {    private static Method m1;    private static Method m2;    private static Method m3;    private static Method m0;    public $Proxy0(InvocationHandler invocationHandler) {        super(invocationHandler);    }    static {        try {            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));            m2 = Class.forName("java.lang.Object").getMethod("toString", new Class[0]);            m3 = Class.forName("com.proxy.dynamic.jdk.SellTickets").getMethod("sell", new Class[0]);            m0 = Class.forName("java.lang.Object").getMethod("hashCode", new Class[0]);            return;        }        catch (NoSuchMethodException noSuchMethodException) {            throw new NoSuchMethodError(noSuchMethodException.getMessage());        }        catch (ClassNotFoundException classNotFoundException) {            throw new NoClassDefFoundError(classNotFoundException.getMessage());        }    }    public final boolean equals(Object object) {        try {            return (Boolean)this.h.invoke(this, m1, new Object[]{object});        }        catch (Error | RuntimeException throwable) {            throw throwable;        }        catch (Throwable throwable) {            throw new UndeclaredThrowableException(throwable);        }    }    public final String toString() {        try {            return (String)this.h.invoke(this, m2, null);        }        catch (Error | RuntimeException throwable) {            throw throwable;        }        catch (Throwable throwable) {            throw new UndeclaredThrowableException(throwable);        }    }    public final int hashCode() {        try {            return (Integer)this.h.invoke(this, m0, null);        }        catch (Error | RuntimeException throwable) {            throw throwable;        }        catch (Throwable throwable) {            throw new UndeclaredThrowableException(throwable);        }    }    public final void sell() {        try {            this.h.invoke(this, m3, null);            return;        }        catch (Error | RuntimeException throwable) {            throw throwable;        }        catch (Throwable throwable) {            throw new UndeclaredThrowableException(throwable);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面的类中，我们可以看到以下几个信息：</p><ul><li>代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。</li><li>代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。</li></ul><p>动态代理类的执行流程如下：</p><ol><li>在测试类中通过代理对象调用 sell 方法</li><li>根据多态的特性，执行的是代理类（$Proxy0）中的 sell() 方法</li><li>代理类（$Proxy0）中的 sell 方法又调用了 InvocationHandler 接口的子实现类对象的 invoke 方法</li><li>invoke 方法通过反射执行了真实对象所属类（TrainStation）中的 sell 方法</li></ol><h3 id="1-5-CGLIB-动态代理"><a href="#1-5-CGLIB-动态代理" class="headerlink" title="1.5 CGLIB 动态代理"></a>1.5 CGLIB 动态代理</h3><p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p><p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p><p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cglib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>cglib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.2.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">//火车站public class TrainStation {    public void sell() {        System.out.println("火车站卖票");    }}//代理工厂public class ProxyFactory implements MethodInterceptor {    private TrainStation target = new TrainStation();    public TrainStation getProxyObject() {        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数        Enhancer enhancer =new Enhancer();        //设置父类的字节码对象        enhancer.setSuperclass(target.getClass());        //设置回调函数        enhancer.setCallback(this);        //创建代理对象        TrainStation obj = (TrainStation) enhancer.create();        return obj;    }    /*        intercept方法参数说明：            o ： 代理对象            method ： 真实对象中的方法的Method实例            args ： 实际参数            methodProxy ：代理对象中的方法的method实例     */    public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {        System.out.println("代理点收取一些服务费用(CGLIB动态代理方式)");        TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);        return result;    }}//测试类public class Client {    public static void main(String[] args) {        //创建代理工厂对象        ProxyFactory factory = new ProxyFactory();        //获取代理对象        TrainStation proxyObject = factory.getProxyObject();        proxyObject.sell();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-6-三种代理的对比"><a href="#1-6-三种代理的对比" class="headerlink" title="1.6 三种代理的对比"></a>1.6 三种代理的对比</h3><ul><li><p>jdk代理和CGLIB代理</p><p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p><p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。</p></li><li><p>动态代理和静态代理</p><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p><p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p></li></ul><h3 id="1-7-优缺点"><a href="#1-7-优缺点" class="headerlink" title="1.7 优缺点"></a>1.7 优缺点</h3><p><strong>优点：</strong></p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的复杂度；</li></ul><h3 id="1-8-使用场景"><a href="#1-8-使用场景" class="headerlink" title="1.8 使用场景"></a>1.8 使用场景</h3><ul><li><p>远程（Remote）代理</p><p>本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。</p></li><li><p>防火墙（Firewall）代理</p><p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。</p></li><li><p>保护（Protect or Access）代理</p><p>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。</p></li></ul><h2 id="二、适配器模式"><a href="#二、适配器模式" class="headerlink" title="二、适配器模式"></a>二、适配器模式</h2><p>假如我们有这样软件系统，我们希望它能够和一个新的库搭配使用，但是这个库所提供的接口与我们的软件系统不兼容，我们不想改变现有代码就能解决这个问题，怎么办？这个时候我们就需要将这个新的库接口转换成我们所需要的接口，这就是适配器模式设计动机。</p><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>何谓适配器模式？适配器模式就是将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p><p>在适配器模式中，我们可以定义一个包装类，包装不兼容接口的对象，这个包装类就是适配器，它所包装的对象就是适配者。</p><p>适配器提供给客户需要的接口，适配器的实现就是将客户的请求转换成对适配者的相应的接口的引用。也就是说，当客户调用适配器的方法时，适配器方法内部将调用适配者的方法，客户并不是直接访问适配者的，而是通过调用适配器方法访问适配者。因为适配器可以使互不兼容的类能够“合作愉快”。</p><p>适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><h3 id="2-2-结构"><a href="#2-2-结构" class="headerlink" title="2.2  结构"></a>2.2  结构</h3><p>适配器模式（Adapter）包含以下主要角色：</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，可以是抽象类或接口</li><li>适配者（Adapter）类：是被访问和适配的现存组件库中的组件接口</li><li>适配器（Adapter）类：是一个转换器，通过继承或引用适配者对象，把适配者接口转换成目标接口，让客户暗目标接口的格式访问适配者</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151532422.png" alt="适配器模式"></p><h3 id="2-3-类适配器模式"><a href="#2-3-类适配器模式" class="headerlink" title="2.3 类适配器模式"></a>2.3 类适配器模式</h3><p>实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p><p>【例】读卡器</p><p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。</p><p>类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151532421.png" alt="类适配器模式"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//SD卡的接口public interface SDCard {    //读取SD卡方法    String readSD();    //写入SD卡功能    void writeSD(String msg);}//SD卡实现类public class SDCardImpl implements SDCard {    public String readSD() {        String msg = "sd card read a msg :hello word SD";        return msg;    }    public void writeSD(String msg) {        System.out.println("sd card write msg : " + msg);    }}//电脑类public class Computer {    public String readSD(SDCard sdCard) {        if(sdCard == null) {            throw new NullPointerException("sd card null");        }        return sdCard.readSD();    }}//TF卡接口public interface TFCard {    //读取TF卡方法    String readTF();    //写入TF卡功能    void writeTF(String msg);}//TF卡实现类public class TFCardImpl implements TFCard {    public String readTF() {        String msg ="tf card read msg : hello word tf card";        return msg;    }    public void writeTF(String msg) {        System.out.println("tf card write a msg : " + msg);    }}//定义适配器类（SD兼容TF）public class SDAdapterTF extends TFCardImpl implements SDCard {    public String readSD() {        System.out.println("adapter read tf card ");        return readTF();    }    public void writeSD(String msg) {        System.out.println("adapter write tf card");        writeTF(msg);    }}//测试类public class Client {    public static void main(String[] args) {        Computer computer = new Computer();        SDCard sdCard = new SDCardImpl();        System.out.println(computer.readSD(sdCard));        System.out.println("------------");        SDAdapterTF adapter = new SDAdapterTF();        System.out.println(computer.readSD(adapter));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p><h3 id="2-4-对象适配器模式"><a href="#2-4-对象适配器模式" class="headerlink" title="2.4 对象适配器模式"></a>2.4 对象适配器模式</h3><p>实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p><p>【例】读卡器。使用对象适配器模式将读卡器的案例进行改写。类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151532870.png" alt="对象适配器模式"></p><p>类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//创建适配器对象（SD兼容TF）public class SDAdapterTF  implements SDCard {    private TFCard tfCard;    public SDAdapterTF(TFCard tfCard) {        this.tfCard = tfCard;    }    public String readSD() {        System.out.println("adapter read tf card ");        return tfCard.readTF();    }    public void writeSD(String msg) {        System.out.println("adapter write tf card");        tfCard.writeTF(msg);    }}//测试类public class Client {    public static void main(String[] args) {        Computer computer = new Computer();        SDCard sdCard = new SDCardImpl();        System.out.println(computer.readSD(sdCard));        System.out.println("------------");        TFCard tfCard = new TFCardImpl();        SDAdapterTF adapter = new SDAdapterTF(tfCard);        System.out.println(computer.readSD(adapter));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。</p></blockquote><h3 id="2-5-应用场景"><a href="#2-5-应用场景" class="headerlink" title="2.5 应用场景"></a>2.5 应用场景</h3><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><h3 id="2-6-JDK-源码解析"><a href="#2-6-JDK-源码解析" class="headerlink" title="2.6 JDK 源码解析"></a>2.6 JDK 源码解析</h3><p>Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。</p><p>InputStreamReader继承自java.io包中的Reader，对它中的抽象的未实现的方法给出实现。如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int read() throws IOException {    return sd.read();}public int read(char cbuf[], int offset, int length) throws IOException {    return sd.read(cbuf, offset, length);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151532191.png"></p><p>从上图可以看出：</p><ul><li>InputStreamReader是对同样实现了Reader的StreamDecoder的封装。</li><li>StreamDecoder不是Java SE API中的内容，是Sun  JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。</li></ul><p><font color="red">结论：</font></p><p>从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。</p><h2 id="三、装饰者模式"><a href="#三、装饰者模式" class="headerlink" title="三、装饰者模式"></a>三、装饰者模式</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>示例：</p><p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151533847.png" alt="装饰者模式"></p><p>使用继承的方式存在的问题：</p><ul><li><p>扩展性不好</p><p>如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。</p></li><li><p>产生过多的子类</p></li></ul><p><strong>定义</strong></p><p>装饰者模式，指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。若要扩展功能，装饰者提供了比继承更加有弹性的替代方案</p><h3 id="3-2-结构"><a href="#3-2-结构" class="headerlink" title="3.2 结构"></a>3.2 结构</h3><p>装饰（Decorator）模式中的角色：</p><ul><li>抽象构件（Component）角色：定义一个抽象接口以规范准备接受附加责任的对象</li><li>具体构件（Concrete Component）角色：实现抽象构件，通过装饰角色为其添加一些职责</li><li>抽象装饰（Decorator）角色：继承或实现抽象构件，并包含具体构件的实例，可以通过其积累扩展具体构件的功能</li><li>具体装饰（Concrete Decorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任</li></ul><h3 id="3-3-案例"><a href="#3-3-案例" class="headerlink" title="3.3 案例"></a>3.3 案例</h3><p>我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。</p><p>类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151533853.png" alt="装饰者模式-快餐店案例"></p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//快餐接口public abstract class FastFood {    private float price;    private String desc;    public FastFood() {    }    public FastFood(float price, String desc) {        this.price = price;        this.desc = desc;    }    public void setPrice(float price) {        this.price = price;    }    public float getPrice() {        return price;    }    public String getDesc() {        return desc;    }    public void setDesc(String desc) {        this.desc = desc;    }    public abstract float cost();  //获取价格}//炒饭public class FriedRice extends FastFood {    public FriedRice() {        super(10, "炒饭");    }    public float cost() {        return getPrice();    }}//炒面public class FriedNoodles extends FastFood {    public FriedNoodles() {        super(12, "炒面");    }    public float cost() {        return getPrice();    }}//配料类public abstract class Garnish extends FastFood {    private FastFood fastFood;    public FastFood getFastFood() {        return fastFood;    }    public void setFastFood(FastFood fastFood) {        this.fastFood = fastFood;    }    public Garnish(FastFood fastFood, float price, String desc) {        super(price,desc);        this.fastFood = fastFood;    }}//鸡蛋配料public class Egg extends Garnish {    public Egg(FastFood fastFood) {        super(fastFood,1,"鸡蛋");    }    public float cost() {        return getPrice() + getFastFood().getPrice();    }    @Override    public String getDesc() {        return super.getDesc() + getFastFood().getDesc();    }}//培根配料public class Bacon extends Garnish {    public Bacon(FastFood fastFood) {        super(fastFood,2,"培根");    }    @Override    public float cost() {        return getPrice() + getFastFood().getPrice();    }    @Override    public String getDesc() {        return super.getDesc() + getFastFood().getDesc();    }}//测试类public class Client {    public static void main(String[] args) {        //点一份炒饭        FastFood food = new FriedRice();        //花费的价格        System.out.println(food.getDesc() + " " + food.cost() + "元");        System.out.println("========");        //点一份加鸡蛋的炒饭        FastFood food1 = new FriedRice();        food1 = new Egg(food1);        //花费的价格        System.out.println(food1.getDesc() + " " + food1.cost() + "元");        System.out.println("========");        //点一份加培根的炒面        FastFood food2 = new FriedNoodles();        food2 = new Bacon(food2);        //花费的价格        System.out.println(food2.getDesc() + " " + food2.cost() + "元");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>好处：</strong></p><ul><li><p>饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</p></li><li><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p></li></ul><h3 id="3-4-使用场景"><a href="#3-4-使用场景" class="headerlink" title="3.4 使用场景"></a>3.4 使用场景</h3><ul><li><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p><p>不能采用继承的情况主要有两类：</p><ul><li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li><li>第二类是因为类定义不能继承（如final类）</li></ul></li><li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p></li><li><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p></li></ul><h3 id="3-5-JDK源码解析"><a href="#3-5-JDK源码解析" class="headerlink" title="3.5 JDK源码解析"></a>3.5 JDK源码解析</h3><p>IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。</p><p>我们以BufferedWriter举例来说明，先看看如何使用BufferedWriter</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo {    public static void main(String[] args) throws Exception{        //创建BufferedWriter对象        //创建FileWriter对象        FileWriter fw = new FileWriter("C:\\Users\\Think\\Desktop\\a.txt");        BufferedWriter bw = new BufferedWriter(fw);        //写数据        bw.write("hello Buffered");        bw.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用起来感觉确实像是装饰者模式，接下来看它们的结构：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151534079.png"></p><blockquote><p><font color="red">小结：</font></p><p>​BufferedWriter使用装饰者模式对Writer子实现类进行了增强，添加了缓冲区，提高了写数据的效率。</p></blockquote><h3 id="3-6-代理和装饰者的区别"><a href="#3-6-代理和装饰者的区别" class="headerlink" title="3.6 代理和装饰者的区别"></a>3.6 代理和装饰者的区别</h3><p>静态代理和装饰者模式的区别：</p><ul><li>相同点：<ul><li>都要实现与目标类相同的业务接口</li><li>在两个类中都要声明目标对象</li><li>都可以在不修改目标类的前提下增强目标方法</li></ul></li><li>不同点：<ul><li>目的不同<br>装饰者是为了增强目标对象<br>静态代理是为了保护和隐藏目标对象</li><li>获取目标对象构建的地方不同<br>装饰者是由外界传递进来，可以通过构造方法传递<br>静态代理是在代理类内部创建，以此来隐藏目标对象</li></ul></li></ul><h2 id="四、桥接模式"><a href="#四、桥接模式" class="headerlink" title="四、桥接模式"></a>四、桥接模式</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151530109.png"></p><p>我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。</p><p>试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p><p><strong>定义：</strong></p><p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p><h3 id="4-2-结构"><a href="#4-2-结构" class="headerlink" title="4.2 结构"></a>4.2 结构</h3><p>桥接（Bridge）模式包含以下主要角色：</p><ul><li>抽象化角色：定义抽象类，并包含一个对实现化对象的引用</li><li>扩展抽象化角色：是抽象化角色的子类，实现业务中的业务方法，并通过组合关系调用实现化角儿中的业务方法</li><li>实现化角色：定义实现化角色的接口，供扩展抽象化角色调用</li><li>具体实现化角色：给出实现化角色接口的具体实现</li></ul><h3 id="4-3-案例"><a href="#4-3-案例" class="headerlink" title="4.3 案例"></a>4.3 案例</h3><p>【例】视频播放器</p><p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p><p>类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151530995.png" alt="桥接模式"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//视频文件public interface VideoFile {    void decode(String fileName);}//avi文件public class AVIFile implements VideoFile {    public void decode(String fileName) {        System.out.println("avi视频文件："+ fileName);    }}//rmvb文件public class REVBBFile implements VideoFile {    public void decode(String fileName) {        System.out.println("rmvb文件：" + fileName);    }}//操作系统版本public abstract class OperatingSystemVersion {    protected VideoFile videoFile;    public OperatingSystemVersion(VideoFile videoFile) {        this.videoFile = videoFile;    }    public abstract void play(String fileName);}//Windows版本public class Windows extends OperatingSystem {    public Windows(VideoFile videoFile) {        super(videoFile);    }    public void play(String fileName) {        videoFile.decode(fileName);    }}//mac版本public class Mac extends OperatingSystemVersion {    public Mac(VideoFile videoFile) {        super(videoFile);    }    public void play(String fileName) {videoFile.decode(fileName);    }}//测试类public class Client {    public static void main(String[] args) {        OperatingSystem os = new Windows(new AVIFile());        os.play("战狼3");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-优缺点"><a href="#4-4-优缺点" class="headerlink" title="4.4 优缺点"></a>4.4 优缺点</h3><p><strong>优点</strong>：</p><ul><li><p>系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</p><p>如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。</p></li><li><p>实现细节对客户透明</p></li></ul><p><strong>缺点：</strong></p><ul><li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。 </li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li></ul><h3 id="4-5-使用场景"><a href="#4-5-使用场景" class="headerlink" title="4.5 使用场景"></a>4.5 使用场景</h3><ul><li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li><li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li></ul><h2 id="五、外观模式"><a href="#五、外观模式" class="headerlink" title="五、外观模式"></a>五、外观模式</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p><strong>定义：</strong></p><p>又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><p>外观（Facade）模式是“迪米特法则”的典型应用</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151530119.jpg" alt="外观模式引入"></p><h3 id="5-2-结构"><a href="#5-2-结构" class="headerlink" title="5.2 结构"></a>5.2 结构</h3><p>外观（Facade）模式包含以下主要角色：</p><ul><li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li><li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li></ul><h3 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h3><p>【例】智能家电控制</p><p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151530984.png" alt="外观模式"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//灯类public class Light {    public void on() {        System.out.println("打开了灯....");    }    public void off() {        System.out.println("关闭了灯....");    }}//电视类public class TV {    public void on() {        System.out.println("打开了电视....");    }    public void off() {        System.out.println("关闭了电视....");    }}//控制类public class AirCondition {    public void on() {        System.out.println("打开了空调....");    }    public void off() {        System.out.println("关闭了空调....");    }}//智能音箱public class SmartAppliancesFacade {    private Light light;    private TV tv;    private AirCondition airCondition;    public SmartAppliancesFacade() {        light = new Light();        tv = new TV();        airCondition = new AirCondition();    }    public void say(String message) {        if(message.contains("打开")) {            on();        } else if(message.contains("关闭")) {            off();        } else {            System.out.println("我还听不懂你说的！！！");        }    }    //起床后一键开电器    private void on() {        System.out.println("起床了");        light.on();        tv.on();        airCondition.on();    }    //睡觉一键关电器    private void off() {        System.out.println("睡觉了");        light.off();        tv.off();        airCondition.off();    }}//测试类public class Client {    public static void main(String[] args) {        //创建外观对象        SmartAppliancesFacade facade = new SmartAppliancesFacade();        //客户端直接与外观对象进行交互        facade.say("打开家电");        facade.say("关闭家电");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4-优缺点"><a href="#5-4-优缺点" class="headerlink" title="5.4 优缺点"></a>5.4 优缺点</h3><p><strong>好处：</strong></p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li></ul><p><strong>缺点：</strong></p><ul><li>不符合开闭原则，修改很麻烦</li></ul><h3 id="5-5-使用场景"><a href="#5-5-使用场景" class="headerlink" title="5.5 使用场景"></a>5.5 使用场景</h3><ul><li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li><li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li><li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li></ul><h3 id="5-6-源码解析"><a href="#5-6-源码解析" class="headerlink" title="5.6 源码解析"></a>5.6 源码解析</h3><p>使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151530100.png"></p><p>RequestFacade类就使用了外观模式。先看结构图：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151530935.png" alt="外观模式-jdk源码解析"></p><p><strong>为什么在此处使用外观模式呢？</strong></p><p>​定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request  的实现。然后，将 RequestFacade上转为 ServletRequest  传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问。</p><h2 id="六、组合模式"><a href="#六、组合模式" class="headerlink" title="六、组合模式"></a>六、组合模式</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305151543933.png"></p><p>​对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。</p><p><strong>定义：</strong></p><p>又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p><h3 id="6-2-结构"><a href="#6-2-结构" class="headerlink" title="6.2 结构"></a>6.2 结构</h3><p>组合模式主要包含三个角色：</p><ul><li>抽象根结点：定义系统各层次对象的共有方法和属性。可以预先定义一些默认行为和属性</li><li>树枝节点：定义树枝节点的行为，存储子结点，组合树枝节点和叶子节点形成一个树形结构</li><li>叶子结点：叶子结点对象，其下再无分支，是系统层次遍历的最小单位</li></ul><h3 id="6-3-案例实现"><a href="#6-3-案例实现" class="headerlink" title="6.3 案例实现"></a>6.3 案例实现</h3><p>【例】软件菜单</p><p>如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305151616369.png" alt="软件菜单"></p><p>要实现该案例，我们先画出类图：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305151618085.png" alt="组合模式"></p><p><strong>代码实现：</strong></p><p>不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//菜单组件  不管是菜单还是菜单项，都应该继承该类public abstract class MenuComponent {    protected String name;    protected int level;    //添加菜单    public void add(MenuComponent menuComponent){        throw new UnsupportedOperationException();    }    //移除菜单    public void remove(MenuComponent menuComponent){        throw new UnsupportedOperationException();    }    //获取指定的子菜单    public MenuComponent getChild(int i){        throw new UnsupportedOperationException();    }    //获取菜单名称    public String getName(){        return name;    }    public void print(){        throw new UnsupportedOperationException();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Menu extends MenuComponent {    private List&lt;MenuComponent&gt; menuComponentList;    public Menu(String name,int level){        this.level = level;        this.name = name;        menuComponentList = new ArrayList&lt;MenuComponent&gt;();    }    @Override    public void add(MenuComponent menuComponent) {        menuComponentList.add(menuComponent);    }    @Override    public void remove(MenuComponent menuComponent) {        menuComponentList.remove(menuComponent);    }    @Override    public MenuComponent getChild(int i) {        return menuComponentList.get(i);    }    @Override    public void print() {        for (int i = 1; i &lt; level; i++) {            System.out.print("--");        }        System.out.println(name);        for (MenuComponent menuComponent : menuComponentList) {            menuComponent.print();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MenuItem extends MenuComponent {    public MenuItem(String name,int level) {        this.name = name;        this.level = level;    }    @Override    public void print() {        for (int i = 1; i &lt; level; i++) {            System.out.print("--");        }        System.out.println(name);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。</p><h3 id="6-4-组合模式的分类"><a href="#6-4-组合模式的分类" class="headerlink" title="6.4 组合模式的分类"></a>6.4 组合模式的分类</h3><p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。</p><ul><li><p>透明组合模式</p><p>透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 <code>MenuComponent</code> 声明了 <code>add</code>、<code>remove</code> 、<code>getChild</code> 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</p><p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p></li><li><p>安全组合模式</p><p>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 <code>Menu</code> 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305151652149.png" alt="组合模式-安全性"></p></li></ul><h3 id="6-5-优点"><a href="#6-5-优点" class="headerlink" title="6.5 优点"></a>6.5 优点</h3><ul><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li><li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li></ul><h3 id="6-6-使用场景"><a href="#6-6-使用场景" class="headerlink" title="6.6 使用场景"></a>6.6 使用场景</h3><p>组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</p><h2 id="七、享元模式"><a href="#七、享元模式" class="headerlink" title="七、享元模式"></a>七、享元模式</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><p><strong>定义：</strong></p><p>运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p><h3 id="7-2-结构"><a href="#7-2-结构" class="headerlink" title="7.2 结构"></a>7.2 结构</h3><p>享元模式中存在以下两种状态：</p><ul><li>内部状态：即不会随着环境的改变而改变的可共享部分</li><li>外部状态：指随着环境改变而改变的不可以共享的部分</li></ul><p>享元状态的实现要领就是区分应用中的这两种状态，并将外部状态外部化</p><p>享元模式主要有以下角色：</p><ul><li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li>具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li><li>非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li><li>享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ul><h3 id="7-3-案例实现"><a href="#7-3-案例实现" class="headerlink" title="7.3 案例实现"></a>7.3 案例实现</h3><p>【例】俄罗斯方块</p><p>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152000370.jpeg" alt="俄罗斯方块"></p><p>类图：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152001130.png" alt="享元模式"></p><p><strong>代码如下：</strong></p><p>俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class AbstractBox {    public abstract String getShape();    public void display(String color) {        System.out.println("方块形状：" + this.getShape() + " 颜色：" + color);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IBox extends AbstractBox {    @Override    public String getShape() {        return "I";    }}public class LBox extends AbstractBox {    @Override    public String getShape() {        return "L";    }}public class OBox extends AbstractBox {    @Override    public String getShape() {        return "O";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class BoxFactory {    private static HashMap&lt;String, AbstractBox&gt; map;    private BoxFactory() {        map = new HashMap&lt;String, AbstractBox&gt;();        AbstractBox iBox = new IBox();        AbstractBox lBox = new LBox();        AbstractBox oBox = new OBox();        map.put("I", iBox);        map.put("L", lBox);        map.put("O", oBox);    }    public static final BoxFactory getInstance() {        return SingletonHolder.INSTANCE;    }    private static class SingletonHolder {        private static final BoxFactory INSTANCE = new BoxFactory();    }    public AbstractBox getBox(String key) {        return map.get(key);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-5-优缺点"><a href="#7-5-优缺点" class="headerlink" title="7.5 优缺点"></a>7.5 优缺点</h3><p><strong>优点</strong></p><ul><li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li><li>享元模式中的外部状态相对独立，且不影响内部状态</li></ul><p><strong>缺点：</strong></p><p>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</p><h3 id="7-6-使用场景"><a href="#7-6-使用场景" class="headerlink" title="7.6 使用场景"></a>7.6 使用场景</h3><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul><h3 id="7-7-JDK-源码解析"><a href="#7-7-JDK-源码解析" class="headerlink" title="7.7 JDK 源码解析"></a>7.7 JDK 源码解析</h3><p>Integer类使用了享元模式。我们先看下面的例子：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo {    public static void main(String[] args) {        Integer i1 = 127;        Integer i2 = 127;        System.out.println("i1和i2对象是否是同一个对象？" + (i1 == i2));        Integer i3 = 128;        Integer i4 = 128;        System.out.println("i3和i4对象是否是同一个对象？" + (i3 == i4));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152004712.png" alt="image-20200208212930857"></p><p>为什么第一个输出语句输出的是true，第二个输出语句输出的是false？通过反编译软件进行反编译，代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Demo {    public static void main(String[] args) {        Integer i1 = Integer.valueOf((int)127);        Integer i2 Integer.valueOf((int)127);        System.out.println((String)new StringBuilder().append((String)"i1\u548ci2\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f").append((boolean)(i1 == i2)).toString());        Integer i3 = Integer.valueOf((int)128);        Integer i4 = Integer.valueOf((int)128);        System.out.println((String)new StringBuilder().append((String)"i3\u548ci4\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f").append((boolean)(i3 == i4)).toString());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面代码可以看到，直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是 <code>valueOf()</code> ，所以只需要看该方法即可</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final class Integer extends Number implements Comparable&lt;Integer&gt; {    public static Integer valueOf(int i) {        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)            return IntegerCache.cache[i + (-IntegerCache.low)];        return new Integer(i);    }        private static class IntegerCache {        static final int low = -128;        static final int high;        static final Integer cache[];        static {            int h = 127;            String integerCacheHighPropValue =                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");            if (integerCacheHighPropValue != null) {                try {                    int i = parseInt(integerCacheHighPropValue);                    i = Math.max(i, 127);                    // Maximum array size is Integer.MAX_VALUE                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);                } catch( NumberFormatException nfe) {                }            }            high = h;            cache = new Integer[(high - low) + 1];            int j = low;            for(int k = 0; k &lt; cache.length; k++)                cache[k] = new Integer(j++);            // range [-128, 127] must be interned (JLS7 5.1.7)            assert IntegerCache.high &gt;= 127;        }        private IntegerCache() {}    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code> 之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 详解</title>
      <link href="/tur-study/2023/05/01/MQ/Docker%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/05/01/MQ/Docker%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Docker-概述"><a href="#一、Docker-概述" class="headerlink" title="一、Docker 概述"></a>一、Docker 概述</h2><h3 id="1-1-Docker-简介"><a href="#1-1-Docker-简介" class="headerlink" title="1.1 Docker 简介"></a>1.1 Docker 简介</h3><p>Docker是一个开源的<strong>容器引擎</strong>，它可以帮助我们更快地交付应用。Docker可将应用程序和基础设施层隔离，并且能将基础设施当作程序一样进行管理。使用Docker，可更快地打包、测试以及部署应用程序，并可<strong>减少从编写到部署运行代码的周期</strong>。</p><blockquote><ul><li>Docker官方网站：<a href="https://www.docker.com/">https://www.docker.com/</a></li><li>Docker GitHub：<a href="https://github.com/docker/docker">https://github.com/docker/docker</a></li></ul></blockquote><h3 id="1-2-Docker-安装"><a href="#1-2-Docker-安装" class="headerlink" title="1.2 Docker 安装"></a>1.2 Docker 安装</h3><blockquote><p>基于 Centos 系统</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 1、yum 包更新到最新 yum update# 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 yum install -y yum-utils device-mapper-persistent-data lvm2# 3、 设置yum源yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 4、 安装docker，出现输入的界面都按 y yum install -y docker-ce# 5、 查看docker版本，验证是否验证成功docker -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-Docker-架构"><a href="#1-3-Docker-架构" class="headerlink" title="1.3 Docker 架构"></a>1.3 Docker 架构</h3><p>Docker 的架构图如下所示：</p><p><img src="/tur-study/../../../../../AppData/Roaming/Typora/typora-user-images/image-20230513142441074.png" alt="image-20230513142441074"></p><p>其中的组件说明如下：</p><ul><li><p>Docker daemon：Docker 守护进程。是一个运行在宿主机（DOCKER_HOST）的后台进程 ，我们通过 Docker 客户端可与之通信</p></li><li><p>Client（Docker客户端）</p></li></ul><p>  Docker客户端是Docker的用户界面，它可以接受用户命令和配置标识，并与Docker daemon通信。图中，docker build等都是Docker的相关命令</p><ul><li><p>Images（Docker镜像）</p><p>Docker镜像是一个只读模板，它包含创建Docker容器的说明。它和系统安装光盘有点像——我们使用系统安装光盘安装系统，同理，我们使用Docker镜像运行Docker镜像中的程序</p></li><li><p>Container（容器）</p><p>容器是镜像的可运行实例。镜像和容器的关系有点类似于面向对象中，类和对象的关系。我们可通过Docker API或者CLI命令来启停、移动、删除容器</p></li><li><p>Registry</p><p>Docker Registry是一个集中存储与分发镜像的服务。我们构建完Docker镜像后，就可在当前宿主机上运行。但如果想要在其他机器上运行这个镜像，我们就需要手动拷贝。此时，我们可借助Docker Registry来避免镜像的手动拷贝。</p><p>一个Docker  Registry可包含多个Docker仓库；每个仓库可包含多个镜像标签；每个标签对应一个Docker镜像。这跟Maven的仓库有点类似，如果把Docker Registry比作Maven仓库的话，那么Docker仓库就可理解为某jar包的路径，而镜像标签则可理解为jar包的版本号。</p><p>Docker Registry可分为公有Docker Registry和私有Docker Registry。最常用的Docker  Registry莫过于官方的Docker Hub，这也是默认的Docker Registry。Docker  Hub上存放着大量优秀的镜像，我们可使用Docker命令下载并使用</p></li></ul><h2 id="二、Docker-命令"><a href="#二、Docker-命令" class="headerlink" title="二、Docker 命令"></a>二、Docker 命令</h2><h3 id="2-1-Docker-进程相关命令"><a href="#2-1-Docker-进程相关命令" class="headerlink" title="2.1 Docker 进程相关命令"></a>2.1 Docker 进程相关命令</h3><blockquote><p>Linux Centos 系统下</p></blockquote><ul><li><p>启动 Docker 服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>停止 Docker 服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>重启 Docker 服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查看 Docker 服务状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>设置开机自启动 Docker 服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl enable docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="2-2-Docker-镜像命令"><a href="#2-2-Docker-镜像命令" class="headerlink" title="2.2 Docker 镜像命令"></a>2.2 Docker 镜像命令</h3><ul><li><p>查看镜像：查看本地所有的进项</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker imagesdocker images -q  # 只展示镜像的id<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>搜索镜像：从 Docker Hub 中查找需要的镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker search 镜像名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>拉取镜像：从 Docker 仓库下载镜像到本地，镜像名称格式为：<code>名称:版本号</code>，如果版本号不指定则默认拉取最新的版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull 镜像名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>如果不知道镜像版本，可以去 Docker Hub 中搜索对应的镜像查看</p></blockquote></li><li><p>删除镜像：删除本地镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker rmi 镜像名称或id # 删除指定本地镜像docker rim `docker images -q`  # 删除所有本地镜像<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>保存镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker save 镜像名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>加载镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker load 镜像包<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="2-3-Docker-容器相关命令"><a href="#2-3-Docker-容器相关命令" class="headerlink" title="2.3 Docker 容器相关命令"></a>2.3 Docker 容器相关命令</h3><h4 id="2-3-1-新建并启动容器-star"><a href="#2-3-1-新建并启动容器-star" class="headerlink" title="2.3.1 新建并启动容器 :star:"></a>2.3.1 新建并启动容器 <span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>命令：<code>docker run 参数</code> </p><p>常用的参数选项如下：</p><ul><li><code>-d</code>：表示后台运行</li><li><code>-P</code>：随机端口映射</li><li><code>-p</code>：置顶端口映射，有以下四种格式：<ol><li><code>ip:hostPort:containerPort</code></li><li><code>ip::containerPort</code></li><li><code>hostPort:containerPort</code></li><li><code>containerPort</code></li></ol></li><li><code>-network</code>：指定网络模式。有以下可选参数<ol><li><code>-network=bridge</code>：默认选项，表示连接到默认的网桥</li><li><code>-network=host</code>：容器使用宿主机的网络</li><li><code>-network=container:NAME_or_ID</code>：告诉 Docker 让新建的容器使用已有容器的网络配置</li><li><code>-network=none</code>：不配置该容器的网络，用户可自定义网络配置</li></ol></li></ul><blockquote><p>==注意：==</p><p>需要注意的是，使用docker run命令创建容器时，会先检查本地是否存在指定镜像。如果本地不存在该名称的镜像，Docker就会自动从Docker Hub下载镜像并启动一个Docker容器</p></blockquote><h4 id="2-3-2-列出容器-star"><a href="#2-3-2-列出容器-star" class="headerlink" title="2.3.2 列出容器 :star:"></a>2.3.2 列出容器 <span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>命令：</p><ul><li><code>docker ps</code>：查看正在运行的容器</li><li><code>docker ps -a</code>：查看所有容器</li></ul><p>参数：</p><table><thead><tr><th>Name, shorthand</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>--all, -a</code></td><td><code>false</code></td><td>列出所有容器，包括未运行的容器，默认只展示运行的容器</td></tr><tr><td><code>--filter, -f</code></td><td></td><td>根据条件过滤显示内容</td></tr><tr><td><code>--format</code></td><td></td><td>通过Go语言模板文件展示镜像</td></tr><tr><td><code>--last, -n</code></td><td><code>-1</code></td><td>显示最近创建n个容器（包含所有状态）</td></tr><tr><td><code>--latest, -l</code></td><td><code>false</code></td><td>显示最近创建的容器（包含所有状态）</td></tr><tr><td><code>--no-trunc</code></td><td><code>false</code></td><td>不截断输出</td></tr><tr><td><code>--quiet, -q</code></td><td><code>false</code></td><td>静默模式，只展示容器的编号</td></tr><tr><td><code>--size, -s</code></td><td><code>false</code></td><td>显示总文件大小</td></tr></tbody></table><h4 id="2-3-3-停止容器-star"><a href="#2-3-3-停止容器-star" class="headerlink" title="2.3.3 停止容器 :star:"></a>2.3.3 停止容器 <span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>命令：<code>docker stop 容器名称或id</code></p><p>参数：</p><table><thead><tr><th>Name, shorthand</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>--time, -t</code></td><td><code>10</code></td><td>强制杀死容器前等待的时间，单位是秒</td></tr></tbody></table><h4 id="2-3-4-强制停止容器-star"><a href="#2-3-4-强制停止容器-star" class="headerlink" title="2.3.4 强制停止容器 :star:"></a>2.3.4 强制停止容器 <span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>可使用<code>docker kill</code> 命令停止一个或更多运行着的容器。</p><p>命令格式：</p><pre class="line-numbers language-none"><code class="language-none">docker kill [OPTIONS] CONTAINER [CONTAINER...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数：</p><table><thead><tr><th>Name, shorthand</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>--signal, -s</code></td><td><code>KILL</code></td><td>向容器发送一个信号</td></tr></tbody></table><h4 id="2-3-5-启动已停止的容器-star"><a href="#2-3-5-启动已停止的容器-star" class="headerlink" title="2.3.5 启动已停止的容器 :star:"></a>2.3.5 启动已停止的容器 <span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>使用<code>docker run</code> 命令，即可新建并启动一个容器。对于已停止的容器，可使用<code>docker start</code> 命令来启动。</p><p>命令格式：</p><pre class="line-numbers language-none"><code class="language-none">docker start [OPTIONS] CONTAINER [CONTAINER...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数：</p><table><thead><tr><th>Name, shorthand</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>--attach, -a</code></td><td><code>false</code></td><td>连接STDOUT/STDERR并转发信号</td></tr><tr><td><code>--checkpoint</code></td><td></td><td>从该检查点还原</td></tr><tr><td><code>--checkpoint-dir</code></td><td></td><td>使用自定义的检查点存储目录</td></tr><tr><td><code>--detach-keys</code></td><td></td><td>覆盖断开容器的关键顺序</td></tr><tr><td><code>--interactive, -i</code></td><td><code>false</code></td><td>连接容器的STDIN</td></tr></tbody></table><h4 id="2-3-6-重启容器-star"><a href="#2-3-6-重启容器-star" class="headerlink" title="2.3.6 重启容器 :star:"></a>2.3.6 重启容器 <span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>可使用<code>docker restart</code> 命令来重启容器。该命令实际上是先执行了<code>docker stop</code> 命令，然后执行了<code>docker start</code> 命令。</p><p>命令格式：</p><pre class="line-numbers language-none"><code class="language-none">docker restart [OPTIONS] CONTAINER [CONTAINER...]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参数：</p><table><thead><tr><th>Name, shorthand</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>--time, -t</code></td><td><code>10</code></td><td>关闭容器前等待的时间，单位是秒</td></tr></tbody></table><h4 id="2-3-7-进入容器-star"><a href="#2-3-7-进入容器-star" class="headerlink" title="2.3.7 进入容器:star:"></a>2.3.7 进入容器<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>某场景下，我们可能需要进入运行中的容器。</p><p>① 使用<code>docker attach</code> 命令进入容器。</p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">docker attach 784fd3b294d7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>很多场景下，使用<code>docker attach</code> 命令并不方便。当多个窗口同时attach到同一个容器时，所有窗口都会同步显示。同理，如果某个窗口发生阻塞，其他窗口也无法执行操作。</p><p>② 使用<code>nsenter</code> 进入容器</p><p>nsenter工具包含在util-linux 2.23或更高版本中。为了连接到容器，我们需要找到容器第一个进程的PID，可通过以下命令获取：</p><pre class="line-numbers language-none"><code class="language-none">docker inspect --format "{{.State.Pid}}" $CONTAINER_ID<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>获得PID后，就可使用nsenter命令进入容器了：</p><pre class="line-numbers language-none"><code class="language-none">nsenter --target "$PID" --mount --uts --ipc --net --pid<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>下面给出一个完整的例子：</p><pre class="line-numbers language-none"><code class="language-none">[root@localhost ~]# docker psCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES784fd3b294d7        nginx               "nginx -g 'daemon off"   55 minutes ago      Up 3 minutes        443/tcp, 0.0.0.0:91-&gt;80/tcp   backstabbing_archimedes[root@localhost ~]# docker inspect --format "{{.State.Pid}}" 784fd3b294d795492[root@localhost ~]# nsenter --target 95492 --mount --uts --ipc --net --pidroot@784fd3b294d7:/# <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>也可将以上两条命令封装成一个Shell，从而简化进入容器的过程。</p><p>③ docker exec</p><pre class="line-numbers language-none"><code class="language-none">docker exec -it 容器id /bin/bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-3-8-删除容器-star"><a href="#2-3-8-删除容器-star" class="headerlink" title="2.3.8 删除容器:star:"></a>2.3.8 删除容器<span class="github-emoji"><span>⭐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2b50.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></h4><p>使用<code>docker rm</code> 命令即可删除指定容器。</p><p>命令格式</p><pre class="line-numbers language-none"><code class="language-none">docker rm [OPTIONS] CONTAINER [CONTAINER...]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数：</p><table><thead><tr><th>Name, shorthand</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>--force, -f</code></td><td><code>false</code></td><td>通过SIGKILL信号强制删除正在运行中的容器</td></tr><tr><td><code>--link, -l</code></td><td><code>false</code></td><td>删除容器间的网络连接</td></tr><tr><td><code>--volumes, -v</code></td><td><code>false</code></td><td>删除与容器关联的卷</td></tr></tbody></table><p>例1：删除指定容器。</p><pre class="line-numbers language-none"><code class="language-none">docker rm 784fd3b294d7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该命令只能删除已停止的容器，如需删除正在运行的容器，可使用-f参数。</p><p>例2：删除所有的容器。</p><pre class="line-numbers language-none"><code class="language-none">docker rm -f $(docker ps -a -q)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-3-9-导出容器"><a href="#2-3-9-导出容器" class="headerlink" title="2.3.9 导出容器"></a>2.3.9 导出容器</h4><p>将容器导出成一个压缩包文件。</p><p>命令格式：</p><pre class="line-numbers language-none"><code class="language-none">docker export [OPTIONS] CONTAINER<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数：</p><table><thead><tr><th>Name, shorthand</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>--output, -o</code></td><td></td><td>将内容写到文件而非STDOUT</td></tr></tbody></table><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">docker export red_panda &gt; latest.tardocker export --output="latest.tar" red_panda<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-3-10-导入容器"><a href="#2-3-10-导入容器" class="headerlink" title="2.3.10 导入容器"></a>2.3.10 导入容器</h4><p>使用<code>docker import</code> 命令即可从归档文件导入内容并创建镜像。</p><p>命令格式：</p><pre class="line-numbers language-none"><code class="language-none">docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数：</p><table><thead><tr><th>Name, shorthand</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>--change, -c</code></td><td></td><td>将Dockerfile指令应用到创建的镜像</td></tr><tr><td><code>--message, -m</code></td><td></td><td>为导入的镜像设置提交信息</td></tr></tbody></table><p>示例：</p><pre class="line-numbers language-none"><code class="language-none">docker import nginx2.tar nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 容器服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ详解</title>
      <link href="/tur-study/2023/05/01/MQ/RabbitMQ%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/05/01/MQ/RabbitMQ%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Rabbit-极简入门"><a href="#一、Rabbit-极简入门" class="headerlink" title="一、Rabbit 极简入门"></a>一、Rabbit 极简入门</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p><a href="https://www.rabbitmq.com/">RabbitMQ</a> 是由 LShift 提供的一个 <a href="https://zh.wikipedia.org/zh-hans/%E9%AB%98%E7%BA%A7%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%8D%8F%E8%AE%AE">Advanced Message Queuing Protocol (AMQP)</a> 的开源实现，由以高性能、健壮以及可伸缩性出名的 <a href="https://www.erlang.org/">Erlang</a> 写成，因此也是继承了这些优点。</p><blockquote><p>AMQP：高级消息队列协议。是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制</p></blockquote><p>RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p><ol><li>可靠性（Reliability） RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li><li>灵活的路由（Flexible Routing） 在消息进入队列之前，通过 Exchange  来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的 Exchange 来实现。针对更复杂的路由功能，可以将多个  Exchange 绑定在一起，也通过插件机制实现自己的 Exchange 。</li><li>消息集群（Clustering） 多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker 。</li><li>高可用（Highly Available Queues） 队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li><li>多种协议（Multi-protocol） RabbitMQ 支持多种消息队列协议，比如 STOMP、MQTT 等等。</li><li>多语言客户端（Many Clients） RabbitMQ 几乎支持所有常用语言，比如 Java、.NET、Ruby 等等。</li><li>管理界面（Management UI） RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面。</li><li>跟踪机制（Tracing） 如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。</li><li>插件机制（Plugin System） RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</li></ol><h3 id="1-2-RabbitMQ-基本概念"><a href="#1-2-RabbitMQ-基本概念" class="headerlink" title="1.2 RabbitMQ 基本概念"></a>1.2 RabbitMQ 基本概念</h3><p><img src="/tur-study/../../../../../AppData/Roaming/Typora/typora-user-images/image-20230513135648263.png" alt="RabbitMQ 模型"></p><ol><li><code>Message  </code>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</li><li><code>Publisher </code>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</li><li><code>Exchange </code>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</li><li><code>Binding </code>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</li><li><code>Queue </code>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</li><li><code>Connection </code>网络连接，比如一个TCP连接。</li><li><code>Channel </code>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP  命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP  都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。</li><li><code>Consumer </code>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。</li><li><code>Virtual Host </code>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个  vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP  概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。</li><li><code>Broker </code>表示消息队列服务器实体。</li></ol><h3 id="1-3-单机部署"><a href="#1-3-单机部署" class="headerlink" title="1.3 单机部署"></a>1.3 单机部署</h3><blockquote><p>采用 Docker 来安装部署 RabbitMQ</p></blockquote><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker pull rabbitmq<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run \ -e RABBITMQ_DEFAULT_USER=root \ -e RABBITMQ_DEFAULT_PASS=123456 \ --name rabbitmq \ --hostname rabbitmq \ -p 15672:15672 \ -p 5672:5672 \ -d \ rabbitmq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>==注意：==</p><p>Docker 运行 RabbitMQ 时不会自动启动 RabbitMQ Management 插件，此时浏览器是无法访问的，需要手动开启。命令如下：<code>rabbitmq-plugins enable rabbitmq_management</code></p></blockquote><p>RabbitMQ Mangement：</p><p><img src="/tur-study/../../../../../AppData/Roaming/Typora/typora-user-images/image-20230513170635776.png" alt="Rabbit Mangement"></p><h3 id="1-4-集群部署"><a href="#1-4-集群部署" class="headerlink" title="1.4 集群部署"></a>1.4 集群部署</h3><h3 id="1-5-简单示例"><a href="#1-5-简单示例" class="headerlink" title="1.5 简单示例"></a>1.5 简单示例</h3>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3知识合集</title>
      <link href="/tur-study/2023/05/01/Vue/Vue3%20%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/"/>
      <url>/tur-study/2023/05/01/Vue/Vue3%20%E7%9F%A5%E8%AF%86%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Vue-基础"><a href="#一、Vue-基础" class="headerlink" title="一、Vue 基础"></a>一、Vue 基础</h2><h3 id="1-1-Vue-简介"><a href="#1-1-Vue-简介" class="headerlink" title="1.1 Vue 简介"></a>1.1 Vue 简介</h3><h4 id="1-1-1-什么是-vue"><a href="#1-1-1-什么是-vue" class="headerlink" title="1.1.1 什么是 vue"></a>1.1.1 什么是 vue</h4><p>官方给出的概念：Vue 是一套<font color="red">用来构建用户界面</font>的前端<font color="red">框架</font></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305011110924.png" alt="核心关键词"></p><h5 id="1-构建用户界面"><a href="#1-构建用户界面" class="headerlink" title="1. 构建用户界面"></a>1. 构建用户界面</h5><p>前端开发者最主要的工作，就是为<font color="red">网站的使用者</font>（又称为：网站的用户）<font color="red">构建出美观、舒适、好用的网页</font></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202305011111600.png" alt="构建用户界面"></p><p>在传统的 Web 前端开发中，是基于 <font color="red">jQuery + 模板引擎</font> 的方式来构建用户界面的。</p>]]></content>
      
      
      <categories>
          
          <category> Vue3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式--设计原则</title>
      <link href="/tur-study/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/"/>
      <url>/tur-study/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1. 单一职责原则"></a>1. 单一职责原则</h3><p>一个类，只有一个引起它变化的原因。应该只有一个职责。每一个职责都是变化的一个轴线，如果一个类有一个以上的职责，这些职责就耦合在了一起。这会导致脆弱的设计。当一个职责发生变化时，可能会影响其它的职责。另外，多个职责耦合在一起，会影响复用性。例如：要实现逻辑和界面的分离</p><h3 id="2-开闭原则（OCP）"><a href="#2-开闭原则（OCP）" class="headerlink" title="2. 开闭原则（OCP）"></a>2. 开闭原则（OCP）</h3><p>开闭原则就是说<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类。</p><h3 id="3-里氏代还原则（LSP）"><a href="#3-里氏代还原则（LSP）" class="headerlink" title="3. 里氏代还原则（LSP）"></a>3. 里氏代还原则（LSP）</h3><p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。  里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。  LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h3 id="4-依赖倒转原则（DIP）"><a href="#4-依赖倒转原则（DIP）" class="headerlink" title="4. 依赖倒转原则（DIP）"></a>4. 依赖倒转原则（DIP）</h3><p>所谓依赖倒置原则（Dependence Inversion Principle）就是要依赖于抽象，不要依赖于具体。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><p>实现开闭原则的关键是抽象化，并且从抽象化导出具体化实现，如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要手段。</p><h3 id="5-接口隔离原则"><a href="#5-接口隔离原则" class="headerlink" title="5. 接口隔离原则"></a>5. 接口隔离原则</h3><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p><h3 id="6-合成复用原则"><a href="#6-合成复用原则" class="headerlink" title="6. 合成复用原则"></a>6. 合成复用原则</h3><p>合成复用原则就是指在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用其已有功能的目的。简言之：要尽量使用组合/聚合关系，少用继承。</p><p>通常类的复用分为继承复用和合成复用两种。</p><p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>对象间的耦合度低。可以在类的成员位置声明抽象。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><h3 id="7-迪特米法则（最少知道原则）"><a href="#7-迪特米法则（最少知道原则）" class="headerlink" title="7. 迪特米法则（最少知道原则）"></a>7. 迪特米法则（最少知道原则）</h3><p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。也就是说一个软件实体应当尽可能少的与其他实体发生相互作用。这样，当一个模块修改时，就会尽量少的影响其他的模块，扩展会相对容易，这是对软件实体之间通信的限制，它要求限制软件实体之间通信的宽度和深度</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式--创建型模式</title>
      <link href="/tur-study/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/tur-study/2023/05/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F--%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>在软件工程中，创建型模式是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。</p><p>创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。</p><p>创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中。</p><p>创建型模式分为：</p><ul><li>单例模式</li><li>工厂方法模式</li><li>抽象工程模式</li><li>原型模式</li><li>建造者模式</li></ul><h2 id="一、单例模式"><a href="#一、单例模式" class="headerlink" title="一、单例模式"></a>一、单例模式</h2><p>有时候某些对象我们只需要一个，如：线程池、缓存、对话框等等，对于这类对象我们只能有一个实例，如果我们制造出多个实例，就会导致很多问题产生。</p><p>但是我们怎样才能保证一个类只有一个实例并且能够便于访问？这里我们想到了全局变量，全局变量确实是可以</p><p>保证该类可以随时访问，但是它很难解决只有一个实例问题。最好的办法就是让该自身来负责保存它的唯一实例。这个类必须要保证没有其他类来创建它。这里我们可以将其<strong>构造方法私有化</strong>。即</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public MyClass {    private MyClass(){}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>含有私有化构造器的类就能保证它不能被其他类实例化了。但是我们如何来获取这个实例化类呢？提供一个方法用于返回该类的实例对象即可实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public MyClass {    private MyClass(){}        public static MyClass getInstance() {        return new MyClass();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-基本定义"><a href="#1-1-基本定义" class="headerlink" title="1.1 基本定义"></a>1.1 基本定义</h3><p>单例模式就是确保某一个类只有一个实例，并且提供一个全局访问点，可以直接访问，不需要实例化该类的对象。</p><p>从上面可以看出单例模式有如下几个特点：</p><ul><li><p>只有一个实例。</p></li><li><p>必须要自行实例化。</p></li><li><p>必须自行想整个系统提供访问点。</p></li></ul><h3 id="1-2-模式结构"><a href="#1-2-模式结构" class="headerlink" title="1.2 模式结构"></a>1.2 模式结构</h3><p>单例模式的主要有以下角色：</p><ul><li>单例类。只能创建一个实例的类</li><li>访问类。使用单例类</li></ul><h3 id="1-3-模式实现"><a href="#1-3-模式实现" class="headerlink" title="1.3 模式实现"></a>1.3 模式实现</h3><p>单例设计模式分类两种：</p><ul><li><p>饿汉式：类加载就会导致该单实例对象被创建</p></li><li><p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></li></ul><h4 id="1-3-1-饿汉式"><a href="#1-3-1-饿汉式" class="headerlink" title="1.3.1 饿汉式"></a>1.3.1 饿汉式</h4><h5 id="1-静态变量方式"><a href="#1-静态变量方式" class="headerlink" title="1. 静态变量方式"></a>1. 静态变量方式</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Singleton {    //私有构造方法    private Singleton() {}    //在成员位置创建该类的对象    private static Singleton instance = new Singleton();    //对外提供静态方法获取该对象    public static Singleton getInstance() {        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><font color="red">说明：</font></p><p>该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p></blockquote><h5 id="2-静态代码块方式"><a href="#2-静态代码块方式" class="headerlink" title="2. 静态代码块方式"></a>2. 静态代码块方式</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Singleton {    //私有构造方法    private Singleton() {}    //在成员位置创建该类的对象    private static Singleton instance;    static {        instance = new Singleton();    }    //对外提供静态方法获取该对象    public static Singleton getInstance() {        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><font color="red">说明：</font></p><p>该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。</p></blockquote><h5 id="3-枚举方式"><a href="#3-枚举方式" class="headerlink" title="3. 枚举方式"></a>3. 枚举方式</h5><p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public enum Singleton {    INSTANCE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="1-3-2-懒汉式"><a href="#1-3-2-懒汉式" class="headerlink" title="1.3.2 懒汉式"></a>1.3.2 懒汉式</h4><h5 id="1-方式1（线程不安全）"><a href="#1-方式1（线程不安全）" class="headerlink" title="1. 方式1（线程不安全）"></a>1. 方式1（线程不安全）</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Singleton {    //私有构造方法    private Singleton() {}    //在成员位置创建该类的对象    private static Singleton instance;    //对外提供静态方法获取该对象    public static Singleton getInstance() {        if(instance == null) {            instance = new Singleton();        }        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">说明：</font></p><p>从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p><h5 id="2-方式2（线程安全）"><a href="#2-方式2（线程安全）" class="headerlink" title="2. 方式2（线程安全）"></a>2. 方式2（线程安全）</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Singleton {    //私有构造方法    private Singleton() {}    //在成员位置创建该类的对象    private static Singleton instance;    //对外提供静态方法获取该对象    public static synchronized Singleton getInstance() {        if(instance == null) {            instance = new Singleton();        }        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">说明：</font></p><p>​该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了<code>synchronized</code>关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p><h5 id="3-双重检查锁模式"><a href="#3-双重检查锁模式" class="headerlink" title="3. 双重检查锁模式"></a>3. 双重检查锁模式</h5><p>对于 <code>getInstance()</code> 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Singleton {     //私有构造方法    private Singleton() {}    private static Singleton instance;   //对外提供静态方法获取该对象    public static Singleton getInstance() {//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例        if(instance == null) {            synchronized (Singleton.class) {                //抢到锁之后再次判断是否为null                if(instance == null) {                    instance = new Singleton();                }            }        }        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p><p>要解决双重检查锁模式带来空指针异常的问题，只需要使用 <code>volatile</code> 关键字, <code>volatile</code> 关键字可以保证可见性和有序性。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Singleton {    //私有构造方法    private Singleton() {}    private static volatile Singleton instance;   //对外提供静态方法获取该对象    public static Singleton getInstance() {//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际        if(instance == null) {            synchronized (Singleton.class) {                //抢到锁之后再次判断是否为空                if(instance == null) {                    instance = new Singleton();                }            }        }        return instance;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">小结：</font></p><p>添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p><h5 id="4-静态内部类方式"><a href="#4-静态内部类方式" class="headerlink" title="4. 静态内部类方式"></a>4. 静态内部类方式</h5><p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Singleton {    //私有构造方法    private Singleton() {}    private static class SingletonHolder {        private static final Singleton INSTANCE = new Singleton();    }    //对外提供静态方法获取该对象    public static Singleton getInstance() {        return SingletonHolder.INSTANCE;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">说明：</font></p><p>第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p><p><font color="red">小结：</font></p><p>静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p><h3 id="1-4-存在的问题"><a href="#1-4-存在的问题" class="headerlink" title="1.4 存在的问题"></a>1.4 存在的问题</h3><h4 id="1-4-1-问题演示"><a href="#1-4-1-问题演示" class="headerlink" title="1.4.1 问题演示"></a>1.4.1 问题演示</h4><p>破坏单例模式：使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。</p><h5 id="1-序列化"><a href="#1-序列化" class="headerlink" title="1. 序列化"></a>1. 序列化</h5><p><strong>Singleton类：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Singleton implements Serializable {    //私有构造方法    private Singleton() {}    private static class SingletonHolder {        private static final Singleton INSTANCE = new Singleton();    }    //对外提供静态方法获取该对象    public static Singleton getInstance() {        return SingletonHolder.INSTANCE;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Test类：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test {    public static void main(String[] args) throws Exception {        //往文件中写对象        //writeObject2File();        //从文件中读取对象        Singleton s1 = readObjectFromFile();        Singleton s2 = readObjectFromFile();        //判断两个反序列化后的对象是否是同一个对象        System.out.println(s1 == s2);    }    private static Singleton readObjectFromFile() throws Exception {        //创建对象输入流对象        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("C:\\Users\\Think\\Desktop\\a.txt"));        //第一个读取Singleton对象        Singleton instance = (Singleton) ois.readObject();        return instance;    }    public static void writeObject2File() throws Exception {        //获取Singleton类的对象        Singleton instance = Singleton.getInstance();        //创建对象输出流        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("C:\\Users\\Think\\Desktop\\a.txt"));        //将instance对象写出到文件中        oos.writeObject(instance);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式。</p></blockquote><h5 id="2-反射"><a href="#2-反射" class="headerlink" title="2. 反射"></a>2. 反射</h5><p><strong>Singleton类：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Singleton {    //私有构造方法    private Singleton() {}        private static volatile Singleton instance;    //对外提供静态方法获取该对象    public static Singleton getInstance() {        if(instance != null) {            return instance;        }        synchronized (Singleton.class) {            if(instance != null) {                return instance;            }            instance = new Singleton();            return instance;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Test类：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test {    public static void main(String[] args) throws Exception {        //获取Singleton类的字节码对象        Class clazz = Singleton.class;        //获取Singleton类的私有无参构造方法对象        Constructor constructor = clazz.getDeclaredConstructor();        //取消访问检查        constructor.setAccessible(true);        //创建Singleton类的对象s1        Singleton s1 = (Singleton) constructor.newInstance();        //创建Singleton类的对象s2        Singleton s2 = (Singleton) constructor.newInstance();        //判断通过反射创建的两个Singleton对象是否是同一个对象        System.out.println(s1 == s2);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式</p></blockquote><blockquote><p><font color="red">注意：</font>枚举方式不会出现这两个问题。</p></blockquote><h4 id="1-4-2-问题的解决"><a href="#1-4-2-问题的解决" class="headerlink" title="1.4.2 问题的解决"></a>1.4.2 问题的解决</h4><h5 id="1-序列化-1"><a href="#1-序列化-1" class="headerlink" title="1. 序列化"></a>1. 序列化</h5><p>序列化、反序列方式破坏单例模式的解决方法：</p><p>在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Singleton implements Serializable {    //私有构造方法    private Singleton() {}    private static class SingletonHolder {        private static final Singleton INSTANCE = new Singleton();    }    //对外提供静态方法获取该对象    public static Singleton getInstance() {        return SingletonHolder.INSTANCE;    }        /**     * 下面是为了解决序列化反序列化破解单例模式     */    private Object readResolve() {        return SingletonHolder.INSTANCE;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>源码解析：</strong><code>ObjectInputStream</code>类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final Object readObject() throws IOException, ClassNotFoundException{    ...    // if nested read, passHandle contains handle of enclosing object    int outerHandle = passHandle;    try {        Object obj = readObject0(false);//重点查看readObject0方法    .....}    private Object readObject0(boolean unshared) throws IOException {...    try {switch (tc) {...case TC_OBJECT:return checkResolve(readOrdinaryObject(unshared));//重点查看readOrdinaryObject方法...        }    } finally {        depth--;        bin.setBlockDataMode(oldMode);    }    }    private Object readOrdinaryObject(boolean unshared) throws IOException {...//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，    obj = desc.isInstantiable() ? desc.newInstance() : null;     ...    // 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true    if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod()) {    // 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量    // 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。    Object rep = desc.invokeReadResolve(obj);     ...    }    return obj;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-反射-1"><a href="#2-反射-1" class="headerlink" title="2. 反射"></a>2. 反射</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Singleton {    //私有构造方法    private Singleton() {        /*           反射破解单例模式需要添加的代码        */        if(instance != null) {            throw new RuntimeException();        }    }        private static volatile Singleton instance;    //对外提供静态方法获取该对象    public static Singleton getInstance() {        if(instance != null) {            return instance;        }        synchronized (Singleton.class) {            if(instance != null) {                return instance;            }            instance = new Singleton();            return instance;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="red">说明:</font></p><p>这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。</p><h3 id="1-5-单例模式实例——Runtime-类源码解析"><a href="#1-5-单例模式实例——Runtime-类源码解析" class="headerlink" title="1.5 单例模式实例——Runtime 类源码解析"></a>1.5 单例模式实例——Runtime 类源码解析</h3><p>通过源代码查看使用的是哪儿种单例模式:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Runtime {    private static Runtime currentRuntime = new Runtime();    /**     * Returns the runtime object associated with the current Java application.     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance     * methods and must be invoked with respect to the current runtime object.     *     * @return  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current     *          Java application.     */    public static Runtime getRuntime() {        return currentRuntime;    }    /** Don't let anyone else instantiate this class */    private Runtime() {}    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面源代码中可以看出Runtime类使用的是饿汉式（静态属性）方式来实现单例模式的。</p><h3 id="1-6-模式优缺点"><a href="#1-6-模式优缺点" class="headerlink" title="1.6 模式优缺点"></a>1.6 模式优缺点</h3><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h4><ul><li>一、节约了系统资源。由于系统中只存在一个实例对象，对与一些需要频繁创建和销毁对象的系统而言，单</li></ul><p>例模式无疑节约了系统资源和提高了系统的性能。</p><ul><li>二、因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它。</li></ul><h4 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2. 缺点"></a>2. 缺点</h4><ul><li>一、由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>二、单例类的职责过重，在一定程度上违背了“单一职责原则”。</li></ul><h3 id="1-7-使用场景"><a href="#1-7-使用场景" class="headerlink" title="1.7 使用场景"></a>1.7 使用场景</h3><ul><li><p>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</p></li><li><p>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</p></li></ul><h2 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h2><h3 id="2-0-案例需求"><a href="#2-0-案例需求" class="headerlink" title="2.0 案例需求"></a>2.0 案例需求</h3><p>需求：设计一个咖啡店点餐系统。  </p><p>设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。</p><p>具体类的设计如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152306931.png" alt="工厂设计模式引入"></p><p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p><p>工厂模式有三种具体模式：</p><ul><li>简单工厂模式（不属于GOF的23种经典设计模式）</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h3 id="2-1-简单工厂模式"><a href="#2-1-简单工厂模式" class="headerlink" title="2.1 简单工厂模式"></a>2.1 简单工厂模式</h3><p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p><h4 id="2-1-1-结构"><a href="#2-1-1-结构" class="headerlink" title="2.1.1 结构"></a>2.1.1 结构</h4><p>简单工厂包含如下角色：</p><ul><li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品 ：实现或者继承抽象产品的子类</li><li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li></ul><h4 id="2-1-2-实现"><a href="#2-1-2-实现" class="headerlink" title="2.1.2 实现"></a>2.1.2 实现</h4><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152306300.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SimpleCoffeeFactory {    public Coffee createCoffee(String type) {        Coffee coffee = null;        if("americano".equals(type)) {            coffee = new AmericanoCoffee();        } else if("latte".equals(type)) {            coffee = new LatteCoffee();        }        return coffee;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p><p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。</p><h4 id="2-1-3-优缺点"><a href="#2-1-3-优缺点" class="headerlink" title="2.1.3 优缺点"></a>2.1.3 优缺点</h4><p><strong>优点</strong></p><p>1、简单工厂模式实现了对责任的分割，提供了专门的工厂类用于创建对象。</p><p>2、客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</p><p>3、通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</p><p><strong>缺点</strong></p><p>1、由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</p><p>2、使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</p><p>3、系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</p><p>4、简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</p><h4 id="2-1-4-静态工厂"><a href="#2-1-4-静态工厂" class="headerlink" title="2.1.4 静态工厂"></a>2.1.4 静态工厂</h4><p>在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class SimpleCoffeeFactory {    public static Coffee createCoffee(String type) {        Coffee coffee = null;        if("americano".equals(type)) {            coffee = new AmericanoCoffee();        } else if("latte".equals(type)) {            coffee = new LatteCoffee();        }        return coffe;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-5-使用场景"><a href="#2-1-5-使用场景" class="headerlink" title="2.1.5 使用场景"></a>2.1.5 使用场景</h4><ul><li><p>工厂类负责创建的对象比较少。</p></li><li><p>客户端只知道传入工厂类的参数，对于如何创建对象不关心。</p></li></ul><h3 id="2-2-工厂方法模式"><a href="#2-2-工厂方法模式" class="headerlink" title="2.2 工厂方法模式"></a>2.2 工厂方法模式</h3><p>针对简单工厂的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><h4 id="2-2-1-概述"><a href="#2-2-1-概述" class="headerlink" title="2.2.1 概述"></a>2.2.1 概述</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p><h4 id="2-2-2-结构"><a href="#2-2-2-结构" class="headerlink" title="2.2.2 结构"></a>2.2.2 结构</h4><p>工厂方法模式的主要角色：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><h4 id="2-2-3-实现"><a href="#2-2-3-实现" class="headerlink" title="2.2.3 实现"></a>2.2.3 实现</h4><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152306943.png" alt="工厂方法模式"></p><p>抽象工厂：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface CoffeeFactory {    Coffee createCoffee();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>具体工厂：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LatteCoffeeFactory implements CoffeeFactory {    public Coffee createCoffee() {        return new LatteCoffee();    }}public class AmericanCoffeeFactory implements CoffeeFactory {    public Coffee createCoffee() {        return new AmericanCoffee();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>咖啡店类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CoffeeStore {    private CoffeeFactory factory;    public CoffeeStore(CoffeeFactory factory) {        this.factory = factory;    }    public Coffee orderCoffee() {        Coffee coffee = factory.createCoffee();        coffee.addMilk();        coffee.addsugar();        return coffee;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。</p><p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p><h4 id="2-2-4-优缺点"><a href="#2-2-4-优缺点" class="headerlink" title="2.2.4 优缺点"></a>2.2.4 优缺点</h4><p><strong>优点：</strong></p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li></ul><p><strong>缺点：</strong></p><ul><li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li></ul><h4 id="2-2-5-使用场景"><a href="#2-2-5-使用场景" class="headerlink" title="2.2.5 使用场景"></a>2.2.5 使用场景</h4><ul><li><p>一个类不知道它所需要的对象的类。在工厂方法模式中，我们不需要具体产品的类名，我们只需要知道创建它的具体工厂即可。</p></li><li><p>一个类通过其子类来指定创建那个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</p></li><li><p>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</p></li></ul><h3 id="2-3-抽象工厂模式"><a href="#2-3-抽象工厂模式" class="headerlink" title="2.3 抽象工厂模式"></a>2.3 抽象工厂模式</h3><p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视。</p><p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p><p>而抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p><h4 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h4><p>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><h4 id="2-3-2-结构"><a href="#2-3-2-结构" class="headerlink" title="2.3.2 结构"></a>2.3.2 结构</h4><p>抽象工厂模式的主要角色如下：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li></ul><h4 id="2-3-3-实现"><a href="#2-3-3-实现" class="headerlink" title="2.3.3 实现"></a>2.3.3 实现</h4><p>现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152307783.png" alt="抽象工厂模式"></p><p>抽象工厂：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface DessertFactory {    Coffee createCoffee();    Dessert createDessert();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体工厂：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//美式甜点工厂public class AmericanDessertFactory implements DessertFactory {    public Coffee createCoffee() {        return new AmericanCoffee();    }    public Dessert createDessert() {        return new MatchaMousse();    }}//意大利风味甜点工厂public class ItalyDessertFactory implements DessertFactory {    public Coffee createCoffee() {        return new LatteCoffee();    }    public Dessert createDessert() {        return new Tiramisu();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。</p><h4 id="2-3-4-优缺点"><a href="#2-3-4-优缺点" class="headerlink" title="2.3.4 优缺点"></a>2.3.4 优缺点</h4><p><strong>优点：</strong></p><p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong></p><p>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p><h4 id="2-3-5-使用场景"><a href="#2-3-5-使用场景" class="headerlink" title="2.3.5 使用场景"></a>2.3.5 使用场景</h4><ul><li><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</p></li><li><p>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</p></li><li><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p></li></ul><p>如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</p><h3 id="2-4-模式扩展"><a href="#2-4-模式扩展" class="headerlink" title="2.4 模式扩展"></a>2.4 模式扩展</h3><p><strong>简单工厂+配置文件接触耦合</strong></p><p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</p><p>第一步：定义配置文件</p><p>使用properties文件作为配置文件，名称为bean.properties</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 值为产品具体类的路径american=com.pattern.factory.AmericanCoffeelatte=com.pattern.factory.LatteCoffee<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>第二步：改进工厂类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CoffeeFactory {    private static Map&lt;String,Coffee&gt; map = new HashMap();    static {        Properties p = new Properties();        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream("bean.properties");        try {            p.load(is);            //遍历Properties集合对象            Set&lt;Object&gt; keys = p.keySet();            for (Object key : keys) {                //根据键获取值（全类名）                String className = p.getProperty((String) key);                //获取字节码对象                Class clazz = Class.forName(className);                Coffee obj = (Coffee) clazz.newInstance();                map.put((String)key,obj);            }        } catch (Exception e) {            e.printStackTrace();        }    }    public static Coffee createCoffee(String name) {        return map.get(name);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。</p><h3 id="2-5-Collection-iterator-方法解析"><a href="#2-5-Collection-iterator-方法解析" class="headerlink" title="2.5 Collection.iterator 方法解析"></a>2.5 Collection.iterator 方法解析</h3><p>单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152309339.png"></p><p>Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。</p><blockquote><p>另：</p><ul><li>DateForamt类中的getInstance()方法使用的是工厂模式；</li><li>Calendar类中的getInstance()方法使用的是工厂模式；</li></ul></blockquote><h2 id="三、原型模式"><a href="#三、原型模式" class="headerlink" title="三、原型模式"></a>三、原型模式</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p><h3 id="3-2-结构"><a href="#3-2-结构" class="headerlink" title="3.2 结构"></a>3.2 结构</h3><p>原型模式包含如下角色：</p><ul><li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ul><p>接口类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152309988.png"></p><h3 id="3-3-实现"><a href="#3-3-实现" class="headerlink" title="3.3 实现"></a>3.3 实现</h3><p>原型模式的克隆分为浅克隆和深克隆。</p><ul><li><p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p></li><li><p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p></li></ul><p>Java中的Object类中提供了 <code>clone()</code> 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：</p><p><strong>Realizetype（具体的原型类）：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Realizetype implements Cloneable {    public Realizetype() {        System.out.println("具体的原型对象创建完成！");    }    @Override    protected Realizetype clone() throws CloneNotSupportedException {        System.out.println("具体原型复制成功！");        return (Realizetype) super.clone();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>PrototypeTest（测试访问类）：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class PrototypeTest {    public static void main(String[] args) throws CloneNotSupportedException {        Realizetype r1 = new Realizetype();        Realizetype r2 = r1.clone();        System.out.println("对象r1和r2是同一个对象？" + (r1 == r2));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-案例"><a href="#3-4-案例" class="headerlink" title="3.4 案例"></a>3.4 案例</h3><p><strong>用原型模式生成“三好学生”奖状</strong></p><p>同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。</p><p>类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152310190.png"></p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//奖状类public class Citation implements Cloneable {    private String name;    public void setName(String name) {        this.name = name;    }    public String getName() {        return (this.name);    }    public void show() {        System.out.println(name + "同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！");    }    @Override    public Citation clone() throws CloneNotSupportedException {        return (Citation) super.clone();    }}//测试访问类public class CitationTest {    public static void main(String[] args) throws CloneNotSupportedException {        Citation c1 = new Citation();        c1.setName("张三");        //复制奖状        Citation c2 = c1.clone();        //将奖状的名字修改李四        c2.setName("李四");        c1.show();        c2.show();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-使用场景"><a href="#3-5-使用场景" class="headerlink" title="3.5 使用场景"></a>3.5 使用场景</h3><ul><li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li><li>性能和安全要求比较高。</li></ul><h3 id="3-6-扩展（深克隆）"><a href="#3-6-扩展（深克隆）" class="headerlink" title="3.6 扩展（深克隆）"></a>3.6 扩展（深克隆）</h3><p>将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//奖状类public class Citation implements Cloneable {    private Student stu;    public Student getStu() {        return stu;    }    public void setStu(Student stu) {        this.stu = stu;    }    void show() {        System.out.println(stu.getName() + "同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！");    }    @Override    public Citation clone() throws CloneNotSupportedException {        return (Citation) super.clone();    }}//学生类public class Student {    private String name;    private String address;    public Student(String name, String address) {        this.name = name;        this.address = address;    }    public Student() {    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getAddress() {        return address;    }    public void setAddress(String address) {        this.address = address;    }}//测试类public class CitationTest {    public static void main(String[] args) throws CloneNotSupportedException {        Citation c1 = new Citation();        Student stu = new Student("张三", "西安");        c1.setStu(stu);        //复制奖状        Citation c2 = c1.clone();        //获取c2奖状所属学生对象        Student stu1 = c2.getStu();        stu1.setName("李四");        //判断stu对象和stu1对象是否是同一个对象        System.out.println("stu和stu1是同一个对象？" + (stu == stu1));        c1.show();        c2.show();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152310394.png" alt="原型模式2"></p><p><font color="red">说明：</font></p><p>​stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class CitationTest1 {    public static void main(String[] args) throws Exception {        Citation c1 = new Citation();        Student stu = new Student("张三", "西安");        c1.setStu(stu);        //创建对象输出流对象        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("C:\\Users\\Think\\Desktop\\b.txt"));        //将c1对象写出到文件中        oos.writeObject(c1);        oos.close();        //创建对象出入流对象        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("C:\\Users\\Think\\Desktop\\b.txt"));        //读取对象        Citation c2 = (Citation) ois.readObject();        //获取c2奖状所属学生对象        Student stu1 = c2.getStu();        stu1.setName("李四");        //判断stu对象和stu1对象是否是同一个对象        System.out.println("stu和stu1是同一个对象？" + (stu == stu1));        c1.show();        c2.show();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果为：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152310592.png"></p><blockquote><p>注意：Citation类和Student类必须实现Serializable接口，序列化后才可以进行流操作。否则会抛NotSerializableException异常。</p></blockquote><h2 id="四、建造者模式"><a href="#四、建造者模式" class="headerlink" title="四、建造者模式"></a>四、建造者模式</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152311527.png"></p><ul><li>分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。</li><li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</li><li>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</li></ul><h3 id="4-2-结构"><a href="#4-2-结构" class="headerlink" title="4.2 结构"></a>4.2 结构</h3><p>建造者（Builder）模式包含如下角色：</p><ul><li><p>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 </p></li><li><p>具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 </p></li><li><p>产品类（Product）：要创建的复杂对象。</p></li><li><p>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</p></li></ul><p>类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152311795.png"></p><h3 id="4-3-实例"><a href="#4-3-实例" class="headerlink" title="4.3 实例"></a>4.3 实例</h3><p><strong>创建共享单车</strong></p><p>生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。</p><p>这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305152311302.png"></p><p>具体的代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//自行车类public class Bike {    private String frame;    private String seat;    public String getFrame() {        return frame;    }    public void setFrame(String frame) {        this.frame = frame;    }    public String getSeat() {        return seat;    }    public void setSeat(String seat) {        this.seat = seat;    }}// 抽象 builder 类public abstract class Builder {    protected Bike mBike = new Bike();    public abstract void buildFrame();    public abstract void buildSeat();    public abstract Bike createBike();}//摩拜单车Builder类public class MobikeBuilder extends Builder {    @Override    public void buildFrame() {        mBike.setFrame("铝合金车架");    }    @Override    public void buildSeat() {        mBike.setSeat("真皮车座");    }    @Override    public Bike createBike() {        return mBike;    }}//ofo单车Builder类public class OfoBuilder extends Builder {    @Override    public void buildFrame() {        mBike.setFrame("碳纤维车架");    }    @Override    public void buildSeat() {        mBike.setSeat("橡胶车座");    }    @Override    public Bike createBike() {        return mBike;    }}//指挥者类public class Director {    private Builder mBuilder;    public Director(Builder builder) {        mBuilder = builder;    }    public Bike construct() {        mBuilder.buildFrame();        mBuilder.buildSeat();        return mBuilder.createBike();    }}//测试类public class Client {    public static void main(String[] args) {        showBike(new OfoBuilder());        showBike(new MobikeBuilder());    }    private static void showBike(Builder builder) {        Director director = new Director(builder);        Bike bike = director.construct();        System.out.println(bike.getFrame());        System.out.println(bike.getSeat());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：</strong></p><p>上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 抽象 builder 类public abstract class Builder {    protected Bike mBike = new Bike();    public abstract void buildFrame();    public abstract void buildSeat();    public abstract Bike createBike();        public Bike construct() {        this.buildFrame();        this.BuildSeat();        return this.createBike();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>说明：</strong></p><p>这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。</p><h3 id="4-4-优缺点"><a href="#4-4-优缺点" class="headerlink" title="4.4 优缺点"></a>4.4 优缺点</h3><p><strong>优点：</strong></p><ul><li>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</li><li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</li></ul><p><strong>缺点：</strong></p><p>造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p><h3 id="4-5-使用场景"><a href="#4-5-使用场景" class="headerlink" title="4.5 使用场景"></a>4.5 使用场景</h3><p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p><ul><li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li><li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li></ul><h3 id="4-6-模式扩展"><a href="#4-6-模式扩展" class="headerlink" title="4.6 模式扩展"></a>4.6 模式扩展</h3><p>建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。</p><p>重构前代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Phone {    private String cpu;    private String screen;    private String memory;    private String mainboard;    public Phone(String cpu, String screen, String memory, String mainboard) {        this.cpu = cpu;        this.screen = screen;        this.memory = memory;        this.mainboard = mainboard;    }    public String getCpu() {        return cpu;    }    public void setCpu(String cpu) {        this.cpu = cpu;    }    public String getScreen() {        return screen;    }    public void setScreen(String screen) {        this.screen = screen;    }    public String getMemory() {        return memory;    }    public void setMemory(String memory) {        this.memory = memory;    }    public String getMainboard() {        return mainboard;    }    public void setMainboard(String mainboard) {        this.mainboard = mainboard;    }    @Override    public String toString() {        return "Phone{" +                "cpu='" + cpu + '\'' +                ", screen='" + screen + '\'' +                ", memory='" + memory + '\'' +                ", mainboard='" + mainboard + '\'' +                '}';    }}public class Client {    public static void main(String[] args) {        //构建Phone对象        Phone phone = new Phone("intel","三星屏幕","金士顿","华硕");        System.out.println(phone);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。</p><p>重构后代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Phone {    private String cpu;    private String screen;    private String memory;    private String mainboard;    private Phone(Builder builder) {        cpu = builder.cpu;        screen = builder.screen;        memory = builder.memory;        mainboard = builder.mainboard;    }    public static final class Builder {        private String cpu;        private String screen;        private String memory;        private String mainboard;        public Builder() {}        public Builder cpu(String val) {            cpu = val;            return this;        }        public Builder screen(String val) {            screen = val;            return this;        }        public Builder memory(String val) {            memory = val;            return this;        }        public Builder mainboard(String val) {            mainboard = val;            return this;        }        public Phone build() {            return new Phone(this);}    }    @Override    public String toString() {        return "Phone{" +                "cpu='" + cpu + '\'' +                ", screen='" + screen + '\'' +                ", memory='" + memory + '\'' +                ", mainboard='" + mainboard + '\'' +                '}';    }}public class Client {    public static void main(String[] args) {        Phone phone = new Phone.Builder()                .cpu("intel")                .mainboard("华硕")                .memory("金士顿")                .screen("三星")                .build();        System.out.println(phone);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。</p><h2 id="五、创建者模式对比"><a href="#五、创建者模式对比" class="headerlink" title="五、创建者模式对比"></a>五、创建者模式对比</h2><h3 id="5-1-工厂方法模式VS建造者模式"><a href="#5-1-工厂方法模式VS建造者模式" class="headerlink" title="5.1 工厂方法模式VS建造者模式"></a>5.1 工厂方法模式VS建造者模式</h3><p>工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。</p><p>我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。</p><h3 id="5-2-抽象工厂模式VS建造者模式"><a href="#5-2-抽象工厂模式VS建造者模式" class="headerlink" title="5.2 抽象工厂模式VS建造者模式"></a>5.2 抽象工厂模式VS建造者模式</h3><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p><p>建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p><p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>商城项目文档</title>
      <link href="/tur-study/2023/04/24/Project/README/"/>
      <url>/tur-study/2023/04/24/Project/README/</url>
      
        <content type="html"><![CDATA[<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><table><thead><tr><th>依赖</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>SpringBoot</td><td>2.7.7</td><td>MVC框架</td></tr><tr><td>SpringCloud</td><td>2021.0.5</td><td>微服务框架</td></tr><tr><td>SpringCloudAlibaba</td><td>2021.0.5.0</td><td>阿里微服务组件</td></tr><tr><td>Nacos</td><td>2.2.0</td><td>服务注册与配置中心</td></tr><tr><td>Mybatis-Plus</td><td></td><td>ORM框架</td></tr><tr><td>Sa-Token</td><td></td><td>轻量级 Java 权限认证框架</td></tr><tr><td>Spring Security</td><td></td><td>权限认证框架</td></tr><tr><td>Knife4j</td><td></td><td>接口文档聚合工具</td></tr><tr><td>Kibana</td><td></td><td>分析和可视化平台</td></tr><tr><td>ElasticSearch</td><td></td><td>搜索引擎</td></tr><tr><td>RabbitMQ</td><td></td><td>消息队列</td></tr><tr><td>Redis</td><td></td><td>分布式缓存</td></tr><tr><td>Druid</td><td></td><td>数据库连接池</td></tr><tr><td>七牛云</td><td></td><td>七牛云对象存储</td></tr><tr><td>阿里云</td><td></td><td>阿里云对象存储</td></tr><tr><td>SLF4J</td><td></td><td>日志框架</td></tr><tr><td>Lombok</td><td></td><td>简化对象封装工具</td></tr><tr><td>Nginx</td><td></td><td>Http和反向代理web服务器</td></tr><tr><td>JustAuth</td><td></td><td>第三方登录工具</td></tr><tr><td>Hutool</td><td></td><td>Java工具包类库</td></tr><tr><td>Zipkin</td><td></td><td>链路追踪</td></tr><tr><td>Ip2region</td><td></td><td>离线IP地址定位库</td></tr><tr><td>Minio</td><td></td><td>本地对象存储服务</td></tr></tbody></table><h2 id="API地址"><a href="#API地址" class="headerlink" title="API地址"></a>API地址</h2><h3 id="前端项目"><a href="#前端项目" class="headerlink" title="前端项目"></a>前端项目</h3><table><thead><tr><th>项目</th><th>端口</th></tr></thead><tbody><tr><td>平台端</td><td>8000</td></tr><tr><td>商家端</td><td>8100</td></tr><tr><td>用户管理端</td><td>8200</td></tr></tbody></table><h3 id="后端服务地址"><a href="#后端服务地址" class="headerlink" title="后端服务地址"></a>后端服务地址</h3><table><thead><tr><th>服务</th><th>地址端口</th></tr></thead><tbody><tr><td>gateway</td><td>8080</td></tr><tr><td>auth</td><td>9001</td></tr><tr><td>biz</td><td>9002</td></tr><tr><td>leaf</td><td>9003</td></tr><tr><td>multishop</td><td>9004</td></tr><tr><td>order</td><td>9005</td></tr><tr><td>payment</td><td>9006</td></tr><tr><td>product</td><td>9007</td></tr><tr><td>rbac</td><td>9008</td></tr><tr><td>search</td><td>9009</td></tr><tr><td>user</td><td>9010</td></tr></tbody></table><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h2 id="每日计划"><a href="#每日计划" class="headerlink" title="每日计划"></a>每日计划</h2><h3 id="2023-x2F-04"><a href="#2023-x2F-04" class="headerlink" title="2023/04"></a>2023/04</h3><h4 id="2023-x2F-04-x2F-25-周二"><a href="#2023-x2F-04-x2F-25-周二" class="headerlink" title="2023/04/25 周二"></a>2023/04/25 周二</h4><ul><li><input checked="" disabled="" type="checkbox"> 定义统一响应类</li><li><input checked="" disabled="" type="checkbox"> 响应枚举码</li><li><input checked="" disabled="" type="checkbox"> 基于美团Leaf的生成id服务</li></ul><h4 id="2023-x2F-04-x2F-26-周三"><a href="#2023-x2F-04-x2F-26-周三" class="headerlink" title="2023/04/26 周三"></a>2023/04/26 周三</h4><ul><li><input checked="" disabled="" type="checkbox"> 自定义统一异常处理 </li><li><input checked="" disabled="" type="checkbox"> 拷贝工具</li><li><input checked="" disabled="" type="checkbox"> 代码生成器模块</li><li><input checked="" disabled="" type="checkbox"> 网关模块构建</li><li><input checked="" disabled="" type="checkbox"> 依据前端定义相应响应码</li><li><input disabled="" type="checkbox"> 用户账号登录<ul><li><input checked="" disabled="" type="checkbox"> 账号授权表</li><li><input checked="" disabled="" type="checkbox"> redis方法定义</li><li><input disabled="" type="checkbox"> 获取用户信息</li><li><input disabled="" type="checkbox"> redis存储用户信息</li><li><input disabled="" type="checkbox"> 返回token信息</li></ul></li></ul><h4 id="2023-x2F-04-x2F-27-周四"><a href="#2023-x2F-04-x2F-27-周四" class="headerlink" title="2023/04/27 周四"></a>2023/04/27 周四</h4><ul><li><input disabled="" type="checkbox"> 用户登录</li><li><input disabled="" type="checkbox"> 用户注册</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客社区项目文档</title>
      <link href="/tur-study/2023/04/21/Project/%E5%8D%9A%E5%AE%A2%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/"/>
      <url>/tur-study/2023/04/21/Project/%E5%8D%9A%E5%AE%A2%E7%A4%BE%E5%8C%BA%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><table><thead><tr><th>依赖</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>SpringBoot</td><td>2.7.11</td><td>MVC框架</td></tr><tr><td>SpringCloud</td><td>2021.0.5</td><td>微服务框架</td></tr><tr><td>SpringCloudAlibaba</td><td>2021.0.5.0</td><td>阿里微服务组件</td></tr><tr><td>Mybatis-Plus</td><td></td><td>ORM框架</td></tr><tr><td>Sa-Token</td><td></td><td>轻量级 Java 权限认证框架</td></tr><tr><td>Knife4j</td><td></td><td>接口文档聚合工具</td></tr><tr><td>Kibana</td><td></td><td>分析和可视化平台</td></tr><tr><td>ElasticSearch</td><td></td><td>搜索引擎</td></tr><tr><td>RabbitMQ</td><td></td><td>消息队列</td></tr><tr><td>Redis</td><td></td><td>分布式缓存</td></tr><tr><td>Druid</td><td></td><td>数据库连接池</td></tr><tr><td>七牛云</td><td></td><td>七牛云对象存储</td></tr><tr><td>阿里云</td><td></td><td>阿里云对象存储</td></tr><tr><td>SLF4J</td><td></td><td>日志框架</td></tr><tr><td>Lombok</td><td></td><td>简化对象封装工具</td></tr><tr><td>Nginx</td><td></td><td>Http和反向代理web服务器</td></tr><tr><td>JustAuth</td><td></td><td>第三方登录工具</td></tr><tr><td>Hutool</td><td></td><td>Java工具包类库</td></tr><tr><td>Zipkin</td><td></td><td>链路追踪</td></tr><tr><td>Flexmark-java</td><td></td><td>Markdown转换html</td></tr><tr><td>Ip2region</td><td></td><td>离线IP地址定位库</td></tr><tr><td>Minio</td><td></td><td>本地对象存储服务</td></tr></tbody></table><h2 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h2>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm操作命令</title>
      <link href="/tur-study/2023/04/20/Vue/npm%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
      <url>/tur-study/2023/04/20/Vue/npm%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install --registry=https://registry.npm.taobao.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>建议不要用cnpm  安装有各种诡异的bug </p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinIO使用详解</title>
      <link href="/tur-study/2023/04/19/SpringBoot/MinIO%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/04/19/SpringBoot/MinIO%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>MinIO 是一个非常轻量的服务,可以很简单的 和其他应用的结合使用，它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量 非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等。 </p><p>它一大特点就是<code>轻量</code>，使用简单，功能强大，支持各种平台，单个文件最大 5TB，兼 容 Amazon S3 接口，提供了 Java、Python、GO 等多版本 SDK 支</p><blockquote><p>官网：<a href="https://min.io/">https://min.io</a> </p><p>中文：<a href="https://www.minio.org.cn/%EF%BC%8Chttp://docs.minio.org.cn/docs/">https://www.minio.org.cn/，http://docs.minio.org.cn/docs/</a></p></blockquote><p>MinIO 集群采用<font color="red">去中心化</font>共享架构，每个结点是对等关系，通过 Nginx 可对 MinIO 进 行负载均衡访问</p><blockquote><p>去中心化有什么好处？ </p></blockquote><p>在大数据领域，通常的设计理念都是无中心和分布式。Minio 分布式模式可以帮助你搭 建一个高可用的对象存储服务，你可以使用这些存储设备，而不用考虑其真实物理位 置。</p><p> 它将分布在不同服务器上的多块硬盘组成一个对象存储服务。由于硬盘分布在不同的 节点上，分布式 Minio 避免了单点故障。如下图：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191532888.png"></p><p>Minio 使用<font color="red">纠删码技术</font>来保护数据，它是一种恢复丢失和损坏数据的数学算法，它将数 据分块冗余的分散存储在各各节点的磁盘上，所有的可用磁盘组成一个集合，上图由 8 块硬盘组成一个集合，当上传一个文件时会通过纠删码算法计算对文件进行分块存 储，除了将文件本身分成 4 个数据块，还会生成 4 个校验块，数据块和校验块会分散 的存储在这 8 块硬盘上。 </p><p>使用纠删码的好处是即便丢失一半数量（N/2）的硬盘，仍然可以恢复数据。 比如上 边集合中有 4 个以内的硬盘损害仍可保证数据恢复，不影响上传和下载，如果多于一 半的硬盘坏了则无法恢复。</p><h2 id="二、MinIO数据恢复演示"><a href="#二、MinIO数据恢复演示" class="headerlink" title="二、MinIO数据恢复演示"></a>二、MinIO数据恢复演示</h2><h3 id="2-1-MinIO的运行"><a href="#2-1-MinIO的运行" class="headerlink" title="2.1 MinIO的运行"></a>2.1 MinIO的运行</h3><h4 id="1-下载-MinIO"><a href="#1-下载-MinIO" class="headerlink" title="1. 下载 MinIO"></a>1. 下载 MinIO</h4><blockquote><p>下载地址：<a href="https://dl.min.io/server/minio/release/">https://dl.min.io/server/minio/release/</a></p></blockquote><ol><li>进入下载地址，相应的操作系统选择对应的安装包</li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191536992.png"></p><ol start="2"><li>选择 <code>minio.exe</code> 下载</li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191537689.png" alt="image-20230419153715623"></p><h4 id="2-命令行运行-minio-exe"><a href="#2-命令行运行-minio-exe" class="headerlink" title="2. 命令行运行 minio.exe"></a>2. 命令行运行 minio.exe</h4><blockquote><p>演示系统为：windows</p></blockquote><p>cmd 进入有 minio.exe 的目录。运行下边命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">minio.exe server D:\develop\minio_data\data1 D:\develop\minio_data\data2 D:\develop\minio_data\data3 D:\develop\minio_data\data4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中，<code>D:\develop\minio_data\data1、2、3、4</code>为自定义的目录。即数据硬盘，用来存放文件</p><p>启动结果如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191541822.png" alt="image-20230419154123725"></p><p>说明如下：</p><pre class="line-numbers language-none"><code class="language-none">WARNING: MINIO_ACCESS_KEY and MINIO_SECRET_KEY are deprecated. Please use MINIO_ROOT_USER and MINIO_ROOT_PASSWORDFormatting 1st pool, 1 set(s), 4 drives per set.WARNING: Host local has more than 2 drives of set. A host failurewill result in data becoming unavailable.WARNING: Detected default credentials 'minioadmin:minioadmin', we recommend that you change these values with 'MINIO_ROOT_USER' and 'MINIO_ROOT_PASSWORD' environment variabl<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>老版本使用的 MINIO_ACCESS_KEY 和 MINIO_SECRET_KEY 不推荐使用，推荐使用 MINIO_ROOT_USER 和 MINIO_ROOT_PASSWORD 设置账号和密码。</li><li>pool 即 minio 节点组成的池子，当前有一个 pool 和 4 个硬盘组成的 set 集合 </li><li>因为集合是 4 个硬盘，大于 2 的硬盘损坏数据将无法恢复。</li><li>账号和密码默认为 minioadmin、minioadmin，可以在环境变量中设置通过 ‘<code>MINIO_ROOT_USER</code>‘ and ‘<code>MINIO_ROOT_PASSWORD</code>‘ 进行设置</li></ol><h4 id="3-MinIO-Web界面"><a href="#3-MinIO-Web界面" class="headerlink" title="3. MinIO Web界面"></a>3. MinIO Web界面</h4><p>浏览器输入 <code>http://localhost:9000</code> 进入web界面</p><blockquote><p>MinIO 的默认端口是 9000</p></blockquote><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191545750.png"></p><p>登陆成功后，下一步创建 bucket，桶，它相当于存储文件的目录，可以创建若干的桶。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191546377.png"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191547579.png" alt="image-20230419154734511"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191547871.png" alt="image-20230419154756833"></p><h4 id="4-文件上传"><a href="#4-文件上传" class="headerlink" title="4. 文件上传"></a>4. 文件上传</h4><p>点击创建的 Bucket 的 <code>upload</code>，上传文件</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191550758.png" alt="image-20230419155036711"></p><p>打开之前建立好的4个数据盘，观察文件的存储情况：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304191552498.png" alt="image-20230419155202452"></p><p>可以看到，上传的文件在四个目录上都有存储，即4个硬盘上</p><p>测试：删除一个、两个目录后，删除的目录会自动恢复。但删除三个目录后，有大于一半的数据盘损坏，数据无法恢复，此时报错：We encountered an internal error, please try again. (Read failed. Insufficient number of drives online)在线驱动器数量不足</p><h3 id="2-2-Docker-中安装-minio"><a href="#2-2-Docker-中安装-minio" class="headerlink" title="2.2 Docker 中安装 minio"></a>2.2 Docker 中安装 minio</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run -d -p 9000:9000 -p 9090:9090 --name minio \-e "MINIO_ACCESS_KEY=minio" \-e "MINIO_SECRET_KEY=minio123" \-v /home/admin/minio/data:/data \-v /home/admin/minio/config:/root/.minio \minio/minio server /data \--console-address ":9000" --address ":9090"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、SpringBoot-中使用-MinIO"><a href="#三、SpringBoot-中使用-MinIO" class="headerlink" title="三、SpringBoot 中使用 MinIO"></a>三、SpringBoot 中使用 MinIO</h2><p>maven 依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- minio --&gt;</span>                               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>                                     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.minio<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>minio<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>               <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>8.5.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>                                                                             <span class="token comment">&lt;!-- okhttp --&gt;</span>                              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>                                     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.squareup.okhttp3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>okhttp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.9.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>                                <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-上传文件"><a href="#3-1-上传文件" class="headerlink" title="3.1 上传文件"></a>3.1 上传文件</h3><ul><li><p>在 MInIO 中创建一个 Bucket</p><p>Bucket 的命名只允许全小写。不允许大写字母</p></li><li><p>将 Access Policy 的权限 private 更改为 public</p></li><li><p>如下是测试上传文件的代码。以上传图片为例</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MinioTest {    private static final MinioClient minioClient = MinioClient.builder()            .endpoint("http://localhost:9090")            .credentials("minio", "minio123")            .build();    public static void upload() throws ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException {        // 判断是否存在Bucket。若不存在则新建        boolean found = minioClient.bucketExists(BucketExistsArgs.builder().bucket("testbucket").build());        if (!found) {            minioClient.makeBucket(MakeBucketArgs.builder().bucket("testbucket").build());        } else {            System.out.println("Bucket is already exists!");        }        // 上传文件        minioClient.uploadObject(UploadObjectArgs.builder()                .bucket("testbucket") // Bucket                .object("list.jpg") // MinIO上文件名                .filename("C:\\Users\\18517\\Desktop\\list.jpg") // 文件地址                .build());        System.out.println("上传成功");    }    public static void main(String[] args) throws ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException {        upload();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>==注意事项：==</p><p>新版的 MinIO 的容器端口是 9000， 而对外的API接口是 9090。即访问 MinIO控制台时使用 9000 端口，而使用 MinIO 进行文件操作时，需要使用 9090 端口</p></blockquote><h3 id="3-2-查询文件"><a href="#3-2-查询文件" class="headerlink" title="3.2 查询文件"></a>3.2 查询文件</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MinioTest {    private static final MinioClient minioClient = MinioClient.builder()            .endpoint("http://1.12.233.28:9090")            .credentials("minio", "minio123")            .build();    public static void getFile() throws ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException {        // 获取文件流        InputStream stream = minioClient.getObject(GetObjectArgs.builder()                        .bucket("testbucket")                        .object("list.jpg")                .build());        // 存放的文件地址        FileOutputStream fileOutputStream = new FileOutputStream(new File("C:\\Users\\18517\\Desktop\\list.jpg"));        // IO流复制        IOUtils.copy(stream, fileOutputStream);        System.out.println("下载成功");    }    public static void main(String[] args) throws ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException {        getFile();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-删除文件"><a href="#3-3-删除文件" class="headerlink" title="3.3 删除文件"></a>3.3 删除文件</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MinioTest {    private static final MinioClient minioClient = MinioClient.builder()            .endpoint("http://1.12.233.28:9090")            .credentials("minio", "minio123")            .build();    public static void delete() throws ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException {        minioClient.removeObject(RemoveObjectArgs.builder()                        .bucket("testbucket")                        .object("list.jpg")                .build());        System.out.println("删除成功");    }    public static void main(String[] args) throws ServerException, InsufficientDataException, ErrorResponseException, IOException, NoSuchAlgorithmException, InvalidKeyException, InvalidResponseException, XmlParserException, InternalException {        delete();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux安装常用应用</title>
      <link href="/tur-study/2023/04/18/linux/linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8/"/>
      <url>/tur-study/2023/04/18/linux/linux%E5%AE%89%E8%A3%85%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="安装-jdk"><a href="#安装-jdk" class="headerlink" title="安装 jdk"></a>安装 jdk</h3><h4 id="1-写在-openJDK，安装-Oracle-提供的JDK"><a href="#1-写在-openJDK，安装-Oracle-提供的JDK" class="headerlink" title="1. 写在 openJDK，安装 Oracle 提供的JDK"></a>1. 写在 openJDK，安装 Oracle 提供的JDK</h4>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot Web 注解详解</title>
      <link href="/tur-study/2023/04/14/SpringBoot/SpringBoot%20Web%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/04/14/SpringBoot/SpringBoot%20Web%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>主要用于将请求参数区域的数据映射到控制层方法的参数上</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ol><li><code>value</code>：请求中传入参数的名称，若不设置后台接口的 value 值，则<font color="red">默认为该变量名</font></li><li><code>required</code>：该参数是否为必传项。<ul><li><font color="red">默认是 true</font>，表示请求中一定要传入对应的参数，否则会报<font color="red">404</font> 错误。</li><li>如果设置为 false 时，当请求中没有此参数时，则会默认为 null。二对于基本数据类型的变量，则必须有值，这时会抛出空指针异常。如果允许控制，则接口中变量需要使用包装类来声明，不用 int 而是 Integer 来声明整型数字</li></ul></li><li><code>defaultValue</code>：参数的默认值，如果请求中没有同名的参数时，该变量默认为此值注意默认值可以使用SpEL表达式，如”#{systemProperties[‘java.vm.version’]}”</li></ol><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果在请求中传入多个同名参数，比如：<code>url?userName=zhl&amp;userName=holley</code>时怎么办？</p><p>其实此时传入的数据格式是：“zhl,holley”,即多个数据之间使用逗号分隔开，在后台接口中可以使用数组或者list类型的变量来接收：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public String requestparam8(@RequestParam(value="userName") String []  userNames) 或者public String requestparam8(@RequestParam(value="list") List&lt;String&gt; list) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis Plus 中CRUD接口注意事项</title>
      <link href="/tur-study/2023/04/13/MybatisPlus/Mybatis%20Plus%20%E4%B8%ADCRUD%E6%8E%A5%E5%8F%A3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/tur-study/2023/04/13/MybatisPlus/Mybatis%20Plus%20%E4%B8%ADCRUD%E6%8E%A5%E5%8F%A3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>官网：<a href="https://baomidou.com/">https://baomidou.com/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Mybatis Plus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA中创建文件模板</title>
      <link href="/tur-study/2023/04/10/IDEA/IDEA%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF/"/>
      <url>/tur-study/2023/04/10/IDEA/IDEA%E4%B8%AD%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>在 IDEA 中创建适合自己项目的文件模板，可以在新建文件时，免去一些常规重复的操作，如一些类中常添加的注解如@Data、@Builder等等，创建文件时，自动导入这些可以提高些许效率。</p><p>so， 开始吧。</p><p>下面以创建 pojo 模型类为例：</p><p>创建 pojo 模型类时，一般需要添加注解：</p><ul><li>@Data</li><li>@Builder</li><li>@NoArgsConstructor</li><li>@AllArgsConstrustor</li></ul><blockquote><p>至于这些注解的用处，想必都知道</p></blockquote><p>所以，目标便是将添加的注解放入到模板</p><p>步骤如下：</p><h5 id="1-打开：设置-gt-编辑器-gt-文件和代码模板"><a href="#1-打开：设置-gt-编辑器-gt-文件和代码模板" class="headerlink" title="1. 打开：设置 -> 编辑器 -> 文件和代码模板"></a>1. 打开：设置 -&gt; 编辑器 -&gt; 文件和代码模板</h5><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304102117353.png" alt="image-20230410211734116"></p><h5 id="2-在文件栏里新建文件"><a href="#2-在文件栏里新建文件" class="headerlink" title="2. 在文件栏里新建文件"></a>2. 在文件栏里新建文件</h5><ul><li><p>名称的命名随意，建议文件名容易知道它的用处。</p></li><li><p>文件扩展名默认 java。如果需要创建其他类型的需要改动</p></li><li><p>文件名(F)：即新建的类文件的文件名。书写格式如下：<code>$ClassName</code></p><blockquote><p>注：ClassName可以自定义，在新建文件时会出现的新建窗口，填写的值即文件名</p></blockquote></li></ul><h5 id="3-在编辑框里编写模板"><a href="#3-在编辑框里编写模板" class="headerlink" title="3. 在编辑框里编写模板"></a>3. 在编辑框里编写模板</h5><ul><li>添加类的javadoc注释</li><li>添加注解</li><li>添加类的定义</li></ul><p>内容如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import lombok.Builder;/*** @author ${USER}* @date ${DATE} ${TIME}* @description TODO* @version 1.0*/@Data@Builder@AllArgsConstructor@NoArgsConstructorpublic class $ClassName  {}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>$ClassName</code> 需要与上方填写的文件名一致，保证文件名和类名一致</p><h5 id="4-创建好的模板如下所示："><a href="#4-创建好的模板如下所示：" class="headerlink" title="4.创建好的模板如下所示："></a>4.创建好的模板如下所示：</h5><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304102124535.png" alt="image-20230410211734116"></p><h5 id="5-模板的使用："><a href="#5-模板的使用：" class="headerlink" title="5. 模板的使用："></a>5. 模板的使用：</h5><blockquote><p>创建好的模板记得点应用</p></blockquote><p>在新建选项可以看到新建的模板出现了：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304102125891.png" alt="image-20230410212516834"></p><p>点击新建的模板，弹出填写 ClassName（文件名）的窗口：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304102126186.png" alt="image-20230410212615151"></p><p>填写你需要的文件名，即可创建成功文件。</p>]]></content>
      
      
      <categories>
          
          <category> IDEA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间相关类的使用</title>
      <link href="/tur-study/2023/04/10/Java/%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/04/10/Java/%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Calendar-类"><a href="#Calendar-类" class="headerlink" title="Calendar 类"></a>Calendar 类</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p><code>Calendar </code>类是一个抽象类，它为特定瞬间与 <code>YEAR、MONTH、DAY_OF—MONTH、HOUR </code>等日历字段之间的转换提供了一些方法，并为操作日历字段（如获得下星期的日期） 提供了一些方法</p><p>在实际使用时实现特定的子类的对象，创建对象的过程对程序员来说是透明的，只需要使用getInstance方法创建即可</p><h5 id="创建一个代表系统当前日期的-Calendar-对象"><a href="#创建一个代表系统当前日期的-Calendar-对象" class="headerlink" title="创建一个代表系统当前日期的 Calendar 对象"></a>创建一个代表系统当前日期的 Calendar 对象</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">Calendar c = Calendar.getInstance(); //默认是当前日期<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="创建一个指定日期的-Calendar-对象"><a href="#创建一个指定日期的-Calendar-对象" class="headerlink" title="创建一个指定日期的 Calendar 对象"></a>创建一个指定日期的 Calendar 对象</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">//创建一个代表2019年12月22日的Calendar对象Calendar c1 = Calendar.getInstance();c1.set(2019, 12 - 1, 22);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>==注：==<font color="red">月份 - 1 </font>是因为 Calendar 中月份是从 0 开始计数，即一月为0，12月为11</p></blockquote><h3 id="2-Calendar-类对象字段类型"><a href="#2-Calendar-类对象字段类型" class="headerlink" title="2. Calendar 类对象字段类型"></a>2. Calendar 类对象字段类型</h3><p> Calendar类中用以下这些常量表示不同的意义，jdk内的很多类其实都是采用的这种思想</p><table><thead><tr><th>常量</th><th>描述</th></tr></thead><tbody><tr><td>Calendar.YEAR</td><td>年份</td></tr><tr><td>Calendar.MONTH</td><td>月份</td></tr><tr><td>Calendar.DATE</td><td>日期</td></tr><tr><td>Calendar.DAY_OF_MONTH</td><td>日期，和上面的字段意义完全相同</td></tr><tr><td>Calendar.HOUR</td><td>12小时制的小时</td></tr><tr><td>Calendar.HOUR_OF_DAY</td><td>24小时制的小时</td></tr><tr><td>Calendar.MINUTE</td><td>分钟</td></tr><tr><td>Calendar.SECOND</td><td>秒</td></tr><tr><td>Calendar.DAY_OF_WEEK</td><td>星期几</td></tr></tbody></table><h3 id="3-Calendar-类对象信息的设置"><a href="#3-Calendar-类对象信息的设置" class="headerlink" title="3. Calendar 类对象信息的设置"></a>3. Calendar 类对象信息的设置</h3><h4 id="3-1-Set-设置"><a href="#3-1-Set-设置" class="headerlink" title="3.1 Set 设置"></a>3.1 Set 设置</h4><p>如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Calendar c1 = Calendar.getInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>调用：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public final void set(int year,int month,int date)c1.set(2009, 6, 12);//把Calendar对象c1的年月日分别设这为：2009、6、12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>利用字段类型设置</p><p>如果只设定某个字段，例如日期的值，则可以使用如下set方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void set(int field,int value)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把 c1对象代表的日期设置为10号，其它所有的数值会被重新计算</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">c1.set(Calendar.DATE,10);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把c1对象代表的年份设置为2008年，其他的所有数值会被重新计算</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">c1.set(Calendar.YEAR,2008);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他字段属性set的意义以此类推</p><h4 id="3-2-Add-设置"><a href="#3-2-Add-设置" class="headerlink" title="3.2 Add 设置"></a>3.2 Add 设置</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">Calendar c1 = Calendar.getInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把c1对象的日期加上10，也就是c1也就表示为10天后的日期，其它所有的数值会被重新计算</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">c1.add(Calendar.DATE, 10);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把c1对象的日期减去10，也就是c1也就表示为10天前的日期，其它所有的数值会被重新计算</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">c1.add(Calendar.DATE, -10);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其他字段属性的add的意义以此类推</p><h3 id="4-Calendar-类对象信息的获得"><a href="#4-Calendar-类对象信息的获得" class="headerlink" title="4. Calendar 类对象信息的获得"></a>4. Calendar 类对象信息的获得</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">Calendar c1 = Calendar.getInstance();// 获得年份int year = c1.get(Calendar.YEAR);// 获得月份int month = c1.get(Calendar.MONTH) + 1;// 获得日期int date = c1.get(Calendar.DATE);// 获得小时int hour = c1.get(Calendar.HOUR_OF_DAY);// 获得分钟int minute = c1.get(Calendar.MINUTE);// 获得秒int second = c1.get(Calendar.SECOND);// 获得星期几（注意（这个与Date类是不同的）：1代表星期日、2代表星期1、3代表星期二，以此类推）int day = c1.get(Calendar.DAY_OF_WEEK);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-GregorianCalendar-类"><a href="#5-GregorianCalendar-类" class="headerlink" title="5. GregorianCalendar 类"></a>5. GregorianCalendar 类</h3><p>Calendar类实现了公历日历，GregorianCalendar是Calendar类的一个具体实现。</p><p>Calendar 的getInstance（）方法返回一个默认用当前的语言环境和时区初始化的GregorianCalendar对象。GregorianCalendar定义了两个字段：AD和BC。这是代表公历定义的两个时代。</p><p>下面列出GregorianCalendar对象的几个构造方法：</p><table><thead><tr><th align="left"><strong>序号</strong></th><th><strong>构造函数和说明</strong></th></tr></thead><tbody><tr><td align="left">1</td><td><strong>GregorianCalendar()</strong>   在具有默认语言环境的默认时区内使用当前时间构造一个默认的 GregorianCalendar。</td></tr><tr><td align="left">2</td><td><strong>GregorianCalendar(int year, int month, int date)</strong>   在具有默认语言环境的默认时区内构造一个带有给定日期设置的 GregorianCalendar</td></tr><tr><td align="left">3</td><td><strong>GregorianCalendar(int year, int month, int date, int hour, int minute)</strong>   为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。</td></tr><tr><td align="left">4</td><td><strong>GregorianCalendar(int year, int month, int date, int hour, int minute, int second)</strong>    为具有默认语言环境的默认时区构造一个具有给定日期和时间设置的 GregorianCalendar。</td></tr><tr><td align="left">5</td><td><strong>GregorianCalendar(Locale aLocale)</strong>   在具有给定语言环境的默认时区内构造一个基于当前时间的 GregorianCalendar。</td></tr><tr><td align="left">6</td><td><strong>GregorianCalendar(TimeZone zone)</strong>   在具有默认语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。</td></tr><tr><td align="left">7</td><td><strong>GregorianCalendar(TimeZone zone, Locale aLocale)</strong>    在具有给定语言环境的给定时区内构造一个基于当前时间的 GregorianCalendar。</td></tr></tbody></table><p>这里是GregorianCalendar 类提供的一些有用的方法列表：</p><table><thead><tr><th><strong>序号</strong></th><th><strong>方法和说明</strong></th></tr></thead><tbody><tr><td>1</td><td><strong>void add(int field, int amount)</strong>   根据日历规则，将指定的（有符号的）时间量添加到给定的日历字段中。</td></tr><tr><td>2</td><td><strong>protected void computeFields()</strong>   转换UTC毫秒值为时间域值</td></tr><tr><td>3</td><td><strong>protected void computeTime()</strong>   覆盖Calendar ，转换时间域值为UTC毫秒值</td></tr><tr><td>4</td><td><strong>boolean equals(Object obj)</strong>   比较此 GregorianCalendar 与指定的 Object。</td></tr><tr><td>5</td><td><strong>int get(int field)</strong>   获取指定字段的时间值</td></tr><tr><td>6</td><td><strong>int getActualMaximum(int field)</strong>   返回当前日期，给定字段的最大值</td></tr><tr><td>7</td><td><strong>int getActualMinimum(int field)</strong>   返回当前日期，给定字段的最小值</td></tr><tr><td>8</td><td><strong>int getGreatestMinimum(int field)</strong>    返回此 GregorianCalendar 实例给定日历字段的最高的最小值</td></tr><tr><td>9</td><td><strong>Date getGregorianChange()</strong>   获得格里高利历的更改日期。</td></tr><tr><td>10</td><td><strong>int getLeastMaximum(int field)</strong>   返回此 GregorianCalendar 实例给定日历字段的最低的最大值</td></tr><tr><td>11</td><td><strong>int getMaximum(int field)</strong>   返回此 GregorianCalendar 实例的给定日历字段的最大值。</td></tr><tr><td>12</td><td><strong>Date getTime()</strong>  获取日历当前时间。</td></tr><tr><td>13</td><td><strong>long getTimeInMillis()</strong>   获取用长整型表示的日历的当前时间</td></tr><tr><td>14</td><td><strong>TimeZone getTimeZone()</strong>   获取时区。</td></tr><tr><td>15</td><td><strong>int getMinimum(int field)</strong>   返回给定字段的最小值。</td></tr><tr><td>16</td><td><strong>int hashCode()</strong>   重写hashCode.</td></tr><tr><td>17</td><td><strong>boolean isLeapYear(int year)</strong>  确定给定的年份是否为闰年。</td></tr><tr><td>18</td><td><strong>void roll(int field, boolean up)</strong>   在给定的时间字段上添加或减去（上/下）单个时间单元，不更改更大的字段。</td></tr><tr><td>19</td><td><strong>void set(int field, int value)</strong>   用给定的值设置时间字段。</td></tr><tr><td>20</td><td><strong>void set(int year, int month, int date)</strong>   设置年、月、日的值。</td></tr><tr><td>21</td><td><strong>void set(int year, int month, int date, int hour, int minute)</strong>   设置年、月、日、小时、分钟的值。</td></tr><tr><td>22</td><td><strong>void set(int year, int month, int date, int hour, int minute, int second)</strong>   设置年、月、日、小时、分钟、秒的值。</td></tr><tr><td>23</td><td><strong>void setGregorianChange(Date date)</strong>   设置 GregorianCalendar 的更改日期。</td></tr><tr><td>24</td><td><strong>void setTime(Date date)</strong>   用给定的日期设置Calendar的当前时间。</td></tr><tr><td>25</td><td><strong>void setTimeInMillis(long millis)</strong>   用给定的long型毫秒数设置Calendar的当前时间。</td></tr><tr><td>26</td><td><strong>void setTimeZone(TimeZone value)</strong>   用给定时区值设置当前时区。</td></tr><tr><td>27</td><td><strong>String toString()</strong>   返回代表日历的字符串。</td></tr></tbody></table><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;  public class GregorianCalendarDemo {    public static void main(String[] args) {      String months[] = {      "Jan", "Feb", "Mar", "Apr",      "May", "Jun", "Jul", "Aug",      "Sep", "Oct", "Nov", "Dec"};            int year;      // 初始化 Gregorian 日历      // 使用当前时间和日期      // 默认为本地时间和时区      GregorianCalendar gcalendar = new GregorianCalendar();      // 显示当前时间和日期的信息      System.out.print("Date: ");      System.out.print(months[gcalendar.get(Calendar.MONTH)]);      System.out.print(" " + gcalendar.get(Calendar.DATE) + " ");      System.out.println(year = gcalendar.get(Calendar.YEAR));      System.out.print("Time: ");      System.out.print(gcalendar.get(Calendar.HOUR) + ":");      System.out.print(gcalendar.get(Calendar.MINUTE) + ":");      System.out.println(gcalendar.get(Calendar.SECOND));            // 测试当前年份是否为闰年      if(gcalendar.isLeapYear(year)) {         System.out.println("当前年份是闰年");      }      else {         System.out.println("当前年份不是闰年");      }   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上实例编译运行结果如下：</p><pre class="line-numbers language-none"><code class="language-none">Date: Apr 10 2023Time: 11:25:27当前年份不是闰年<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="6-实例：获取从去年这时到现在的日期"><a href="#6-实例：获取从去年这时到现在的日期" class="headerlink" title="6. 实例：获取从去年这时到现在的日期"></a>6. 实例：获取从去年这时到现在的日期</h3><p>在数据统计中，会遇到需要展示从去年这时到现在的所有日期的数据，如：2022-04-11到2023-04-11之间的所有日期，此处展示如何获取一年的日期</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class DateUtils {    /**     * 日期格式     * */    public static final String YYYY_MM_DD = "yyyy-MM-dd";    /**     * @description 将date按照指定的格式转换成字符串     * @param date 日期     * @param code 日期格式。如：yyyy-MM-DD hh:mm:ss     * @return java.lang.String    */            public static String formatDate(Date date, String code){        SimpleDateFormat format = new SimpleDateFormat(code);        return format.format(date);    }    public static void main(String[] args) {        List&lt;String&gt; dateList = new ArrayList&lt;&gt;();        Date date = new Date();        // 获取当前日期        Calendar calendar = Calendar.getInstance();        // 指定时间为去年这时。即 year - 1        calendar.add(Calendar.YEAR, -1);        // 将获取时间添加入数组中        dateList.add(DateUtils.formatDate(calendar.getTime(), DateUtils.YYYY_MM_DD));        // 获取下一天日期        while (date.after(calendar.getTime())) { //倒序时间,顺序:after改before其他相应的改动。            calendar.add(Calendar.DAY_OF_MONTH, 1);            dateList.add(DateUtils.formatDate(calendar.getTime(), DateUtils.YYYY_MM_DD));        }        System.out.println(dateList.toString());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实例的测试结果为：</p><pre class="line-numbers language-none"><code class="language-none">[2022-04-11, 2022-04-12, 2022-04-13, 2022-04-14, 2022-04-15, 2022-04-16, 2022-04-17, 2022-04-18, 2022-04-19, 2022-04-20, 2022-04-21, 2022-04-22, 2022-04-23, 2022-04-24, 2022-04-25, 2022-04-26, 2022-04-27, 2022-04-28, 2022-04-29, 2022-04-30, 2022-05-01, 2022-05-02, 2022-05-03, 2022-05-04, 2022-05-05, 2022-05-06, 2022-05-07, 2022-05-08, 2022-05-09, 2022-05-10, 2022-05-11, 2022-05-12, 2022-05-13, 2022-05-14, 2022-05-15, 2022-05-16, 2022-05-17, 2022-05-18, 2022-05-19, 2022-05-20, 2022-05-21, 2022-05-22, 2022-05-23, 2022-05-24, 2022-05-25, 2022-05-26, 2022-05-27, 2022-05-28, 2022-05-29, 2022-05-30, 2022-05-31, 2022-06-01, 2022-06-02, 2022-06-03, 2022-06-04, 2022-06-05, 2022-06-06, 2022-06-07, 2022-06-08, 2022-06-09, 2022-06-10, 2022-06-11, 2022-06-12, 2022-06-13, 2022-06-14, 2022-06-15, 2022-06-16, 2022-06-17, 2022-06-18, 2022-06-19, 2022-06-20, 2022-06-21, 2022-06-22, 2022-06-23, 2022-06-24, 2022-06-25, 2022-06-26, 2022-06-27, 2022-06-28, 2022-06-29, 2022-06-30, 2022-07-01, 2022-07-02, 2022-07-03, 2022-07-04, 2022-07-05, 2022-07-06, 2022-07-07, 2022-07-08, 2022-07-09, 2022-07-10, 2022-07-11, 2022-07-12, 2022-07-13, 2022-07-14, 2022-07-15, 2022-07-16, 2022-07-17, 2022-07-18, 2022-07-19, 2022-07-20, 2022-07-21, 2022-07-22, 2022-07-23, 2022-07-24, 2022-07-25, 2022-07-26, 2022-07-27, 2022-07-28, 2022-07-29, 2022-07-30, 2022-07-31, 2022-08-01, 2022-08-02, 2022-08-03, 2022-08-04, 2022-08-05, 2022-08-06, 2022-08-07, 2022-08-08, 2022-08-09, 2022-08-10, 2022-08-11, 2022-08-12, 2022-08-13, 2022-08-14, 2022-08-15, 2022-08-16, 2022-08-17, 2022-08-18, 2022-08-19, 2022-08-20, 2022-08-21, 2022-08-22, 2022-08-23, 2022-08-24, 2022-08-25, 2022-08-26, 2022-08-27, 2022-08-28, 2022-08-29, 2022-08-30, 2022-08-31, 2022-09-01, 2022-09-02, 2022-09-03, 2022-09-04, 2022-09-05, 2022-09-06, 2022-09-07, 2022-09-08, 2022-09-09, 2022-09-10, 2022-09-11, 2022-09-12, 2022-09-13, 2022-09-14, 2022-09-15, 2022-09-16, 2022-09-17, 2022-09-18, 2022-09-19, 2022-09-20, 2022-09-21, 2022-09-22, 2022-09-23, 2022-09-24, 2022-09-25, 2022-09-26, 2022-09-27, 2022-09-28, 2022-09-29, 2022-09-30, 2022-10-01, 2022-10-02, 2022-10-03, 2022-10-04, 2022-10-05, 2022-10-06, 2022-10-07, 2022-10-08, 2022-10-09, 2022-10-10, 2022-10-11, 2022-10-12, 2022-10-13, 2022-10-14, 2022-10-15, 2022-10-16, 2022-10-17, 2022-10-18, 2022-10-19, 2022-10-20, 2022-10-21, 2022-10-22, 2022-10-23, 2022-10-24, 2022-10-25, 2022-10-26, 2022-10-27, 2022-10-28, 2022-10-29, 2022-10-30, 2022-10-31, 2022-11-01, 2022-11-02, 2022-11-03, 2022-11-04, 2022-11-05, 2022-11-06, 2022-11-07, 2022-11-08, 2022-11-09, 2022-11-10, 2022-11-11, 2022-11-12, 2022-11-13, 2022-11-14, 2022-11-15, 2022-11-16, 2022-11-17, 2022-11-18, 2022-11-19, 2022-11-20, 2022-11-21, 2022-11-22, 2022-11-23, 2022-11-24, 2022-11-25, 2022-11-26, 2022-11-27, 2022-11-28, 2022-11-29, 2022-11-30, 2022-12-01, 2022-12-02, 2022-12-03, 2022-12-04, 2022-12-05, 2022-12-06, 2022-12-07, 2022-12-08, 2022-12-09, 2022-12-10, 2022-12-11, 2022-12-12, 2022-12-13, 2022-12-14, 2022-12-15, 2022-12-16, 2022-12-17, 2022-12-18, 2022-12-19, 2022-12-20, 2022-12-21, 2022-12-22, 2022-12-23, 2022-12-24, 2022-12-25, 2022-12-26, 2022-12-27, 2022-12-28, 2022-12-29, 2022-12-30, 2022-12-31, 2023-01-01, 2023-01-02, 2023-01-03, 2023-01-04, 2023-01-05, 2023-01-06, 2023-01-07, 2023-01-08, 2023-01-09, 2023-01-10, 2023-01-11, 2023-01-12, 2023-01-13, 2023-01-14, 2023-01-15, 2023-01-16, 2023-01-17, 2023-01-18, 2023-01-19, 2023-01-20, 2023-01-21, 2023-01-22, 2023-01-23, 2023-01-24, 2023-01-25, 2023-01-26, 2023-01-27, 2023-01-28, 2023-01-29, 2023-01-30, 2023-01-31, 2023-02-01, 2023-02-02, 2023-02-03, 2023-02-04, 2023-02-05, 2023-02-06, 2023-02-07, 2023-02-08, 2023-02-09, 2023-02-10, 2023-02-11, 2023-02-12, 2023-02-13, 2023-02-14, 2023-02-15, 2023-02-16, 2023-02-17, 2023-02-18, 2023-02-19, 2023-02-20, 2023-02-21, 2023-02-22, 2023-02-23, 2023-02-24, 2023-02-25, 2023-02-26, 2023-02-27, 2023-02-28, 2023-03-01, 2023-03-02, 2023-03-03, 2023-03-04, 2023-03-05, 2023-03-06, 2023-03-07, 2023-03-08, 2023-03-09, 2023-03-10, 2023-03-11, 2023-03-12, 2023-03-13, 2023-03-14, 2023-03-15, 2023-03-16, 2023-03-17, 2023-03-18, 2023-03-19, 2023-03-20, 2023-03-21, 2023-03-22, 2023-03-23, 2023-03-24, 2023-03-25, 2023-03-26, 2023-03-27, 2023-03-28, 2023-03-29, 2023-03-30, 2023-03-31, 2023-04-01, 2023-04-02, 2023-04-03, 2023-04-04, 2023-04-05, 2023-04-06, 2023-04-07, 2023-04-08, 2023-04-09, 2023-04-10, 2023-04-11]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sa-Token在微服务中使用</title>
      <link href="/tur-study/2023/04/09/SpringCloud/Sa-Token%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/04/09/SpringCloud/Sa-Token%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="四、微服务中使用-Sa-Token-依赖引入说明"><a href="#四、微服务中使用-Sa-Token-依赖引入说明" class="headerlink" title="四、微服务中使用 Sa-Token 依赖引入说明"></a>四、微服务中使用 Sa-Token 依赖引入说明</h2><blockquote><p>==注意：==<strong>在微服务架构中使用Sa-Token时，网关和内部服务要分开引入Sa-Token依赖（不要直接在顶级父pom中引入Sa-Token）</strong></p></blockquote><p>总体来讲，我们需要关注的依赖就是两个：<code>sa-token-spring-boot-starter</code> 和 <code>sa-token-reactor-spring-boot-starter</code>：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 权限认证，在线文档：https://sa-token.cc --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 权限认证（Reactor响应式集成），在线文档：https://sa-token.cc --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-reactor-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>对于内部基础服务来讲，我们一般都是使用SpringBoot默认的web模块：SpringMVC， 因为这个SpringMVC是基于Servlet模型的，在这里我们需要引入的是<code>sa-token-spring-boot-starter</code></p><p>对于网关服务，大体来讲分为两种：</p><ul><li>一种是基于Servlet模型的，如：Zuul，我们需要引入的是：<code>sa-token-spring-boot-starter</code>，详细戳：<a href="https://sa-token.cc/doc.html#/start/example">在SpringBoot环境集成</a></li><li>一种是基于Reactor模型的，如：SpringCloud Gateway、ShenYu 等等，我们需要引入的是：<code>sa-token-reactor-spring-boot-starter</code>，<strong>并且注册全局过滤器！</strong>，详细戳：<a href="https://sa-token.cc/doc.html#/start/webflux-example">在WebFlux环境集成</a></li></ul><blockquote><p>注：切不可直接在一个项目里同时引入这两个依赖，否则会造成项目无法启动</p></blockquote><p>另外，我们需要引入Redis集成包，因为我们的网关和子服务主要通过Redis来同步数据 </p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 整合 Redis （使用 jackson 序列化方式） --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-dao-redis-jackson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sa-Token </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gateway服务网关</title>
      <link href="/tur-study/2023/04/08/SpringCloud/Gateway%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/"/>
      <url>/tur-study/2023/04/08/SpringCloud/Gateway%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p><h3 id="1-为什么需要网关"><a href="#1-为什么需要网关" class="headerlink" title="1.  为什么需要网关"></a>1.  为什么需要网关</h3><p>Gateway网关是我们服务的守门神，所有微服务的统一入口。</p><p>网关的<strong>核心功能特性</strong>：</p><ul><li>请求路由</li><li>权限控制</li><li>限流</li></ul><p>架构图：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304082115722.png" alt="image-20210714210131152"></p><p><strong>权限控制</strong>：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p><p><strong>路由和负载均衡</strong>：一切请求都必须先经过gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p><p><strong>限流</strong>：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p><p>在SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h3 id="2-Gateway-快速入门"><a href="#2-Gateway-快速入门" class="headerlink" title="2. Gateway 快速入门"></a>2. Gateway 快速入门</h3><p>基本步骤如下：</p><ol><li>创建SpringBoot工程gateway，引入网关依赖</li><li>编写启动类</li><li>编写基础配置和路由规则</li><li>启动网关服务进行测试</li></ol><h5 id="1-网关依赖"><a href="#1-网关依赖" class="headerlink" title="1. 网关依赖"></a>1. 网关依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--网关--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-基础配置与路由规则"><a href="#3-基础配置与路由规则" class="headerlink" title="3. 基础配置与路由规则"></a>3. 基础配置与路由规则</h5><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">server:  port: 10010 # 网关端口spring:  application:    name: gateway # 服务名称  cloud:    gateway:      routes: # 网关路由配置        - id: user-service # 路由id，自定义，只要唯一即可          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址          uri: lb://userservice # 路由的目标地址 lb就是负载均衡，后面跟服务名称          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述实例中将符合<code>Path</code> 规则的一切请求，都代理到 <code>uri</code>参数指定的地址。</p><p>本例中，我们将 <code>/user/**</code>开头的请求，代理到<code>lb://userservice</code>，lb是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p><blockquote><p>注：lb 负载均衡需要引入 Nacos 才可以使用</p></blockquote><h5 id="5-网关路由的流程图"><a href="#5-网关路由的流程图" class="headerlink" title="5. 网关路由的流程图"></a>5. 网关路由的流程图</h5><p>整个访问的流程如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304082119230.png" alt="image-20210714211742956"></p><p>总结：</p><p>网关搭建步骤：</p><ol><li><p>创建项目，引入nacos服务发现和gateway依赖</p></li><li><p>配置application.yml，包括服务基本信息、nacos地址、路由</p></li></ol><p>路由配置包括：</p><ol><li><p>路由id：路由的唯一标示</p></li><li><p>路由目标（uri）：路由的目标地址，http代表固定地址，lb代表根据服务名负载均衡</p></li><li><p>路由断言（predicates）：判断路由的规则，</p></li><li><p>路由过滤器（filters）：对请求或响应做处理</p></li></ol><h3 id="3-断言工厂"><a href="#3-断言工厂" class="headerlink" title="3. 断言工厂"></a>3. 断言工厂</h3><p>我们在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件</p><p>例如Path=/user/**是按照路径匹配，这个规则是由</p><p><code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code>类来处理的，像这样的断言工厂在SpringCloudGateway还有十几个:</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header=X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>-  Host=<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method=GET,POST</td></tr><tr><td>Path</td><td>请求路径必须符合指定规则</td><td>- Path=/red/{segment},/blue/**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query=name, Jack或者-  Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr=192.168.1.1/24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table><blockquote><p>一般只需要掌握Path这种路由工程就可以了。</p></blockquote><h3 id="4-过滤器工厂"><a href="#4-过滤器工厂" class="headerlink" title="4. 过滤器工厂"></a>4. 过滤器工厂</h3><p>GatewayFilter是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304082120187.png" alt="image-20210714212312871"></p><h4 id="4-1-路由过滤器种类"><a href="#4-1-路由过滤器种类" class="headerlink" title="4.1 路由过滤器种类"></a>4.1 路由过滤器种类</h4><p>Spring提供了31种不同的路由过滤器工厂。例如：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>AddRequestHeader</td><td>给当前请求添加一个请求头</td></tr><tr><td>RemoveRequestHeader</td><td>移除请求中的一个请求头</td></tr><tr><td>AddResponseHeader</td><td>给响应结果中添加一个响应头</td></tr><tr><td>RemoveResponseHeader</td><td>从响应结果中移除有一个响应头</td></tr><tr><td>RequestRateLimiter</td><td>限制请求的流量</td></tr></tbody></table><h5 id="4-2-请求头过滤器"><a href="#4-2-请求头过滤器" class="headerlink" title="4.2 请求头过滤器"></a>4.2 请求头过滤器</h5><p>以AddRequestHeader 为例</p><blockquote><p><strong>需求</strong>：给所有进入userservice的请求添加一个请求头：Truth=itcast is freaking awesome!</p></blockquote><p>只需要修改gateway服务的application.yml文件，添加路由过滤即可：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    gateway:      routes:      - id: user-service         uri: lb://userservice         predicates:         - Path=/user/**         filters: # 过滤器        - AddRequestHeader=Truth, Itcast is freaking awesome! # 添加请求头<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当前过滤器写在userservice路由下，因此仅仅对访问userservice的请求有效。</p><h5 id="3-4-3-默认过滤器"><a href="#3-4-3-默认过滤器" class="headerlink" title="3.4.3.默认过滤器"></a>3.4.3.默认过滤器</h5><p>如果要对所有的路由都生效，则可以将过滤器工厂写到default下。格式如下：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    gateway:      routes:      - id: user-service         uri: lb://userservice         predicates:         - Path=/user/**      default-filters: # 默认过滤项      - AddRequestHeader=Truth, Itcast is freaking awesome! <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-全局过滤器"><a href="#5-全局过滤器" class="headerlink" title="5. 全局过滤器"></a>5. 全局过滤器</h3><h5 id="5-1-全局过滤器作用"><a href="#5-1-全局过滤器作用" class="headerlink" title="5.1 全局过滤器作用"></a>5.1 全局过滤器作用</h5><p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的；而GlobalFilter的逻辑需要自己写代码实现。</p><p>定义方式是实现GlobalFilter接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface GlobalFilter {    /**     *  处理当前请求，有必要的话通过{@link GatewayFilterChain}将请求交给下一个过滤器处理     *     * @param exchange 请求上下文，里面可以获取Request、Response等信息     * @param chain 用来把请求委托给下一个过滤器      * @return {@code Mono&lt;Void&gt;} 返回标示当前过滤器业务结束     */    Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在filter中编写自定义逻辑，可以实现下列功能：</p><ul><li>登录状态判断</li><li>权限校验</li><li>请求限流等</li></ul><h4 id="5-2-自定义全局过滤器"><a href="#5-2-自定义全局过滤器" class="headerlink" title="5.2 自定义全局过滤器"></a>5.2 自定义全局过滤器</h4><p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p><ul><li><p>参数中是否有authorization，</p></li><li><p>authorization参数值是否为admin</p></li></ul><p>如果同时满足则放行，否则拦截</p><p>实现：</p><p>在gateway中定义一个过滤器：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">package cn.itcast.gateway.filters;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.annotation.Order;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Mono;@Order(-1)@Componentpublic class AuthorizeFilter implements GlobalFilter {    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {        // 1.获取请求参数        MultiValueMap&lt;String, String&gt; params = exchange.getRequest().getQueryParams();        // 2.获取authorization参数        String auth = params.getFirst("authorization");        // 3.校验        if ("admin".equals(auth)) {            // 放行            return chain.filter(exchange);        }        // 4.拦截        // 4.1.禁止访问，设置状态码        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);        // 4.2.结束处理        return exchange.getResponse().setComplete();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-3-过滤器执行顺序"><a href="#5-3-过滤器执行顺序" class="headerlink" title="5.3 过滤器执行顺序"></a>5.3 过滤器执行顺序</h4><p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前路由过滤器和DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304082122421.png" alt="image-20210714214228409"></p><p>排序的规则是什么呢？</p><ul><li>每一个过滤器都必须指定一个int类型的order值，<strong>order值越小，优先级越高，执行顺序越靠前</strong>。</li><li>GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定</li><li>路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。</li><li>当过滤器的order值一样时，会按照 defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行。</li></ul><h3 id="6-跨域问题"><a href="#6-跨域问题" class="headerlink" title="6.跨域问题"></a>6.跨域问题</h3><h4 id="6-1-什么是跨域问题"><a href="#6-1-什么是跨域问题" class="headerlink" title="6.1.什么是跨域问题"></a>6.1.什么是跨域问题</h4><p>跨域：域名不一致就是跨域，主要包括：</p><ul><li><p>域名不同： <a href="http://www.taobao.com/">www.taobao.com</a> 和 <a href="http://www.taobao.org/">www.taobao.org</a> 和 <a href="http://www.jd.com/">www.jd.com</a> 和 miaosha.jd.com</p></li><li><p>域名相同，端口不同：localhost:8080和localhost8081</p></li></ul><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域ajax请求，请求被浏览器拦截的问题</p><p>解决方案：CORS</p><h4 id="6-2-解决跨域问题"><a href="#6-2-解决跨域问题" class="headerlink" title="6.2 解决跨域问题"></a>6.2 解决跨域问题</h4><p>在gateway服务的application.yml文件中，添加下面的配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    gateway:      # 。。。      globalcors: # 全局的跨域处理        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题        corsConfigurations:          '[/**]':            allowedOrigins: # 允许哪些网站的跨域请求               - "http://localhost:8090"            allowedMethods: # 允许的跨域ajax的请求方式              - "GET"              - "POST"              - "DELETE"              - "PUT"              - "OPTIONS"            allowedHeaders: "*" # 允许在请求中携带的头信息            allowCredentials: true # 是否允许携带cookie            maxAge: 360000 # 这次跨域检测的有效期<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>报错合集</title>
      <link href="/tur-study/2023/04/05/%E6%8A%A5%E9%94%99%E5%90%88%E9%9B%86/"/>
      <url>/tur-study/2023/04/05/%E6%8A%A5%E9%94%99%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p><span class="github-emoji"><span>🦊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f98a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>希望每天都没有bug</p></blockquote><h2 id="一、SpringBoot"><a href="#一、SpringBoot" class="headerlink" title="一、SpringBoot"></a>一、SpringBoot</h2><h3 id="1-No-serializer-found-for-class-java-util-Collections-3-and-no-properties-discovered-to-create-BeanSerializer"><a href="#1-No-serializer-found-for-class-java-util-Collections-3-and-no-properties-discovered-to-create-BeanSerializer" class="headerlink" title="1. No serializer found for class java.util.Collections$3 and no properties discovered to create BeanSerializer"></a>1. No serializer found for class java.util.Collections$3 and no properties discovered to create BeanSerializer</h3><h4 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h4><p>使用fasyjson，在全局拦截器的时候，出现：</p><pre><code>No serializer found for class java.util.Collections$3 and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: org.apache.catalina.connector.RequestFacade[1]-&gt;o</code></pre><p>显示序列化，但我实现了序列化，还是有错，由于请求参数为空，所以传入了一个空对象，而fastjson无法解析，就抛出了异常</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>在配置文件中添加如下配置，忽略对于参数是否为空的检测</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  jackson:    serialization:      FAIL_ON_EMPTY_BEANS: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：从报错信息上看，忽略参数是否为空检测是不推荐的，但暂未找到其他好的办法  <span class="github-emoji"><span>🙁</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f641.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p></blockquote><h3 id="2-循环依赖报错"><a href="#2-循环依赖报错" class="headerlink" title="2. 循环依赖报错"></a>2. 循环依赖报错</h3><h4 id="问题背景-1"><a href="#问题背景-1" class="headerlink" title="问题背景"></a>问题背景</h4><p>两个 Bean 中互相依赖对象，形成闭环，如 A 中引入了 B，B 中也引入了 A，这会导致 Spring 无法知道先加载哪一个，从而报错</p><pre class="line-numbers language-none"><code class="language-none">The dependencies of some of the beans in the application context form a cycle:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="1-修改配置文件"><a href="#1-修改配置文件" class="headerlink" title="1. 修改配置文件"></a>1. 修改配置文件</h5><p>根据Action 中的提示删除依赖之间的关系循环</p><blockquote><p>不鼓励依赖循环引用，默认情况下禁止循环引用。更新应用程序以删除 Bean 之间的依赖关系循环。作为最后的手段，可以通过将  spring.main.allow-circular-references 设置为 true  来自动打破循环。因此可以在yml配置文件中设置来打破循环依赖</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:    main:        allow-circular-references: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><h5 id="2-添加注解，延迟加载"><a href="#2-添加注解，延迟加载" class="headerlink" title="2. 添加注解，延迟加载"></a>2. 添加注解，延迟加载</h5><p>由于在循环依赖中，Spring在初始化的时候不知道先加载哪个bean，因此可以通过使用@Lazy注解，放在其中一个bean上，让这个bean延迟加载，另一个bean就会先加载，进而解决循环依赖问题</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304091543949.png" alt="image-20230409154347678"></p><h2 id="二、SpringCloud"><a href="#二、SpringCloud" class="headerlink" title="二、SpringCloud"></a>二、SpringCloud</h2><h3 id="1-No-spring-config-import-property-has-been-defined"><a href="#1-No-spring-config-import-property-has-been-defined" class="headerlink" title="1. No spring.config.import property has been defined"></a>1. No spring.config.import property has been defined</h3><h4 id="问题背景-2"><a href="#问题背景-2" class="headerlink" title="问题背景"></a>问题背景</h4><p>在我们配置spring cloud config的客户端映射时，启动项目之后出现No spring.config.import property has been defined的问题，如图：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052228437.png" alt="image-20230405222859110"></p><p>产生问题的原因是bootstrap.properties比application.properties的优先级要高<br>由于bootstrap.properties是系统级的资源配置文件，是用在程序引导执行时更加早期配置信息读取；<br>而application.properties是用户级的资源配置文件，是用来后续的一些配置所需要的公共参数。<br>但是在SpringCloud 2020.* 版本把bootstrap禁用了，导致在读取文件的时候读取不到而报错，所以我们只要把bootstrap从新导入进来就会生效了。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- bootstrap --&gt;</span>                                          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>                                                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-bootstrap<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>                                               <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：若是父工程中没有添加cloud依赖的，此处需要添加版本，有则不需要</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 错误 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos的配置与使用</title>
      <link href="/tur-study/2023/04/05/SpringCloud/Nacos%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/04/05/SpringCloud/Nacos%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、简介与启动"><a href="#一、简介与启动" class="headerlink" title="一、简介与启动"></a>一、简介与启动</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><p>Nacos 是 SpringCloudAlibaba 中的一个组件，相比 Eureka 功能更加丰富</p><ul><li>Nacos 官网：<a href="https://nacos.io/zh-cn/">https://nacos.io/zh-cn/</a></li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052242845.png" alt="image-20230405224257780"></p><ul><li>Github 主页：<a href="https://github.com/alibaba/nacos">https://github.com/alibaba/nacos</a></li></ul><blockquote><p>==注意：==下载 nacos 时，要注意<font color="red"> 版本匹配</font>。版本需要与 SpringCloud、SpringBoot 对应，可以查看 github 上 spring-cloud-alibaba 的版本说明。地址：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a></p></blockquote><h3 id="1-2-启动"><a href="#1-2-启动" class="headerlink" title="1.2 启动"></a>1.2 启动</h3><ol><li>进入下载好的 nacos-server 文件夹下 bin 文件下：<code>start.cmd</code>就是 window 下启动的脚本</li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052259834.png" alt="image-20230405225936791"></p><ol start="2"><li>进入 cmd 命令控制台，输入一下命令：<code>start.cmd -m standalone</code> 启动 nacos</li></ol><blockquote><p>==注意：==cmd 需要进入 nacos 的 bin 文件夹，在执行命令</p></blockquote><ol start="3"><li>启动：</li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052301082.png" alt="image-20230405230141041"></p><p>提示信息出现 successfully 表示启动成功，访问<code>localhost:8848</code>，打开 nacos 配置页面</p><blockquote><p>==注意：==由于是在命令控制台中启动 nacos ，所以不能关闭此窗口，否则无法 访问 nacos</p></blockquote><h2 id="二、注册中心"><a href="#二、注册中心" class="headerlink" title="二、注册中心"></a>二、注册中心</h2><h3 id="2-1-注册服务到-nacos"><a href="#2-1-注册服务到-nacos" class="headerlink" title="2.1 注册服务到 nacos"></a>2.1 注册服务到 nacos</h3><p>步骤如下：</p><h4 id="2-1-1-引入依赖"><a href="#2-1-1-引入依赖" class="headerlink" title="2.1.1  引入依赖"></a>2.1.1  引入依赖</h4><h5 id="1-父工程引入-SpringCloudAlibaba-的依赖"><a href="#1-父工程引入-SpringCloudAlibaba-的依赖" class="headerlink" title="1. 父工程引入 SpringCloudAlibaba 的依赖"></a>1. 父工程引入 SpringCloudAlibaba 的依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2021.0.5.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>==注意：==</p><ul><li><code>&lt;type&gt;pom&lt;/type&gt;</code> 与 <code>&lt;scope&gt;import&lt;scope&gt;</code> 必须添加，否则子工程无法引入依赖</li><li>版本需要与 SpringCloud、SpringBoot 对应，可以查看 github 上 spring-cloud-alibaba 的版本说明。地址：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a></li></ul></blockquote><h5 id="2-子工程引入-nacos-discovery-依赖"><a href="#2-子工程引入-nacos-discovery-依赖" class="headerlink" title="2. 子工程引入 nacos-discovery 依赖"></a>2. 子工程引入 nacos-discovery 依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-配置-nacos-地址"><a href="#2-1-2-配置-nacos-地址" class="headerlink" title="2.1.2 配置 nacos 地址"></a>2.1.2 配置 nacos 地址</h4><p>在所需要注册的服务工程的 <code>application.yml</code> 中添加 nacos 地址：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848 # 8848是默认端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>重启服务工程后可以在 nacos 管理页面看到微服务信息：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052257618.png" alt="image-20230405225720564"></p><h3 id="2-2-环境隔离"><a href="#2-2-环境隔离" class="headerlink" title="2.2 环境隔离"></a>2.2 环境隔离</h3><p>Nacos提供了namespace来实现环境隔离功能。</p><ul><li>nacos中可以有多个namespace</li><li>namespace下可以有group、service等</li><li>不同namespace之间相互隔离，例如不同namespace的服务互相不可见</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052304031.png" alt="image-20230405230442932"></p><blockquote><p>创建 namespace ，就不用记录了</p></blockquote><p>下面给微服务配置 namespace</p><p>给微服务配置namespace只能通过修改配置来实现。</p><p>修改 application.yml文件：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        namespace: 492a7d5d-237b-46a1-a99a-fa8e98e4b0f9 # 命名空间，填ID<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>命令空间 ID 是在创建 namespace 时，若没有指定则自动生成，可以指定为与 namespace 名一样。</p><p>如：namespace 为 dev</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  cloud:    nacos:      server-addr: localhost:8848      discovery:        namespace: dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、Nacos-配置管理"><a href="#三、Nacos-配置管理" class="headerlink" title="三、Nacos 配置管理"></a>三、Nacos 配置管理</h2><h3 id="3-1-统一配置管理"><a href="#3-1-统一配置管理" class="headerlink" title="3.1 统一配置管理"></a>3.1 统一配置管理</h3><p>Nacos一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052315538.png" alt="image-20230405231526486"></p><h4 id="3-1-1-在-nacos-中添加配置文件"><a href="#3-1-1-在-nacos-中添加配置文件" class="headerlink" title="3.1.1 在 nacos 中添加配置文件"></a>3.1.1 在 nacos 中添加配置文件</h4><p>点击加号：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052316484.png" alt="image-20230405231635432"></p><p>在弹出的表单中，填写配置信息：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052317615.png" alt="image-20230405231721564"></p><blockquote><p>==注意：==项目的核心配置，需要热更新的配置才有放到nacos管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p></blockquote><h4 id="3-1-2-从-nacos-拉取配置"><a href="#3-1-2-从-nacos-拉取配置" class="headerlink" title="3.1.2 从 nacos 拉取配置"></a>3.1.2 从 nacos 拉取配置</h4><p>微服务要拉取nacos中管理的配置，并且与本地的application.yml配置合并，才能完成项目启动。</p><p>但如果尚未读取application.yml，又如何得知nacos地址呢？</p><p>因此spring引入了一种新的配置文件：<code>bootstrap.yml</code>文件，会在<code>application.yml</code>之前被读取，流程如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052318308.png" alt="img"></p><h5 id="1-引入-nacos-config-依赖"><a href="#1-引入-nacos-config-依赖" class="headerlink" title="1. 引入 nacos-config 依赖"></a>1. 引入 nacos-config 依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--nacos配置管理依赖--&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-添加-bootstrap-yml"><a href="#2-添加-bootstrap-yml" class="headerlink" title="2. 添加 bootstrap.yml"></a>2. 添加 bootstrap.yml</h5><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  application:    name: userservice # 服务名称  profiles:    active: dev #开发环境，这里是dev   cloud:    nacos:      server-addr: localhost:8848 # Nacos地址      config:        file-extension: yml # 文件后缀名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里会根据spring.cloud.nacos.server-addr获取nacos地址，再根据</p><p><code>${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}</code>作为文件id，来读取配置。</p><p>本例中，就是去读取<code>userservice-dev.yaml</code>：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052320342.png" alt="image-20210714170845901"></p><h5 id="3-读取配置"><a href="#3-读取配置" class="headerlink" title="3. 读取配置"></a>3. 读取配置</h5><p>跟读取 application.yml 中值的读取一样，使用 <code>@Value</code> 注解</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052322094.png" alt="image-20210714170337448"></p><h3 id="3-2-配置热更新"><a href="#3-2-配置热更新" class="headerlink" title="3.2 配置热更新"></a>3.2 配置热更新</h3><h4 id="3-2-1-方式一"><a href="#3-2-1-方式一" class="headerlink" title="3.2.1 方式一"></a>3.2.1 方式一</h4><p>在<code>@Value</code>注入的变量所在类上添加注解<code>@RefreshScope：</code></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052322744.png" alt="image-20210714171036335"></p><h4 id="3-2-2-方式二"><a href="#3-2-2-方式二" class="headerlink" title="3.2.2 方式二"></a>3.2.2 方式二</h4><p>使用<code>@ConfigurationProperties</code>注解代替<code>@Value</code>注解。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import lombok.Data;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.stereotype.Component;@Component@Data@ConfigurationProperties(prefix = "pattern")public class PatternProperties {    private String dateformat;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在UserController中使用这个类代替@Value：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052323568.png" alt="image-20210714171316124"></p><h3 id="3-3-配置共享"><a href="#3-3-配置共享" class="headerlink" title="3.3 配置共享"></a>3.3 配置共享</h3><p>其实微服务启动时，会去nacos读取多个配置文件，例如：</p><ul><li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：userservice-dev.yaml</p></li><li><p><code>[spring.application.name].yaml</code>，例如：userservice.yaml</p></li></ul><p>而<code>[spring.application.name].yaml</code>不包含环境，因此可以被多个环境共享，故而可以用来配置一些公共配置</p><p><strong>配置共享的优先级：</strong></p><p>当nacos、服务本地同时出现相同属性时，优先级有高低之分：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304052324369.png" alt="image-20210714174623557"></p><h3 id="3-4-搭建-Nacos-集群"><a href="#3-4-搭建-Nacos-集群" class="headerlink" title="3.4 搭建 Nacos 集群"></a>3.4 搭建 Nacos 集群</h3><hr><h2 id="四、Nacos使用报错合集"><a href="#四、Nacos使用报错合集" class="headerlink" title="四、Nacos使用报错合集"></a>四、Nacos使用报错合集</h2><h3 id="1-Client-not-connected-current-status-STARTING-StatusRuntimeException"><a href="#1-Client-not-connected-current-status-STARTING-StatusRuntimeException" class="headerlink" title="1. Client not connected,current status:STARTING,StatusRuntimeException"></a>1. Client not connected,current status:STARTING,StatusRuntimeException</h3><p>Nacos报错：<code>Client not connected,current status:STARTING,StatusRuntimeException</code></p><p>解决办法：降低 nacos-client 版本</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.nacos<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>nacos-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.nacos<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>nacos-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.4.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tur-blog项目文档</title>
      <link href="/tur-study/2023/04/05/Project/tur-blog%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/"/>
      <url>/tur-study/2023/04/05/Project/tur-blog%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>个人博客项目文档</p></blockquote><h2 id="1-依赖版本说明"><a href="#1-依赖版本说明" class="headerlink" title="1. 依赖版本说明"></a>1. 依赖版本说明</h2><table><thead><tr><th>依赖</th><th>版本</th><th>官网</th></tr></thead><tbody><tr><td>SpringBoot</td><td>2.6.13.RELEASE</td><td></td></tr><tr><td>SpringCloud</td><td>2021.0.5</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注解@Transactional的用法详解</title>
      <link href="/tur-study/2023/04/04/SpringBoot/%E6%B3%A8%E8%A7%A3-Transactional%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/04/04/SpringBoot/%E6%B3%A8%E8%A7%A3-Transactional%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><code>@Transactional</code> 注解可以保证方法内多个数据库操作要么同时成功、要么同时失败。但使用 <code>@Transactional</code> 注解需要注意许多细节，不然注解就会失效</p></blockquote><h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><p>事务管理在系统开发中是不可缺少的一部分，Spring 提供了很好的事务管理机制，主要分为：编程式事务和声明式事务</p><h3 id="1-1-编程式事务"><a href="#1-1-编程式事务" class="headerlink" title="1.1 编程式事务"></a>1.1 编程式事务</h3><p>指在代码中手动管理事务的提交、回滚等操作，代码侵入性比较强</p><p>示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void test() {      TransactionDefinition def = new DefaultTransactionDefinition();      TransactionStatus status = transactionManager.getTransaction(def);       try {         // 事务操作         // 事务提交         transactionManager.commit(status);       } catch (DataAccessException e) {         // 事务回滚         transactionManager.rollback(status);         throw e;       }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上代码，开发者可以通过 API 自己控制事务</p><h3 id="1-2-声明式事务"><a href="#1-2-声明式事务" class="headerlink" title="1.2 声明式事务"></a>1.2 声明式事务</h3><p>声明式事务基于 <code>AOP 面向切面</code>的，将具体业务域事务处理部分解耦，代码侵入性很低，在实际开发中使用较多。</p><p>声明式事务有两种实现方式：</p><ul><li>基于 TX 和 AOP 的 <code>xml 配置文件</code>方式</li><li>基于 <code>@Transactional</code> 注解</li></ul><p>声明式事务对代码没有侵入性，方法内只需要写业务逻辑就可以了，帮助我们节省了很多代码，他会自动帮我们进行事务的开启、提交以及回滚等操作，把程序员从事务管理中解放出来。可以说优点很明显，但是这种方式的缺点也很明显</p><h5 id="1-问题一：声明式事务的粒度问题"><a href="#1-问题一：声明式事务的粒度问题" class="headerlink" title="1. 问题一：声明式事务的粒度问题"></a>1. 问题一：声明式事务的粒度问题</h5><p>声明式事务有一个局限，就是它的最小粒度要作用在方法上。</p><p>也就是说，如果想要给一部分代码增加事务的话，就需要把这部分代码块单独出来作为一个方法。</p><blockquote><p>在大事务耗时过长需要高并发优化的情况下不建议使用声明式事务，建议采用上面提到的编程式事务</p></blockquote><h5 id="2-问题二：声明式事务容易被开发者忽略"><a href="#2-问题二：声明式事务容易被开发者忽略" class="headerlink" title="2. 问题二：声明式事务容易被开发者忽略"></a>2. 问题二：声明式事务容易被开发者忽略</h5><p>而事务一旦被忽略就容易造成很多故障</p><p>首先，如果开发者没有注意到一个方法是被事务嵌套的，那么就可能会再方法中加入一些如RPC远程调用、消息发送、缓存更新、文件写入等操作。</p><p>我们知道，这些操作如果被包在事务中，有两个问题：</p><p>1、这些操作自身是无法回滚的，这就会导致数据的不一致。可能RPC调用成功了，但是本地事务回滚了，可是PRC调用无法回滚了(这里不讨论分布式事务)。</p><p>2、在事务中有远程调用，就会拉长整个事务。那么久会导致本事务的数据库连接一直被占用，那么如果类似操作过多，就会导致数据库连接池耗尽。</p><p>有些时候，即使没有在事务中进行远程操作，但是有些人还是可能会不经意的进行一些内存操作，如运算。或者如果遇到分库分表的情况，有可能不经意间进行跨库操作。</p><h5 id="3-问题三：声明式事务用错，在某些场景下容易失效"><a href="#3-问题三：声明式事务用错，在某些场景下容易失效" class="headerlink" title="3. 问题三：声明式事务用错，在某些场景下容易失效"></a>3. 问题三：声明式事务用错，在某些场景下容易失效</h5><p>后面有详细介绍</p><h2 id="二、-Transactional-介绍"><a href="#二、-Transactional-介绍" class="headerlink" title="二、@Transactional 介绍"></a>二、@Transactional 介绍</h2><h3 id="2-1-Transactional-可以作用在接口、类、类方法上"><a href="#2-1-Transactional-可以作用在接口、类、类方法上" class="headerlink" title="2.1 @Transactional 可以作用在接口、类、类方法上"></a>2.1 @Transactional 可以作用在接口、类、类方法上</h3><ol><li>作用于类：表示该类的所有 public 方法都配置相同的事属性信息</li><li>作用于方法：当类、方法都配置了 @Transactional 时，方法的事务回覆盖类的事务配置信息</li><li>作用于接口：不推荐这种使用方法。因为一旦标注在接口上并且配置了 SpringAOP 使用 CGLib 动态代理，将会导致 @Transactional 失效</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional                                                              @RestController                                                             @RequestMapping                                                             public class MybatisPlusController {                                            @Autowired                                                                  private CityInfoDictMapper cityInfoDictMapper;                                                                                                          @Transactional(rollbackFor = Exception.class)                       @GetMapping("/test")                                                        public String test() throws Exception {                                          CityInfoDict cityInfoDict = new CityInfoDict();                      cityInfoDict.setParentCityId(2);                                     cityInfoDict.setCityName("2");                                       cityInfoDict.setCityLevel("2");                                      cityInfoDict.setCityCode("2");                                       int insert = cityInfoDictMapper.insert(cityInfoDict);                return insert + "";                                              }                                                               }                                                                           <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-Transactional-注解的属性"><a href="#2-2-Transactional-注解的属性" class="headerlink" title="2.2 @Transactional 注解的属性"></a>2.2 @Transactional 注解的属性</h3><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>value</td><td>String</td><td>可选的限定描述符，指定使用的事务管理器</td></tr><tr><td>propagation</td><td>enum: Propagation</td><td>可选的事务传播行为设置</td></tr><tr><td>isolation</td><td>enum: Isolation</td><td>可选的事务隔离级别设置</td></tr><tr><td>readOnly</td><td>boolean</td><td>读写或只读事务，默认读写</td></tr><tr><td>timeout</td><td>int (in seconds granularity)</td><td>事务超时时间设置</td></tr><tr><td>rollbackFor</td><td>Class对象数组，必须继承自Throwable</td><td>导致事务回滚的异常类数组</td></tr><tr><td>rollbackForClassName</td><td>类名数组，必须继承自Throwable</td><td>导致事务回滚的异常类名字数组</td></tr><tr><td>noRollbackFor</td><td>Class对象数组，必须继承自Throwable</td><td>不会导致事务回滚的异常类数组</td></tr><tr><td>noRollbackForClassName</td><td>类名数组，必须继承自Throwable</td><td>不会导致事务回滚的异常类名字数组</td></tr></tbody></table><h5 id="1-propagation-属性"><a href="#1-propagation-属性" class="headerlink" title="1. propagation 属性"></a>1. propagation 属性</h5><p><code>propagation </code>属性代表事务的传播行为，默认值为：<code>Propagation.REQUIRED</code>。其他属性信息如下：</p><table><thead><tr><th>Propagation.REQUIRED</th><th>如果当前存在事务，则加入该事务，如果当前不存在事务，则创建一个新的事务。( 也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务 ）</th></tr></thead><tbody><tr><td>Propagation.SUPPORTS</td><td>如果当前存在事务，则加入该事务；如果当前不存在事务，则以非事务的方式继续运行。</td></tr><tr><td>Propagation.MANDATORY</td><td>如果当前存在事务，则加入该事务；如果当前不存在事务，则抛出异常。</td></tr><tr><td>Propagation.REQUIRES_NEW</td><td>重新创建一个新的事务，如果当前存在事务，暂停当前的事务。( 当类A中的 a 方法用默认Propagation.REQUIRED模式，类B中的 b方法加上采用  Propagation.REQUIRES_NEW模式，然后在 a 方法中调用 b方法操作数据库，然而  a方法抛出异常后，b方法并没有进行回滚，因为Propagation.REQUIRES_NEW会暂停 a方法的事务 )</td></tr><tr><td>Propagation.NOT_SUPPORTED</td><td>以非事务的方式运行，如果当前存在事务，暂停当前的事务。</td></tr><tr><td>Propagation.NEVER</td><td>以非事务的方式运行，如果当前存在事务，则抛出异常。</td></tr><tr><td>Propagation.NESTED</td><td>和 Propagation.REQUIRED 效果一样。</td></tr></tbody></table><h5 id="2-isolation-属性"><a href="#2-isolation-属性" class="headerlink" title="2. isolation 属性"></a>2. isolation 属性</h5><p><code>isolation </code>属性：事务的隔离级别，默认值为<code> Isolation.DEFAULT</code></p><ul><li><code>Isolation.DEFAULT</code>：使用底层数据库默认的隔离级别。</li><li><code>Isolation.READ_UNCOMMITTED</code></li><li><code>Isolation.READ_COMMITTED</code></li><li><code>Isolation.REPEATABLE_READ</code></li><li><code>Isolation.SERIALIZABLE</code></li></ul><h5 id="3-timeout-属性"><a href="#3-timeout-属性" class="headerlink" title="3. timeout 属性"></a>3. timeout 属性</h5><p><code>timeout </code>：事务的超时时间，默认值为 -1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</p><blockquote><p>事务超时，就会报错 TransactionTimedOutException:</p></blockquote><h5 id="4-readOnly-属性"><a href="#4-readOnly-属性" class="headerlink" title="4. readOnly 属性"></a>4. readOnly 属性</h5><p><code>readOnly </code>：指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</p><h5 id="5-rollbackFor-属性"><a href="#5-rollbackFor-属性" class="headerlink" title="5. rollbackFor 属性"></a>5. rollbackFor 属性</h5><p><code>rollbackFor </code>：用于指定能够触发事务回滚的异常类型，可以指定多个异常类型。</p><h5 id="6-noRollbackFor属性"><a href="#6-noRollbackFor属性" class="headerlink" title="6. noRollbackFor属性"></a>6. noRollbackFor属性</h5><p><code>noRollbackFor</code>：抛出指定的异常类型，不回滚事务，也可以指定多个异常类型</p><h2 id="三、-Transactional-失效场景"><a href="#三、-Transactional-失效场景" class="headerlink" title="三、@Transactional 失效场景"></a>三、@Transactional 失效场景</h2><h3 id="3-1-Transactional-应用在非-public修饰的方法上"><a href="#3-1-Transactional-应用在非-public修饰的方法上" class="headerlink" title="3.1 @Transactional 应用在非 public修饰的方法上"></a>3.1 @Transactional 应用在非 public修饰的方法上</h3><p>如果Transactional注解应用在非public 修饰的方法上，Transactional将会失效</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304040830528.png" alt="image-20230404083047229"></p><p>之所以会失效是因为在Spring AOP 代理时，如上图所示 TransactionInterceptor  （事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy 的内部类）的  intercept 方法或 JdkDynamicAopProxy 的 invoke 方法会间接调用  AbstractFallbackTransactionAttributeSource的 computeTransactionAttribute  方法，获取Transactional 注解的事务配置信息</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected TransactionAttribute computeTransactionAttribute(Method method,    Class&lt;?&gt; targetClass) {        // Don't allow no-public methods as required.        if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {    return null;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。</p><blockquote><p>==注意：==protected、private 修饰的方法上使用 @Transactional 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。</p></blockquote><h3 id="3-2-transactional-注解属性-propagation-设置错误"><a href="#3-2-transactional-注解属性-propagation-设置错误" class="headerlink" title="3.2 @transactional 注解属性 propagation 设置错误"></a>3.2 @transactional 注解属性 propagation 设置错误</h3><p>这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。</p><ol><li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。</li></ol><h3 id="3-3-Transactional-注解属性-rollbackFor-设置错误"><a href="#3-3-Transactional-注解属性-rollbackFor-设置错误" class="headerlink" title="3.3 @Transactional 注解属性 rollbackFor 设置错误"></a>3.3 @Transactional 注解属性 rollbackFor 设置错误</h3><p>rollbackFor 可以指定能够触发事务回滚的异常类型。Spring默认抛出了未检查unchecked异常（继承自  RuntimeException的异常）或者 Error才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望  Spring 能够回滚事务，就需要指定 rollbackFor属性。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304040833490.png" alt="image-20230404083312436"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 希望自定义的异常可以进行回滚 @Transactional(propagation= Propagation.REQUIRED,rollbackFor= MyException.class<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> 若在目标方法中抛出的异常是 rollbackFor 指定的异常的子类，事务同样会回滚。Spring源码如下：</p><pre class="line-numbers language-none"><code class="language-none">private int getDepth(Class&lt;?&gt; exceptionClass, int depth) {       if (exceptionClass.getName().contains(this.exceptionName)) {           // Found it!            return depth;       }       // If we've gone as far as we can go and haven't found it...       if (exceptionClass == Throwable.class) {            return -1;       }       return getDepth(exceptionClass.getSuperclass(), depth + 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-同一个类中方法调用，导致-Transactional失效"><a href="#3-4-同一个类中方法调用，导致-Transactional失效" class="headerlink" title="3.4 同一个类中方法调用，导致@Transactional失效"></a>3.4 同一个类中方法调用，导致@Transactional失效</h3><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但方法A没有声明注解事务，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。</p><p>那为啥会出现这种情况？其实这还是由于使用Spring AOP代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//@Transactional                                                 @GetMapping("/test")                                         private Integer A() throws Exception {                           CityInfoDict cityInfoDict = new CityInfoDict();              cityInfoDict.setCityName("2");                               /**                                                           * B 插入字段为 3的数据                                               */                                                          this.insertB();                                              /**                                                           * A 插入字段为 2的数据                                               */                                                          int insert = cityInfoDictMapper.insert(cityInfoDict);                                                                     return insert;                                           }                                                                                                                         @Transactional()                                             public Integer insertB() throws Exception {                      CityInfoDict cityInfoDict = new CityInfoDict();              cityInfoDict.setCityName("3");                               cityInfoDict.setParentCityId(3);                                                                                          return cityInfoDictMapper.insert(cityInfoDict);          }                                                        <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-异常被你的-catch“吃了”导致-Transactional失效"><a href="#3-5-异常被你的-catch“吃了”导致-Transactional失效" class="headerlink" title="3.5 异常被你的 catch“吃了”导致@Transactional失效"></a>3.5 异常被你的 catch“吃了”导致@Transactional失效</h3><p>这种情况是最常见的一种@Transactional注解失效场景</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Transactional                                             private Integer A() throws Exception {                         int insert = 0;                                            try {                                                          CityInfoDict cityInfoDict = new CityInfoDict();            cityInfoDict.setCityName("2");                             cityInfoDict.setParentCityId(2);                           /**                                                         * A 插入字段为 2的数据                                             */                                                        insert = cityInfoDictMapper.insert(cityInfoDict);          /**                                                         * B 插入字段为 3的数据                                             */                                                        b.insertB();                                           } catch (Exception e) {                                        e.printStackTrace();                                   }                                                      }                                                          <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务还能正常回滚吗？</p><p>答案：不能！</p><p>会抛出异常：</p><p>1org.springframework.transaction.UnexpectedRollbackException:  Transaction rolled back because it has been marked as rollback-only<br>  　因为当ServiceB中抛出了一个异常以后，ServiceB标识当前事务需要rollback。但是ServiceA中由于你手动的捕获这个异常并进行处理，ServiceA认为当前事务应该正常commit。此时就出现了前后不一致，也就是因为这样，抛出了前面的UnexpectedRollbackException异常。</p><p>spring的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行commit or rollback，事务是否执行取决于是否抛出runtime异常。如果抛出runtime exception 并在你的业务方法中没有catch到的话，事务会回滚。</p><p>在业务方法中一般不需要catch异常，如果非要catch一定要手动抛出throw new RuntimeException()，否则会导致事务失效，数据commit造成数据不一致，所以有些时候try catch反倒会画蛇添足。</p><h3 id="3-6-数据库引擎不支持事务"><a href="#3-6-数据库引擎不支持事务" class="headerlink" title="3.6 数据库引擎不支持事务"></a>3.6 数据库引擎不支持事务</h3><p> 这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的MySQL数据库默认使用支持事务的innodb引擎。一旦数据库引擎切换成不支持事务的myisam，那事务就从根本上失效了。</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO系列 BufferedReader</title>
      <link href="/tur-study/2023/04/03/Java/IO%E7%B3%BB%E5%88%97-BufferedReader/"/>
      <url>/tur-study/2023/04/03/Java/IO%E7%B3%BB%E5%88%97-BufferedReader/</url>
      
        <content type="html"><![CDATA[<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1. 基本介绍"></a>1. 基本介绍</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304030916034.png" alt="image-20230403091636971"></p><p><code>BufferedReader</code>：缓冲输入流，继承与 <code>Reader</code></p><ul><li>从字符输入流读取文本，缓冲字符，已提供字符、数组和行的高效读取</li><li>可以指定缓冲区大小，或者使用默认大小。默认值足够大，可用于大部分用途</li></ul><p>通常创建 <code>BufferedReader </code>的基本语法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">BufferedReader br = new BufferedReader(new InputStreamReader(System.in))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>语法解析：</p><ol><li>System.in：字节输入流</li><li>new InputStreamReader：将字节流转换为字符流</li><li>new BufferedReader：将字符流放入字符流缓冲区之中</li></ol><h3 id="2-BufferedReader-方法列表"><a href="#2-BufferedReader-方法列表" class="headerlink" title="2. BufferedReader 方法列表"></a>2. BufferedReader 方法列表</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">BufferedReader(Reader in)BufferedReader(Reader in, int size)void     close()void     mark(int markLimit)boolean  markSupported()int      read()int      read(char[] buffer, int offset, int length)String   readLine()boolean  ready()void     reset()long     skip(long charCount)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主要使用的方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">BufferedReader br = new BufferedReader(new InputStreamReader(System.in));String str= br.readLine() ;char c = br.read() ;// BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>==注意：==</p><ol><li>StringBuffer类的readLine()从每次读取的一行内容，直至读取的为null为止。然后进行输出。</li><li>StringBuffer类的read()方法读取到的每一个字符转换的数字，然后进行输出。</li></ol><h3 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h3><h4 id="3-1-从控制台读取多字符输入"><a href="#3-1-从控制台读取多字符输入" class="headerlink" title="3.1  从控制台读取多字符输入"></a>3.1  从控制台读取多字符输入</h4><p>从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下：</p><pre><code>int read( ) throws IOException</code></pre><p>每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。</p><p>示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">//使用 BufferedReader 在控制台读取字符import java.io.*; public class BRRead {    public static void main(String[] args) throws IOException {        char c;        // 使用 System.in 创建 BufferedReader        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        System.out.println("输入字符, 按下 'q' 键退出。");        // 读取字符        do {            c = (char) br.read();            System.out.println(c);        } while (c != 'q');    }}以上实例编译运行结果如下:输入字符, 按下 'q' 键退出。runoobrunoobqq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-从控制台读取字符串"><a href="#3-2-从控制台读取字符串" class="headerlink" title="3.2 从控制台读取字符串"></a>3.2 从控制台读取字符串</h4><p>从标准输入读取一个字符串需要使用 <strong>BufferedReader 的 readLine() 方法</strong>。</p><p>它的一般格式是：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String readLine( ) throws IOException<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">BRReadLines.java 文件代码：//使用 BufferedReader 在控制台读取字符import java.io.*; public class BRReadLines {    public static void main(String[] args) throws IOException {        // 使用 System.in 创建 BufferedReader        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        String str;        System.out.println("Enter lines of text.");        System.out.println("Enter 'end' to quit.");        do {            str = br.readLine();            System.out.println(str);        } while (!str.equals("end"));    }}以上实例编译运行结果如下:Enter lines of text.Enter 'end' to quit.This is line oneThis is line oneThis is line twoThis is line twoendend<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String,StringBuffer,StringBuilder类的区别</title>
      <link href="/tur-study/2023/04/03/Java/String-StringBuffer-StringBuilder%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/tur-study/2023/04/03/Java/String-StringBuffer-StringBuilder%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="1-简述"><a href="#1-简述" class="headerlink" title="1. 简述"></a>1. 简述</h3><h4 id="1-1-String-类"><a href="#1-1-String-类" class="headerlink" title="1.1 String 类"></a>1.1 String 类</h4><p>Java 中 字符串属于对象，Java 提供了 String 类来创建和操作字符串。String 类是不可变类，即一旦一个 String 对象被创建以后，包含在这个对象中的字符序列是不可变的，直到这个对象被销毁</p><h4 id="1-2-StringBuilder-和-StringBuffer-类"><a href="#1-2-StringBuilder-和-StringBuffer-类" class="headerlink" title="1.2 StringBuilder 和 StringBuffer 类"></a>1.2 StringBuilder 和 StringBuffer 类</h4><p>StringBuffer、StringBuilder 是 Java 的两个可变字符串类，中文意译为“字符串缓冲区”。</p><p>StringBuffer 和 StringBuilder 功能基本相似，方法也差不多。</p><p>不同之处：StringBuffer 是<code>线程安全</code>的，而 StringBuilder <code>没有实现线程安全</code>，所以 StringBuilder 的性能略高。因此在通常情况下，需要创建一个内容可变的字符串对象时，<font color="red">优先考虑使用 StringBuilder 类</font></p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><p>StringBuffer、StringBuilder、String 都实现了 <code>CharSequence </code>接口</p><blockquote><p>CharSequence 是一个定义字符串操作的接口，只包括 length()、charAt(int index)、subSequence(int start, int end) 这几个API</p></blockquote><p>三者对 CharSequence 接口的实现过程不一样：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304030911053.png" alt="image-20230403091157842"></p><p>可见，String 直接实现了 CharSequence 接口，StringBuilder 和 StringBuffer 都是可变的字符序列，它们都继承于 AbstractStringBuilder，实现了 CharSequence 接口。</p><h3 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h3><p>String 是 Java 中基础且重要的类，被声明为<code> final class</code>，是不可变字符串。因为它的不可变性，所以拼接字符串时候会产生很多无用的中间对象，如果频繁的进行这样的操作对性能有所影响。</p><p> StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类。它提供了 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置，它的本质是一个线程安全的可修改的字符序列。</p><p> 在很多情况下我们的字符串拼接操作不需要线程安全，所以 StringBuilder 登场了。StringBuilder 是 JDK1.5 发布的，它和 StringBuffer 本质上没什么区别，就是去掉了保证线程安全的那部分，减少了开销。</p><p><strong>线程安全：</strong></p><ul><li>StringBuffer：线程安全</li><li>StringBuilder：线程不安全</li></ul><p><strong>速度：</strong></p><p>一般情况下，速度从快到慢为 <code>StringBuilder &gt; StringBuffer &gt; String</code>，当然这是相对的，不是绝对的。</p><p><strong>使用环境：</strong></p><ul><li>操作少量的数据使用 String。</li><li>单线程操作大量数据使用 StringBuilder。</li><li>多线程操作大量数据使用 StringBuffer。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的加密工具类--DigestUtils</title>
      <link href="/tur-study/2023/04/02/Spring/Spring%E7%9A%84%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7%E7%B1%BB-DigestUtils/"/>
      <url>/tur-study/2023/04/02/Spring/Spring%E7%9A%84%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7%E7%B1%BB-DigestUtils/</url>
      
        <content type="html"><![CDATA[<h2 id="一、加密算法简介"><a href="#一、加密算法简介" class="headerlink" title="一、加密算法简介"></a>一、加密算法简介</h2><p>常见的加密算法可以分成三类：</p><ul><li>对称加密算法</li><li>非对称加密算法</li><li>Hash算法</li></ul><h3 id="1-1-对称加密"><a href="#1-1-对称加密" class="headerlink" title="1.1 对称加密"></a>1.1 对称加密</h3><p>指加密和解密使用相同密钥的加密算法。对称加密算法的优点在于加解密的高速度和使用长密钥时的难破解性。</p><p>假设两个用户需要使用对称加密方法加密然后交换数据，则用户最少需要2个密钥并交换使用，如果企业内用户有n个，则整个企业共需要n×(n-1) 个密钥，密钥的生成和分发将成为企业信息部门的恶梦。对称加密算法的安全性取决于加密密钥的保存情况，但要求企业中每一个持有密钥的人都保守秘密是不可能的，他们通常会有意无意的把密钥泄漏出去——如果一个用户使用的密钥被入侵者所获得，入侵者便可以读取该用户密钥加密的所有文档，如果整个企业共用一个加密密钥，那整个企业文档的保密性便无从谈起</p><p>常见的对称加密算法：DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES</p><h3 id="1-2-非对称加密"><a href="#1-2-非对称加密" class="headerlink" title="1.2 非对称加密"></a>1.2 非对称加密</h3><p>指加密和解密使用不同密钥的加密算法，也称为公私钥加密。假设两个用户要加密交换数据，双方交换公钥，使用时一方用对方的公钥加密，另一方即可用自己的私钥解密。</p><p>如果企业中有n个用户，企业需要生成n对密钥，并分发n个公钥。由于公钥是可以公开的，用户只要保管好自己的私钥即可，因此加密密钥的分发将变得十分简单。同时，由于每个用户的私钥是唯一的，其他用户除了可以可以通过信息发送者的公钥来验证信息的来源是否真实，还可以确保发送者无法否认曾发送过该信息。非对称加密的缺点是加解密速度要远远慢于对称加密，在某些极端情况下，甚至能比非对称加密慢上1000倍。</p><p>常见的非对称加密算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）</p><h3 id="1-3-Hash算法"><a href="#1-3-Hash算法" class="headerlink" title="1.3 Hash算法"></a>1.3 Hash算法</h3><p>Hash算法特别的地方在于它是一种单向算法，用户可以通过Hash算法对目标信息生成一段特定长度的唯一的Hash值，却不能通过这个Hash值重新获得目标信息。因此Hash算法常用在不可还原的密码存储、信息完整性校验等。</p><p>常见的Hash算法：MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1</p><blockquote><p>加密算法的效能通常可以按照算法本身的复杂程度、密钥长度（密钥越长越安全）、加解密速度等来衡量。上述的算法中，除了DES密钥长度不够、MD2速度较慢已逐渐被淘汰外，其他算法仍在目前的加密系统产品中使用。</p></blockquote><h3 id="1-4-加密算法的选择"><a href="#1-4-加密算法的选择" class="headerlink" title="1.4 加密算法的选择"></a>1.4 加密算法的选择</h3><p>我们应该根据自己的使用特点来确定，由于非对称加密算法的运行速度比对称加密算法的速度慢很多，当我们需要加密大量的数据时，建议采用对称加密算法，提高加解密速度。</p><p>对称加密算法不能实现签名，因此签名只能非对称算法。</p><p>由于对称加密算法的密钥管理是一个复杂的过程，密钥的管理直接决定着他的安全性，因此当数据量很小时，我们可以考虑采用非对称加密算法。</p><p>在实际的操作过程中，我们通常采用的方式是：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。</p><p>如果在选定了加密算法后，那采用多少位的密钥呢？一般来说，密钥越长，运行的速度就越慢，应该根据的我们实际需要的安全级别来选择，一般来说，RSA建议采用1024位的数字，ECC建议采用160位，AES采用128为即可。</p><h2 id="二、DigestUtils-的使用"><a href="#二、DigestUtils-的使用" class="headerlink" title="二、DigestUtils 的使用"></a>二、DigestUtils 的使用</h2><h3 id="2-1-SHA256加密"><a href="#2-1-SHA256加密" class="headerlink" title="2.1 SHA256加密"></a>2.1 SHA256加密</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">String encodekey = DigestUtils.sha256Hex("测试SHA256");System.out.println(encodekey);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">6c6c0785899852543f360d1270d400f709179fc03b62bada26aa0f69a8ec7dea<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**    * Calculates the SHA-256 digest and returns the value as a hex string.    * &lt;p&gt;    * Throws a &lt;code&gt;RuntimeException&lt;/code&gt; on JRE versions prior to 1.4.0.    * &lt;/p&gt;    *     * @param data    *            Data to digest    * @return SHA-256 digest as a hex string    * @since 1.4    */   public static String sha256Hex(String data) {       return Hex.encodeHexString(sha256(data));   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-md5加密"><a href="#2-2-md5加密" class="headerlink" title="2.2 md5加密"></a>2.2 md5加密</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">String encodekey = DigestUtils.md5Hex("测试MD5");System.out.println(encodekey);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>运行结果：</p><pre class="line-numbers language-none"><code class="language-none">c2dbb895a66c3ca924ccdbea49fa6884<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**     * Calculates the MD5 digest and returns the value as a 16 element &lt;code&gt;byte[]&lt;/code&gt;.     *      * @param data     *            Data to digest     * @return MD5 digest     */    public static byte[] md5(String data) {        return md5(getBytesUtf8(data));    } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该类同时提供了上述两个方法的重载方法传入的不同参数,支持的加密算法如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">   private static MessageDigest getMd5Digest() {return getDigest("MD5");}private static MessageDigest getSha256Digest() {return getDigest("SHA-256");}private static MessageDigest getSha384Digest() {return getDigest("SHA-384");}private static MessageDigest getSha512Digest() {return getDigest("SHA-512");}private static MessageDigest getShaDigest() {return getDigest("SHA");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器解析工具-UserAgentUtils</title>
      <link href="/tur-study/2023/04/02/SpringBoot/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7-UserAgentUtils/"/>
      <url>/tur-study/2023/04/02/SpringBoot/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7-UserAgentUtils/</url>
      
        <content type="html"><![CDATA[<h3 id="1-UserAgentUtils简介"><a href="#1-UserAgentUtils简介" class="headerlink" title="1. UserAgentUtils简介"></a>1. UserAgentUtils简介</h3><p>UserAgentUtils 是一个用来解析 User-Agent 字符串的 Java 类库</p><p>能够识别的内容包括：</p><ul><li>超过150种不同的浏览器；</li><li>7种不同的浏览器类型；</li><li>超过60种不同的操作系统；</li><li>6种不同的设备类型；</li><li>9种不同的渲染引擎；</li><li>9种不同的Web应用，如HttpClient、Bot。</li></ul><blockquote><p>Github主页：<a href="https://github.com/HaraldWalker/user-agent-utils">https://github.com/HaraldWalker/user-agent-utils</a></p></blockquote><h3 id="2-Maven-依赖"><a href="#2-Maven-依赖" class="headerlink" title="2. Maven 依赖"></a>2. Maven 依赖</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>eu.bitwalker<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>UserAgentUtils<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.21<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">String agent=request.getHeader("User-Agent");//"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/43.0.2357.81 Safari/537.36"//解析agent字符串UserAgent userAgent = UserAgent.parseUserAgentString(agent);//获取浏览器对象Browser browser = userAgent.getBrowser();//获取操作系统对象OperatingSystem operatingSystem = userAgent.getOperatingSystem();System.out.println("浏览器名:"+browser.getName());System.out.println("浏览器类型:"+browser.getBrowserType());System.out.println("浏览器家族:"+browser.getGroup());System.out.println("浏览器生产厂商:"+browser.getManufacturer());System.out.println("浏览器使用的渲染引擎:"+browser.getRenderingEngine());System.out.println("浏览器版本:"+userAgent.getBrowserVersion());        System.out.println("操作系统名:"+operatingSystem.getName());System.out.println("访问设备类型:"+operatingSystem.getDeviceType());System.out.println("操作系统家族:"+operatingSystem.getGroup());System.out.println("操作系统生产厂商:"+operatingSystem.getManufacturer());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出内容：</p><pre class="line-numbers language-none"><code class="language-none">浏览器名:Chrome 43浏览器类型:WEB_BROWSER浏览器家族:CHROME浏览器生产厂商:GOOGLE浏览器使用的渲染引擎:WEBKIT浏览器版本:43.0.2357.81操作系统名:Mac OS X访问设备类型:COMPUTER操作系统家族:MAC_OS_X操作系统生产厂商:APPLE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现获取客户端IP地址</title>
      <link href="/tur-study/2023/04/02/Java/Java%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AFIP%E5%9C%B0%E5%9D%80/"/>
      <url>/tur-study/2023/04/02/Java/Java%E5%AE%9E%E7%8E%B0%E8%8E%B7%E5%8F%96%E5%AE%A2%E6%88%B7%E7%AB%AFIP%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p> 项目开发中，在日常处理操作日志时，基本都会通过aop<a href="https://so.csdn.net/so/search?q=%E5%88%87%E9%9D%A2&amp;spm=1001.2101.3001.7020">切面</a>来实现用户操作日志的记录，但涉及到记录操作日志，想必肯定会有一项是基本都会参考记录的，那就是操作人的客户端ip地址，日后查”脏”也方便。</p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><ol><li>定义一个工具类，专门用来封装 ip 相关的方法类</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class IpUtils { }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>获取ip</li></ol><p>通常获取客户端的IP地址都是通过 <code>request.getRemoteAddr()</code> ，但如今基本系统都会进行域名代理等，比如通过 Apache,Squid 等反向代理软件，使用<code>getRemoteAddr() </code>根本无法再获取到客户端的真实 IP 地址了。</p><p>​    为什么加了代理就获取不到了呢？这是因为在客户端和服务之间增加了中间代理，因此服务器是无法直接拿到客户端的 IP地址，服务器端应用也无法直接通过转发请求的地址返回给客户端，基本这种获取方式就直接被pass掉了。</p><p>下面是具体获取客户端ip的方法类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/*** * 获取客户端ip地址 * @param request */public static String getIP(final HttpServletRequest request) throws Exception {    if (request == null) {        throw (new Exception("getIpAddr method HttpServletRequest Object is null"));    }    String ipStr = request.getHeader("x-forwarded-for");    if (StringUtils.isBlank(ipStr) || "unknown".equalsIgnoreCase(ipStr)) {        ipStr = request.getHeader("Proxy-Client-IP");    }    if (StringUtils.isBlank(ipStr) || "unknown".equalsIgnoreCase(ipStr)) {        ipStr = request.getHeader("WL-Proxy-Client-IP");    }    if (StringUtils.isBlank(ipStr) || "unknown".equalsIgnoreCase(ipStr)) {        ipStr = request.getRemoteAddr();    }     // 多个路由时，取第一个非unknown的ip    final String[] arr = ipStr.split(",");    for (final String str : arr) {        if (!"unknown".equalsIgnoreCase(str)) {            ipStr = str;            break;        }    }    //目的是将localhost访问对应的ip 0:0:0:0:0:0:0:1 转成 127.0.0.1。    return ipStr.equals("0:0:0:0:0:0:0:1") ? "127.0.0.1" : ipStr;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><code> 0:0:0:0:0:0:0:1</code> 是<code>[ ipv6 ]</code>的表现形式，对应<code>[ ipv4 ]</code>来说相当于<code>127.0.0.1</code>，也就是本机</p></blockquote><p>上述方法是获取客户端公网IP的方法，通过 ipconfig 本地查询到的 ipv 是内网 ip。</p><blockquote><p>公网ip的查询网站如下：<a href="https://ip.cn/">https://ip.cn/</a> 或者<a href="https://ifconfig.me/">https://ifconfig.me/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义注解与切面实现日志记录</title>
      <link href="/tur-study/2023/04/02/SpringBoot/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%88%87%E9%9D%A2%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/"/>
      <url>/tur-study/2023/04/02/SpringBoot/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E4%B8%8E%E5%88%87%E9%9D%A2%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用到的知识：</p><ul><li>自定义注解</li><li>AOP 的使用</li></ul></blockquote><p>自定义注解和 AOP 切面实现日志记录的步骤如下：</p><h3 id="1-自定义日志注解"><a href="#1-自定义日志注解" class="headerlink" title="1. 自定义日志注解"></a>1. 自定义日志注解</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Target(ElementType.METHOD) // 指定使用的位置：方法上@Retention(RetentionPolicy.RUNTIME) // 指定使用的阶段：运行阶段@Documented // 形成文档注释public @interface BusinessLog {    /**     * 操作模块     * */    String value() default "";    /**     * 操作类型     * */    String type() default "";    /**     * 操作说明     * */    String desc() default "";    /**     * 是否将当前日志记录到数据库中     * */    boolean save() default true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-AOP-切面制作"><a href="#2-AOP-切面制作" class="headerlink" title="2. AOP 切面制作"></a>2. AOP 切面制作</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@Aspect  // 切面表示@Component  // 定义为Beanpublic class BusinessLogAspect {    // 使用自定义注解定义切入点方法    @Pointcut("@annotation(businessLog)")    public void pointcut(BusinessLog businessLog){}    // 通知方法    @Around(value = "pointcut(businessLog)", argNames = "joinPoint,businessLog")    public Object doAround(ProceedingJoinPoint joinPoint, BusinessLog businessLog) throws Throwable {        Object result = joinPoint.proceed();        try {            // do something you need        } catch (Exception e){            log.info("日志记录出错", e);        }        return result;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-自定义注解的使用"><a href="#3-自定义注解的使用" class="headerlink" title="3. 自定义注解的使用"></a>3. 自定义注解的使用</h3><blockquote><p>一般用在 controller 层的接口方法上</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@RestController@Api(value="UserController", tags="用户表业务接口")public class UserController {    @Resource    private UserService  userService;    @GetMapping("/user/ua/simpleInfo")    @ApiOperation(value = "获取用户头像昵称")    @BusinessLog(value = "用户模块", desc = "获取用户头像昵称", type = BusinessLogTypeConstants.SELECT)    public ResponseResult&lt;UserSimpleInfoVO&gt; getUserSimpleInfo(){        return userService.getUserSimpleInfo();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sa-Token-SSO单点登录</title>
      <link href="/tur-study/2023/04/01/SpringBoot/Sa-Token-SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
      <url>/tur-study/2023/04/01/SpringBoot/Sa-Token-SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一、单点登录简述"><a href="#一、单点登录简述" class="headerlink" title="一、单点登录简述"></a>一、单点登录简述</h2><blockquote><p>单点登录是搭建统一认证中心的关键</p></blockquote><h3 id="1-1-单点登录"><a href="#1-1-单点登录" class="headerlink" title="1.1 单点登录"></a>1.1 单点登录</h3><p>单点登录可以将一个系统的各个模块的认证授权互通共享，即用户在一个系统模块登陆之后，便可以畅通无阻的访问其他模块。简而言之，单点登录可以做到：<code>在多个互相信任的系统中，用户只需登陆一次，就可以访问所有系统</code></p><h3 id="1-2-架构选型"><a href="#1-2-架构选型" class="headerlink" title="1.2 架构选型"></a>1.2 架构选型</h3><p>Sa-Token-SSO 由简入难划分为三种模式，解决不同架构下的 SSO 接入问题：</p><table><thead><tr><th>系统架构</th><th>采用模式</th><th>简介</th><th>文档链接</th></tr></thead><tbody><tr><td>前端同域 + 后端同 Redis</td><td>模式一</td><td>共享 Cookie 同步会话</td><td><a href="https://sa-token.cc/doc.html#/sso/sso-type1">文档</a>、<a href="https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-sso1-client">示例</a></td></tr><tr><td>前端不同域 + 后端同 Redis</td><td>模式二</td><td>URL重定向传播会话</td><td><a href="https://sa-token.cc/doc.html#/sso/sso-type2">文档</a>、<a href="https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-sso2-client">示例</a></td></tr><tr><td>前端不同域 + 后端不同 Redis</td><td>模式三</td><td>Http请求获取会话</td><td><a href="https://sa-token.cc/doc.html#/sso/sso-type3">文档</a>、<a href="https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-sso3-client">示例</a></td></tr></tbody></table><ol><li>前端同域：就是指多个系统可以部署在同一个主域名之下，比如：<code>c1.domain.com</code>、<code>c2.domain.com</code>、<code>c3.domain.com</code>。</li><li>后端同Redis：就是指多个系统可以连接同一个Redis。PS：这里并不需要把所有项目的数据都放在同一个Redis中，Sa-Token提供了 <strong><code>[权限缓存与业务缓存分离]</code></strong> 的解决方案，详情戳： <a href="https://sa-token.cc/doc.html#/plugin/alone-redis">Alone独立Redis插件</a>。</li><li>如果既无法做到前端同域，也无法做到后端同Redis，那么只能走模式三，Http请求获取会话（Sa-Token对SSO提供了完整的封装，只需要按照示例从文档上复制几段代码便可以轻松集成）。</li></ol><h3 id="1-3-Sa-Token-SSO-特性"><a href="#1-3-Sa-Token-SSO-特性" class="headerlink" title="1.3 Sa-Token-SSO 特性"></a>1.3 Sa-Token-SSO 特性</h3><ol><li>API 简单易用，文档介绍详细，且提供直接可用的集成示例。</li><li>支持三种模式，不论是否跨域、是否共享Redis、是否前后端分离，都可以完美解决。</li><li>安全性高：内置域名校验、Ticket校验、秘钥校验等，杜绝<code>Ticket劫持</code>、<code>Token窃取</code>等常见攻击手段</li><li>不丢参数：Sa-Token-SSO内有专门的算法保证了参数不丢失，登录成功之后原路返回页面。</li><li>无缝集成：由于Sa-Token本身就是一个权限认证框架，因此可以只用一个框架同时解决<code>权限认证</code> + <code>单点登录</code>问题，让你不再到处搜索：xxx单点登录与xxx权限认证如何整合……</li><li>高可定制：Sa-Token-SSO模块对代码架构侵入性极低，结合Sa-Token本身的路由拦截特性，可以非常轻松的定制化开发。</li></ol><p>下面记录 SSO 单点登录相关步骤：</p><h2 id="二、搭建统一认证中心-SSO-Server"><a href="#二、搭建统一认证中心-SSO-Server" class="headerlink" title="二、搭建统一认证中心 SSO-Server"></a>二、搭建统一认证中心 SSO-Server</h2><p>开始 SSO 对接之前，需要先搭建一个 SSO-Server 认证中</p><p>步骤如下：</p><h3 id="2-1-添加依赖"><a href="#2-1-添加依赖" class="headerlink" title="2.1 添加依赖"></a>2.1 添加依赖</h3><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 权限认证，在线文档：https://sa-token.cc --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token 插件：整合SSO --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-sso<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token 整合 Redis (使用 jackson 序列化方式) --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-dao-redis-jackson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 线程池  --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 视图引擎（在前后端不分离模式下提供视图支持） --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-thymeleaf<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Http请求工具（在模式三的单点注销功能下用到，如不需要可以注释掉） --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.dtflys.forest<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>forest-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.5.26<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-开放认证接口"><a href="#2-2-开放认证接口" class="headerlink" title="2.2 开放认证接口"></a>2.2 开放认证接口</h3><p>开放认证接口：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Sa-Token-SSO Server端 Controller  */@RestControllerpublic class SsoServerController {    /*     * SSO-Server端：处理所有SSO相关请求 (下面的章节我们会详细列出开放的接口)      */    @RequestMapping("/sso/*")    public Object ssoRequest() {        return SaSsoProcessor.instance.serverDister();    }    /**     * 配置SSO相关参数      */    @Autowired    private void configSso(SaSsoConfig sso) {        // 配置：未登录时返回的View         sso.setNotLoginView(() -&gt; {            String msg = "当前会话在SSO-Server端尚未登录，请先访问"                    + "&lt;a href='/sso/doLogin?name=sa&amp;pwd=123456' target='_blank'&gt; doLogin登录 &lt;/a&gt;"                    + "进行登录之后，刷新页面开始授权";            return msg;        });        // 配置：登录处理函数         sso.setDoLoginHandle((name, pwd) -&gt; {            // 此处仅做模拟登录，真实环境应该查询数据进行登录             if("sa".equals(name) &amp;&amp; "123456".equals(pwd)) {                StpUtil.login(10001);                return SaResult.ok("登录成功！").setData(StpUtil.getTokenValue());            }            return SaResult.error("登录失败！");        });        // 配置 Http 请求处理器 （在模式三的单点注销功能下用到，如不需要可以注释掉）         sso.setSendHttp(url -&gt; {            try {                // 发起 http 请求                 System.out.println("------ 发起请求：" + url);                return Forest.get(url).executeAsString();            } catch (Exception e) {                e.printStackTrace();                return null;            }        });    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>==注意：==</p><ul><li>在<code>setDoLoginHandle</code>函数里如果要获取name, pwd以外的参数，可通过<code>SaHolder.getRequest().getParam("xxx")</code>来获取 </li><li>在 <code>setSendHttp</code> 函数中，使用 <code>try-catch</code> 是为了提高整个注销流程的容错性，避免在一些极端情况下注销失败（例如：某个 Client 端上线之后又下线，导致 http 请求无法调用成功，从而阻断了整个注销流程）</li></ul><p>全局异常处理：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestControllerAdvicepublic class GlobalExceptionHandler {    // 全局异常拦截     @ExceptionHandler    public SaResult handlerException(Exception e) {        e.printStackTrace();         return SaResult.error(e.getMessage());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-application-yml-配置"><a href="#2-3-application-yml-配置" class="headerlink" title="2.3 application.yml 配置"></a>2.3 application.yml 配置</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 端口server:    port: 8800# Sa-Token 配置sa-token:     # ------- SSO-模式一相关配置  (非模式一不需要配置)     # cookie:         # 配置 Cookie 作用域         # domain: stp.com     # ------- SSO-模式二相关配置     sso:         # Ticket有效期 (单位: 秒)，默认五分钟         ticket-timeout: 300        # 所有允许的授权回调地址        allow-url: "*"        # 是否打开单点注销功能        is-slo: true        # ------- SSO-模式三相关配置 （下面的配置在SSO模式三并且 is-slo=true 时打开）        # 是否打开模式三         isHttp: true        # 接口调用秘钥（用于SSO模式三的单点注销功能）        secretkey: kQwIOrYvnXmSDkwEiFngrKidMcdrgKor        # ---- 除了以上配置项，你还需要为 Sa-Token 配置http请求处理器（文档有步骤说明） spring:     # Redis配置 （SSO模式一和模式二使用Redis来同步会话）    redis:        # Redis数据库索引（默认为0）        database: 1        # Redis服务器地址        host: 127.0.0.1        # Redis服务器连接端口        port: 6379        # Redis服务器连接密码（默认为空）        password: forest:     # 关闭 forest 请求日志打印    log-enabled: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>==注意：==</p><p><code>sa-token.sso.allow-url</code>为了方便测试配置为<code>*</code>，线上生产环境一定要配置为详细URL地址 </p></blockquote><h3 id="2-4-启动类"><a href="#2-4-启动类" class="headerlink" title="2.4 启动类"></a>2.4 启动类</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Slf4j@SpringBootApplication@MapperScan("com.blog.mapper")public class WebApplication {    public static void main(String[] args) {        SpringApplication.run(WebApplication.class, args);        log.info("\n---------Sa-Token-SSO认证中心启动成功");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>启动项目后：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020759417.png" alt="image-20230402075945152"></p><p>访问统一授权地址：（具体访问路径依据实际情况自己设定）</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020800521.png" alt="image-20230402080039458"></p><h2 id="三、SSO模式一：共享Cookie同步会话"><a href="#三、SSO模式一：共享Cookie同步会话" class="headerlink" title="三、SSO模式一：共享Cookie同步会话"></a>三、SSO模式一：共享Cookie同步会话</h2><blockquote><p>如果多个系统可以做到：前端同域，后端同Redis，便可以用 <code>共享Cookie同步会话</code> 的方式做到单点登录</p></blockquote><h3 id="3-1-解决思路"><a href="#3-1-解决思路" class="headerlink" title="3.1 解决思路"></a>3.1 解决思路</h3><p>多个系统之间为什么无法同步登录状态？</p><ol><li>前端的 <code>Token </code>无法在多个系统下共享</li><li>后端的 <code>Session </code>无法在多个系统间共享</li></ol><p>对于上述原因，单点登录有如下方法解决：</p><ol><li>使用 <code>共享Cookie</code> 来解决  Token 共享问题</li><li>使用 <code>Redis </code>来解决Session 共享问题</li></ol><p><strong>共享Cookie</strong></p><p>共享Cookie就是主域名Cookie在二级域名下的共享</p><p>示例：写在父域名<code>stp.com</code>下的Cookie，在<code>s1.stp.com</code>、<code>s2.stp.com</code>等子域名都是可以共享访问的。</p><p><strong>共享Redis</strong></p><p>共享Redis，并不需要我们把所有项目的数据都放在同一个Redis中，Sa-Token提供了 <strong>[权限缓存与业务缓存分离]</strong> 的解决方案</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020816900.png" alt="image-20230402081618844"></p><h3 id="3-2-准备工作"><a href="#3-2-准备工作" class="headerlink" title="3.2 准备工作"></a>3.2 准备工作</h3><p>修改hosts 文件<code>(C:\windows\system32\drivers\etc\hosts)</code>，添加以下IP映射，方便测试</p><pre class="line-numbers language-uri" data-language="uri"><code class="language-uri">127.0.0.1 sso.stp.com127.0.0.1 s1.stp.com127.0.0.1 s2.stp.com127.0.0.1 s3.stp.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中：<code>sso.stp.com</code>为统一认证中心地址，当用户在其它 Client 端发起登录请求时，均将其重定向至认证中心，待到登录成功之后再原路返回到 Client 端</p><h3 id="3-3-指定-Cookie-的作用域"><a href="#3-3-指定-Cookie-的作用域" class="headerlink" title="3.3 指定 Cookie 的作用域"></a>3.3 指定 Cookie 的作用域</h3><p>在<code>sso.stp.com</code>访问服务器，其Cookie也只能写入到<code>sso.stp.com</code>下，为了将Cookie写入到其父级域名<code>stp.com</code>下，我们需要更改 SSO-Server 端的 yml 配置：</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">sa-token:     cookie:         # 配置 Cookie 作用域         domain: stp.com <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-搭建-Client-端项目"><a href="#3-4-搭建-Client-端项目" class="headerlink" title="3.4 搭建 Client 端项目"></a>3.4 搭建 Client 端项目</h3><h5 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 权限认证, 在线文档：https://sa-token.cc --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token 插件：整合SSO --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-sso<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token 整合redis (使用jackson序列化方式) --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-dao-redis-jackson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- Sa-Token插件：权限缓存与业务缓存分离 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-alone-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-新建-Controller-控制器"><a href="#2-新建-Controller-控制器" class="headerlink" title="2. 新建 Controller 控制器"></a>2. 新建 Controller 控制器</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * Sa-Token-SSO Client端 Controller  * @author kong */@RestControllerpublic class SsoClientController {    // SSO-Client端：首页     @RequestMapping("/")    public String index() {        String authUrl = SaSsoManager.getConfig().splicingAuthUrl();        String solUrl = SaSsoManager.getConfig().splicingSloUrl();        String str = "&lt;h2&gt;Sa-Token SSO-Client 应用端&lt;/h2&gt;" +                     "&lt;p&gt;当前会话是否登录：" + StpUtil.isLogin() + "&lt;/p&gt;" +                     "&lt;p&gt;&lt;a href=\"javascript:location.href='" + authUrl + "?mode=simple&amp;redirect=' + encodeURIComponent(location.href);\"&gt;登录&lt;/a&gt; " +                     "&lt;a href=\"javascript:location.href='" + solUrl + "?back=' + encodeURIComponent(location.href);\"&gt;注销&lt;/a&gt; &lt;/p&gt;";        return str;    }    // 全局异常拦截     @ExceptionHandler    public SaResult handlerException(Exception e) {        e.printStackTrace();         return SaResult.error(e.getMessage());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-application-yml-配置"><a href="#3-application-yml-配置" class="headerlink" title="3. application.yml 配置"></a>3. application.yml 配置</h5><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 端口server:    port: 9001# Sa-Token 配置 sa-token:     # SSO-相关配置    sso:         # SSO-Server端-单点登录授权地址         auth-url: http://sso.stp.com:9000/sso/auth        # SSO-Server端-单点注销地址        slo-url: http://sso.stp.com:9000/sso/signout    # 配置 Sa-Token 单独使用的Redis连接 （此处需要和SSO-Server端连接同一个Redis）    alone-redis:         # Redis数据库索引        database: 1        # Redis服务器地址        host: 127.0.0.1        # Redis服务器连接端口        port: 6379        # Redis服务器连接密码（默认为空）        password:         # 连接超时时间        timeout: 10s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-启动类"><a href="#4-启动类" class="headerlink" title="4. 启动类"></a>4. 启动类</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * SSO模式一，Client端 Demo  */@SpringBootApplicationpublic class SaSso1ClientApplication {    public static void main(String[] args) {        SpringApplication.run(SaSso1ClientApplication.class, args);        System.out.println("\nSa-Token SSO模式一 Client端启动成功");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-访问测试"><a href="#5-访问测试" class="headerlink" title="5. 访问测试"></a>5. 访问测试</h5><p>启动client端和server端，访问 <code>http://s1.stp.com:9001</code></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020851161.png" alt="image-20230402085133074"></p><p>点击登录，重定向至认证中心：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020852328.png" alt="image-20230402085201271"></p><p>点击登录后再刷新页面：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020853616.png" alt="image-20230402085306565"></p><p>刷新另外两个Client端，均显示已登录 </p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304020853412.png" alt="sso1-login-ok2.png"></p><p>测试完成 </p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Sa-Token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Feign使用详解</title>
      <link href="/tur-study/2023/04/01/SpringCloud/Feign%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/04/01/SpringCloud/Feign%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="1-Feign-的基础使用"><a href="#1-Feign-的基础使用" class="headerlink" title="1. Feign 的基础使用"></a>1. Feign 的基础使用</h3><p>Feign 的使用步骤如下：</p><h4 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-添加注解"><a href="#2-添加注解" class="headerlink" title="2. 添加注解"></a>2. 添加注解</h4><p>在启动类中添加注解 <code>@EnableFeignClients</code> 开启Feign 的功能</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304261706380.png" alt="image-20210714175102524"></p><h4 id="3-编写Feign-的客户端"><a href="#3-编写Feign-的客户端" class="headerlink" title="3. 编写Feign 的客户端"></a>3. 编写Feign 的客户端</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@FeignClient("userservice") // value="服务名称"public interface UserClient {        // 与接口声明一样    @GetMapping("/user/{id}")    User findById(@PathVariable("id") Long id);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个客户端主要是基于SpringMVC的注解来声明远程调用的信息，比如：</p><ul><li>服务名称：userservice</li><li>请求方式：GET</li><li>请求路径：/user/{id}</li><li>请求参数：Long id</li><li>返回值类型：User</li></ul><p>这样，Feign就可以帮助我们发送http请求，无需自己使用RestTemplate来发送了。</p><h3 id="2-自定义配置"><a href="#2-自定义配置" class="headerlink" title="2. 自定义配置"></a>2. 自定义配置</h3><p>eign可以支持很多的自定义配置，如下表所示：</p><table><thead><tr><th>类型</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td><strong>feign.Logger.Level</strong></td><td>修改日志级别</td><td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td></tr><tr><td>feign.codec.Decoder</td><td>响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td>feign.codec.Encoder</td><td>请求参数编码</td><td>将请求参数编码，便于通过http请求发送</td></tr><tr><td>feign. Contract</td><td>支持的注解格式</td><td>默认是SpringMVC的注解</td></tr><tr><td>feign. Retryer</td><td>失败重试机制</td><td>请求失败的重试机制，默认是没有，不过会使用Ribbon的重试</td></tr></tbody></table><p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的@Bean覆盖默认Bean即可。</p><h3 id="3-Feign-使用优化"><a href="#3-Feign-使用优化" class="headerlink" title="3. Feign 使用优化"></a>3. Feign 使用优化</h3><p>Feign底层发起http请求，依赖于其它的框架。其底层客户端实现包括：</p><ul><li>URLConnection：默认实现，不支持连接池</li><li>Apache HttpClient ：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>因此提高<code>Feign</code>的性能主要手段就是使用<strong>连接池</strong>代替默认的<code>URLConnection</code>。</p><p>使用步骤如下：</p><blockquote><p>以 Apache 的 HttpClient 为例</p></blockquote><h4 id="3-1-引入依赖"><a href="#3-1-引入依赖" class="headerlink" title="3.1 引入依赖"></a>3.1 引入依赖</h4><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!--httpClient的依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.github.openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>feign-httpclient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-2-配置连接池"><a href="#3-2-配置连接池" class="headerlink" title="3.2 配置连接池"></a>3.2 配置连接池</h4><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">feign:  client:    config:      default: # default全局的配置        loggerLevel: BASIC # 日志级别，BASIC就是基本的请求和响应信息  httpclient:    enabled: true # 开启feign对HttpClient的支持    max-connections: 200 # 最大的连接数    max-connections-per-route: 50 # 每个路径的最大连接数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-最佳实践"><a href="#4-最佳实践" class="headerlink" title="4. 最佳实践"></a>4. 最佳实践</h3><p>feign 的客户端与服务提供者的controller 代码非常相似：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304261712958.png" alt="image-20210714190542730"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304261713354.png" alt="image-20210714190528450"></p><p>所以，需要简化这种重复代码的编写</p><h4 id="4-1-继承方式"><a href="#4-1-继承方式" class="headerlink" title="4.1 继承方式"></a>4.1 继承方式</h4><p>一样的代码可以通过继承来共享：</p><ol><li>定义一个API接口，利用定义方法，并基于SpringMVC注解做声明。</li><li>Feign客户端和Controller都集成改接口</li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304261715438.png" alt="image-20210714190640857"></p><p>优点：</p><ul><li>简单</li><li>实现了代码共享</li></ul><p>缺点：</p><ul><li><p>服务提供方、服务消费方紧耦合</p></li><li><p>参数列表中的注解映射并不会继承，因此Controller中必须再次声明方法、参数列表、注解</p></li></ul><h4 id="4-2-抽取方式"><a href="#4-2-抽取方式" class="headerlink" title="4.2 抽取方式"></a>4.2 抽取方式</h4><p>将Feign的Client抽取为独立模块，并且把接口有关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p><p>例如，将UserClient、User、Feign的默认配置都抽取到一个feign-api包中，所有微服务引用该依赖包，即可直接使用。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304261716772.png" alt="image-20210714214041796"></p>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java正则</title>
      <link href="/tur-study/2023/04/01/Java/Java%E6%AD%A3%E5%88%99/"/>
      <url>/tur-study/2023/04/01/Java/Java%E6%AD%A3%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h2 id="一、正则表达式"><a href="#一、正则表达式" class="headerlink" title="一、正则表达式"></a>一、正则表达式</h2><h3 id="1-1-特殊字符"><a href="#1-1-特殊字符" class="headerlink" title="1.1 特殊字符"></a>1.1 特殊字符</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011503699.png" alt="image-20230401150341463"></p><h3 id="1-2-限定符"><a href="#1-2-限定符" class="headerlink" title="1.2 限定符"></a>1.2 限定符</h3><p>限定符用来指针正则表达式的一个给定组件必须要出现次才能满足适配，有 <code>*、+、?、{n}、{n,}、{n, m}</code>共六种</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011505216.png" alt="image-20230401150555170"></p><p>示例：以下正则表达式匹配一个正整数，<code>[1-9]</code>设置第一个数字不是0，<code>[0-9]* </code>表示任意多个数字：</p><pre class="line-numbers language-none"><code class="language-none">/[1-9][0-9]*/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="二、Pattern-类和-Matcher-类"><a href="#二、Pattern-类和-Matcher-类" class="headerlink" title="二、Pattern 类和 Matcher 类"></a>二、Pattern 类和 Matcher 类</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>Pattern 对象是正则表达式编译后再内存中的表现形式。即正则表达式字符串必须先被编译为 Pattern 对象，然后再利用该 Pattern 对象创建对应的 Matcher 对象</p><p>Matcher 对象保留匹配的结果，多个 Matcher 对象可共享同一个 Pattern 对象</p><h3 id="2-Pattern-类常用方法"><a href="#2-Pattern-类常用方法" class="headerlink" title="2. Pattern 类常用方法"></a>2. Pattern 类常用方法</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 将一个字符串编译成 Pattern 对象Pattern pattern = Pattern.compile("a*c");// 使用 Pattern 对象创建 Matcher 对象Matcher matcher = pattern.matcher("abc");// 返回 trueboolean result = matcher.matches();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面定义的 Pattern 对象可以多次重复使用。如果某个正则表达式仅需一次使用，则可直接使用 Pattern 类的静态 <code>matches()</code>方法，此方法自动把指定字符串编译成匿名的 Pattern 对象，并执行匹配，代码如下所示：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 返回 trueboolean result = Pattern.matches ("a*c","abc");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-Matcher-类常用方法"><a href="#3-Matcher-类常用方法" class="headerlink" title="3. Matcher 类常用方法"></a>3. Matcher 类常用方法</h3><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">find()</td><td align="center">返回目标字符串中是否包含与 Pattern 匹配的子串</td></tr><tr><td align="center">group()</td><td align="center">返回上一次与 Pattern 匹配的子串</td></tr><tr><td align="center">start()</td><td align="center">返回上一次与 Pattern 匹配的子串在目标字符串中的开始位置</td></tr><tr><td align="center">end()</td><td align="center">返回上一次与 Pattern 匹配的子串在目标字符串中的结束位置加 1</td></tr><tr><td align="center">lookingAt()</td><td align="center">返回目标字符串前面部分与 Pattern 是否匹配</td></tr><tr><td align="center">matches()</td><td align="center">返回整个目标字符串与 Pattern 是否匹配</td></tr><tr><td align="center">reset()</td><td align="center">将现有的 Matcher 对象应用于一个新的字符序列。</td></tr></tbody></table><h4 id="3-1-find-和-group-方法"><a href="#3-1-find-和-group-方法" class="headerlink" title="3.1 find() 和 group() 方法"></a>3.1 find() 和 group() 方法</h4><p>通过 Matcher 类的 <code>find()</code> 和 <code>group()</code> 方法可以从目标字符串中依次取出特定子串（匹配正则表达式的子串），例如互联网的网络爬虫，它们可以自动从网页中识别出所有的电话号码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test{    public static void main(String[] args)    {        // 使用字符串模拟从网络上得到的网页源码        String str = "出售JAVA教程，联系电话：13600000001" + "毕业代做，联系电话：13600000002" + "出售二手电脑，联系电话：15800000001";        // 创建一个Pattern对象，并用它建立一个Matcher对象        // 该正则表达式只抓取13X和15X段的手机号        // 实际要抓取哪些电话号码，只要修改正则表达式即可        Matcher m = Pattern.compile("((13\\d)|(15\\d))\\d{8}").matcher(str);        // 将所有符合正则表达式的子串（电话号码）全部输出        while (m.find())        {            System.out.println(m.group());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面运行结果可以看出，<code>find()</code> 方法依次查找字符串中与 Pattern 匹配的子串，一旦找到对应的子串，下次调用 <code>find()</code> 方法时将接着向下查找。</p><h4 id="3-2-start-和-end-方法"><a href="#3-2-start-和-end-方法" class="headerlink" title="3.2 start() 和 end() 方法"></a>3.2 start() 和 end() 方法</h4><p><code>find()</code> 方法还可以传入一个 int 类型的参数，带 int 参数的 <code>find()</code> 方法将从该 int 索引处向下搜索。<code>start()</code> 和 <code>end() </code>方法主要用于确定子串在目标字符串中的位置，如下程序所示。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test2{    public static void main(String[] args)    {        // 创建一个Pattern对象，并用它建立一个Matcher对象        String regStr = "Java is very easy!";        System.out.println("目标字符串是：" + regStr);        Matcher m = Pattern.compile("\\w+").matcher(regStr);        while (m.find())        {            System.out.println(m.group() + "子串的起始位置：" + m.start() + "，其结束位置：" + m.end());        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面程序使用 <code>find()</code>、<code>group()</code> 方法逐项取出目标字符串中与指定正则表达式匹配的子串，并使用<code>start()</code>、<code>end()</code> 方法返回子串在目标字符串中的位置。运行上面程序，看到如下运行结果：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">目标字符串是：Java is very easy!Java子串的起始位置：0，其结束位置：4is子串的起始位置：5，其结束位置：7very子串的起始位置：8，其结束位置：12easy子串的起始位置：13，其结束位置：17<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-3-matches-和-LookingAt-方法"><a href="#3-3-matches-和-LookingAt-方法" class="headerlink" title="3.3 matches() 和 LookingAt() 方法"></a>3.3 matches() 和 LookingAt() 方法</h4><p><code>matches()</code> 和 <code>lookingAt()</code> 方法有点相似，只是 <code>matches()</code> 方法要求整个字符串和 Pattern 完全匹配时才返回 <code>true</code>，而 <code>lookingAt()</code> 只要字符串以 Pattern 开头就会返回 <code>true</code>。<code>reset()</code> 方法可将现有的 Matcher 对象应用于新的字符序列：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test3{    public static void main(String[] args)    {        String[] mails =        { "mymail@163.com", "mymail@gmail.com", "mymail@myweb.org", "mymail@abc.xx" };        String mailRegEx = "\\w{3,20}@\\w+\\.(com|org|cn|net|gov)";        Pattern mailPattern = Pattern.compile(mailRegEx);        Matcher matcher = null;        for (String mail : mails)        {            if (matcher == null)            {                matcher = mailPattern.matcher(mail);            }            else            {                matcher.reset(mail);            }            String result = mail + (matcher.matches() ? "是" : "不是") + "一个有效的邮件地址！";            System.out.println(result);        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面程序创建了一个邮件地址的 Pattern，接着用这个 Pattern 与多个邮件地址进行匹配。当程序中的 Matcher 为 <code>null</code> 时，程序调用 <code>matcher()</code> 方法来创建一个 Matcher 对象，一旦 Matcher 对象被创建，程序就调用 Matcher 的 <code>reset()</code> 方法将该 Matcher 应用于新的字符序列。</p><p>从某个角度来看，Matcher 的 <code>matches()</code>、<code>lookingAt()</code> 和 String 类的 <code>equals()</code> 有点相似。区别是 String 类的 <code>equals()</code> 都是与字符串进行比较，而 Matcher 的 <code>matches()</code> 和 <code>lookingAt()</code> 则是与正则表达式进行匹配。</p><p>事实上，String 类里也提供了 <code>matches()</code> 方法，该方法返回该字符串是否匹配指定的正则表达式。例如：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">"mymail@163.com".matches("\\w{3,20}@\\w+\\.(com|org|cn|net|gov)"); // 返回 true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><h3 id="3-1-匹配数字"><a href="#3-1-匹配数字" class="headerlink" title="3.1 匹配数字"></a>3.1 匹配数字</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * \d 的含义是 [0-9] * \D 的含义是 [^0-9] * {n} 匹配确定 n 次 */public static void matchNumber() {        Pattern p = Pattern.compile("summary_day\\.\\d+[0-9]\\.\\d{17}");        Matcher m = p.matcher("ipva.summary_day.20210621.20210622000205860.B20C41AB-0A17-46DB-9177-817533B8E551.1624291336921.txt");        System.out.println(m.pattern()); //myArray\[\d\]        while (m.find()){            System.out.println(m.group());        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011519329.png" alt="image-20230401151914278"></p><h3 id="3-2-匹配字母"><a href="#3-2-匹配字母" class="headerlink" title="3.2 匹配字母"></a>3.2 匹配字母</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * \w 任何一个字母数字字符（大小写均可）或下划线，等价于 [A-Za-z0-9_] * \W 表示[^A-Za-z0-9_] * + 匹配前面的子表达式或一次或多次 */public static void matchAlphanum() {        Pattern pattern = Pattern.compile("^ipva\\.\\w+");        Matcher matcher = pattern.matcher("ipva.summary_day.20210621.20210622000205860.B20C41AB-0A17-46DB-9177-817533B8E551.1624291336921.txt");        while (matcher.find()) {            System.out.println(matcher.group(0));        }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011520210.png" alt="image-20230401152003168"></p><h3 id="3-3-特殊字符一"><a href="#3-3-特殊字符一" class="headerlink" title="3.3 特殊字符一"></a>3.3 特殊字符一</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * "*" 表示含有零个或者多个 * "+" 匹配前面的子表达式或一次或多次 */public static void matchRepeat() {    Pattern pattern = Pattern.compile("\\w+[\\w\\.]*@[\\d]+\\.\\w+");    Matcher matcher = pattern.matcher("Hello .kangll@163.com is my email address.");    while (matcher.find()) {        System.out.println(matcher.group(0));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011521053.png" alt="image-20230401152153010"></p><h3 id="3-4-特殊字符二"><a href="#3-4-特殊字符二" class="headerlink" title="3.4 特殊字符二"></a>3.4 特殊字符二</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * "*" 表示含有零个或者多个 * "+" 表示匹配前面的子表达式或一次或多次 * "?" 表示匹配零个或者一个字符 */public static void matchRepeat02() {    Pattern pattern = Pattern.compile("http[s]?://[\\w\\.]+");    Matcher matcher = pattern.matcher("The URL is http://www.kangll.com/");    while (matcher.find()) {        System.out.println(matcher.group(0));    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202304011522577.png" alt="image-20230401152240532"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadPoolTaskExecutor的使用</title>
      <link href="/tur-study/2023/04/01/SpringBoot/ThreadPoolTaskExecutor%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/04/01/SpringBoot/ThreadPoolTaskExecutor%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、线程池简介"><a href="#一、线程池简介" class="headerlink" title="一、线程池简介"></a>一、线程池简介</h2><h3 id="1-1-为什么使用线程池"><a href="#1-1-为什么使用线程池" class="headerlink" title="1.1 为什么使用线程池"></a>1.1 为什么使用线程池</h3><ul><li>降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗</li><li>提高系统响应速度，当有任务到达时，通过复用已存在的线程，无需等待新线程的创建，便能立即执行</li><li>方便线程并发数的管控，因为线程若是无限制的创建，可能会导致内存占用过多而产生 <code>OOM</code>，并且会造成 <code>cpu </code>过度切换</li></ul><blockquote><ul><li><p><code>OOM</code>：Out of Memory，内存溢出，即内存不够了。详细见：<a href="https://blog.csdn.net/lovedingd/article/details/104650249/">https://blog.csdn.net/lovedingd/article/details/104650249/</a></p></li><li><p>cpu切换线程有时间成本，需要保持当前执行线程的现场，并恢复要执行线程的现场</p></li></ul></blockquote><ul><li>提供更强大的功能，延时定时线程池</li></ul><h3 id="1-2-线程池需要使用队列的原因"><a href="#1-2-线程池需要使用队列的原因" class="headerlink" title="1.2 线程池需要使用队列的原因"></a>1.2 线程池需要使用队列的原因</h3><p>线程若是无限制创建，可能会导致<code>内存</code>占用过多而产生 <code>OOM</code>，并且会造成<code>cpu</code>过度切换，创建线程池的消耗较高或者线程池创建线程需要获取 <code>mainlock </code>这个全局锁，影响并发效率，阻塞队列可以很好的缓冲</p><h3 id="1-3-线程池使用阻塞队列的原因"><a href="#1-3-线程池使用阻塞队列的原因" class="headerlink" title="1.3 线程池使用阻塞队列的原因"></a>1.3 线程池使用阻塞队列的原因</h3><p><code>阻塞队列</code>可以保证任务队列中没有任务时阻塞获取任务的线程，是的线程进入 <code>wait</code> 状态，释放 <code>cpu </code>资源，当队列中有任务时才唤醒对应线程，从队列中取出消息进行执行，使得线程不至于一直占用 <code>cpu </code>资源</p><blockquote><p>线程执行完任务后通过循环再次从任务队列中取出任务进行执行，代码片段如：<code>while(task != null || (task = getTask()) != null){}</code></p></blockquote><p>不用阻塞队列也是可以的，不过实现起来比较麻烦。</p><h3 id="1-4-线程池的配置"><a href="#1-4-线程池的配置" class="headerlink" title="1.4 线程池的配置"></a>1.4 线程池的配置</h3><h5 id="1-CPU密集型任务"><a href="#1-CPU密集型任务" class="headerlink" title="1. CPU密集型任务"></a>1. CPU密集型任务</h5><p>尽量使用较小的线程池，一般为 <code>CPU </code>核心数 <code>+1</code>，因为 <code>CPU </code>密集型任务使得 <code>CPU </code>使用率较高，若是开过多的线程数，会造成 <code>CPU </code>付过度切换</p><h5 id="2-IO-密集型任务"><a href="#2-IO-密集型任务" class="headerlink" title="2. IO 密集型任务"></a>2. IO 密集型任务</h5><p>可以使用稍大的线程池，一般为 <code>2*CPU</code> 核心数。<code>IO </code>密集型任务 <code>CPU </code>使用率并不高，因此可以让 <code>CPU </code>在等待 <code>IO </code>的时候有其他线程去处理别的任务，充分利用 <code>CPU </code>时间</p><h5 id="3-混合型任务"><a href="#3-混合型任务" class="headerlink" title="3. 混合型任务"></a>3. 混合型任务</h5><p>可以将任务分成IO密集型和CPU密集型任务，然后分别用不同的线程池去处理。 只要分完之后两个任务的执行时间相差不大，那么就会比串行执行来的高效<br>因为如果划分之后两个任务执行时间有数据级的差距，那么拆分没有意义。<br>因为先执行完的任务就要等后执行完的任务，最终的时间仍然取决于后执行完的任务，而且还要加上任务拆分与合并的开销，得不偿失</p><h3 id="1-5-execute-和-submit-方法"><a href="#1-5-execute-和-submit-方法" class="headerlink" title="1.5 execute() 和 submit() 方法"></a>1.5 execute() 和 submit() 方法</h3><ul><li><code>execute()</code>：执行一个任务，没有返回值</li><li><code>submit()</code>，提交一个线程任务，有返回值</li></ul><p>submit(Callable<t> task)能获取到它的返回值，通过future.get()获取（阻塞直到任务执行完）。一般使用FutureTask+Callable配合使用<br>submit(Runnable task, T result)能通过传入的载体result间接获得线程的返回值。<br>submit(Runnable task)则是没有返回值的，就算获取它的返回值也是null</t></p><p>Future.get()方法会使取结果的线程进入阻塞状态，直到线程执行完成之后，唤醒取结果的线程，然后返回结果</p><h2 id="二、Spring-线程池"><a href="#二、Spring-线程池" class="headerlink" title="二、Spring 线程池"></a>二、Spring 线程池</h2><h3 id="2-1-Spring-线程池种类"><a href="#2-1-Spring-线程池种类" class="headerlink" title="2.1 Spring 线程池种类"></a>2.1 Spring 线程池种类</h3><h4 id="1-Spring-线程池的使用"><a href="#1-Spring-线程池的使用" class="headerlink" title="1. Spring 线程池的使用"></a>1. Spring 线程池的使用</h4><ul><li>Spring 通过任务执行器<code>TaskExecutor</code> 来实现多线程和并发</li><li>使用 <code>ThreadPoolTaskExecutor</code> 实现一个基于线程池的 <code>TaskExecutor</code></li><li>使用 <code>@EnableAsync</code> 开启异步，并通过在需要异步的方法上使用注解 <code>@Async</code> 声明是一个异步任务</li></ul><h4 id="2-Spring-已经实现的异常线程池："><a href="#2-Spring-已经实现的异常线程池：" class="headerlink" title="2. Spring 已经实现的异常线程池："></a>2. Spring 已经实现的异常线程池：</h4><ul><li><code>SimpleAsyncTaskExecutor</code>：不是真的线程池，这个类不重用线程，每次调用都会创建一个新的线程。</li><li><code>SyncTaskExecutor</code>：这个类没有实现异步调用，只是一个同步操作。只适用于不需要多线程的地方</li><li><code>ConcurrentTaskExecutor</code>：<code>Executor</code>的适配类，不推荐使用。如果<code>ThreadPoolTaskExecutor</code>不满足要求时，才用考虑使用这个类</li><li><code>SimpleThreadPoolTaskExecutor</code>：是<code>Quartz</code>的<code>SimpleThreadPool</code>的类。线程池同时被<code>quartz</code>和<code>非quartz</code>使用，才需要使用此类</li><li><code>ThreadPoolTaskExecutor </code>：最常使用，推荐。 其实质是对<code>java.util.concurrent.ThreadPoolExecutor</code>的包装</li></ul><h3 id="2-2-ThreadPoolTaskExecutor的使用"><a href="#2-2-ThreadPoolTaskExecutor的使用" class="headerlink" title="2.2 ThreadPoolTaskExecutor的使用"></a>2.2 ThreadPoolTaskExecutor的使用</h3><h4 id="1-线程池配置类"><a href="#1-线程池配置类" class="headerlink" title="1. 线程池配置类"></a>1. 线程池配置类</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configuration@EnableAsync # 开启异步public class TaskExecuteConfig {    @Value("task.executor.core_pool_size")    private int corePoolSize;    @Value("task.executor.max_pool_size")    private int maxPoolSize;    @Value("task.executor.queue_capacity")    private int queueCapacity;    @Value("task.executor.keep_alive_seconds")    private long keepAliveSeconds;    @Bean(name = "threadPoolTaskExecutor")    public ThreadPoolTaskExecutor SendTaskExecutor(){        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();        // 配置核心线程数        executor.setCorePoolSize(corePoolSize);        //最大线程数        executor.setMaxPoolSize(maxPoolSize);        // 队列大小        executor.setQueueCapacity(queueCapacity);        // 线程池维护线程所允许的空闲时间，单位秒，超过则销毁        // 线程池线程数量大于corePoolSize时，多出来的空闲线程，多长时间会被销毁        executor.setKeepAliveSeconds(keepAliveSeconds);        // 配置线程池中的线程名称前缀        executor.setThreadNamePrefix("pool-send-task-executor");        // 线程池拒绝策略        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());        executor.initialize();        return executor;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置类中方法说明：</p><ul><li><code>corePoolSize</code>:线程池维护线程的最小数量</li><li><code>maxPoolSize</code>:线程池维护线程的最大数量，线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值。如果队列中任务已满，并且当前线程个数小于maxPoolSize，那么会创建新的线程来执行任务。</li><li><code>keepAliveSeconds</code>:空闲线程的存活时间，单位秒</li><li><code>queueCapacity</code>：持有等待执行的任务队列，一个阻塞队列，用来存储等待执行的任务，当线程池中的线程数超过它的<code>corePoolSize</code>的时候，线程会进入阻塞队列进行阻塞等待</li><li><code>RejectedExecutionHandler handler</code>： 线程池的拒绝策略，是指当任务添加到线程池中被拒绝，而采取的处理措施。<br>当任务添加到线程池中之所以被拒绝，可能是由于：第一，线程池异常关闭。第二，任务数量超过线程池的最大限制。</li></ul><blockquote><p>Reject 策略预定义有如下四种：</p><ol><li><code>ThreadPoolExecutor.AbortPolicy</code>策略，是默认的策略,处理程序遭到拒绝将抛出运行时 RejectedExecutionException</li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>策略 ,调用者的线程会执行该任务,如果执行器已关闭,则丢弃.</li><li><code>ThreadPoolExecutor.DiscardPolicy</code>策略，不能执行的任务将被丢弃.</li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>策略，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）</li><li>自定义策略：当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务</li></ol></blockquote><h4 id="2-异步方法"><a href="#2-异步方法" class="headerlink" title="2. 异步方法"></a>2. 异步方法</h4><p><code>@Async</code>注解可以用在方法上，表示该方法是个异步方法，也可以用在类上，那么表示此类的所有方法都是异步方法2 异步方法会自动注入使用<code>ThreadPoolTaskExecutor</code>作为<code>TaskExecutor</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Servicepublic class AsyncTaskService {    @Async    public void executeAsync(Integer i) throws Exception{        System.out.println("线程ID：" + Thread.currentThread().getId() + "线程名字：" +Thread.currentThread().getName()+"执行异步任务:" + i);    }    @Async    public Future&lt;String&gt; executeAsyncPlus(Integer i) throws Exception {        System.out.println("线程ID：" + Thread.currentThread().getId() +"线程名字：" +Thread.currentThread().getName()+ "执行异步有返回的任务:" + i);        return new AsyncResult&lt;&gt;("success:"+i);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot整合Redis</title>
      <link href="/tur-study/2023/03/31/SpringBoot/SpringBoot%E6%95%B4%E5%90%88Redis/"/>
      <url>/tur-study/2023/03/31/SpringBoot/SpringBoot%E6%95%B4%E5%90%88Redis/</url>
      
        <content type="html"><![CDATA[<p><code>SpringBoot </code>中对 <code>Redis </code>的集成模块为 <code>SpringDataRedis</code>。官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li><p>提供了对不同Redis客户端的整合（<code>Lettuce</code>和<code>Jedis</code>）</p></li><li><p>提供了<code>RedisTemplate</code>统一API来操作Redis</p></li><li><p>支持Redis的发布订阅模型</p></li><li><p>支持Redis哨兵和Redis集群</p></li><li><p>支持基于<code>Lettuce</code>的响应式编程</p></li><li><p>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</p></li><li><p>支持基于Redis的<code>JDKCollection</code>实现</p></li></ul><h3 id="1-SpringDataRedis-的基本使用"><a href="#1-SpringDataRedis-的基本使用" class="headerlink" title="1. SpringDataRedis 的基本使用"></a>1. SpringDataRedis 的基本使用</h3><p><code>SpringDataRedis </code>中提供了 <code>RedisTemplate </code>工具类，其中封装了各种对 Redis 的操作，并且将不同数据类型的操作 API 封装到了不同的类型中</p><table><thead><tr><th align="center">API</th><th align="center">返回值类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">redisTemplate.opsForValue()</td><td align="center">ValueOperations</td><td align="center">操作 String 类型数据</td></tr><tr><td align="center">redisTemplate.opsForHash()</td><td align="center">HashOperations</td><td align="center">操作 Hash 类型数据</td></tr><tr><td align="center">redisTemplate.opsForList()</td><td align="center">ListOperations</td><td align="center">操作 List 类型数据</td></tr><tr><td align="center">redisTemplate.opsForSet()</td><td align="center">SetOperations</td><td align="center">操作 Set 类型数据</td></tr><tr><td align="center">redisTemplate.opsForZSet()</td><td align="center">ZSetOperations</td><td align="center">操作 ZSet 类型数据</td></tr><tr><td align="center">redisTemplate</td><td align="center"></td><td align="center">通用命令</td></tr></tbody></table><p>SpringDataRedis 的使用步骤如下：</p><ul><li>引入 <code>spring-boot-starter-data-redis</code> 依赖</li><li>在 <code>application.yml</code> 中配置 Redis 信息</li><li>注入 <code>RedisTemplate </code></li></ul><h5 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h5><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Redis依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token comment">&lt;!-- 连接池依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-对-Redis-进行配置"><a href="#2-对-Redis-进行配置" class="headerlink" title="2. 对 Redis 进行配置"></a>2. 对 Redis 进行配置</h5><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">spring:  redis:    port: 6379 # 端口    host: 172.25.248.60 # 虚拟机地址    password: 123456 # 密码    lettuce:      pool:        max-wait: 200  # 等待时间        max-active: 8  # 最大连接数        max-idle: 8    # 最大空闲连接        min-idle: 0    # 最小空闲连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-注入-RedisTemplate"><a href="#3-注入-RedisTemplate" class="headerlink" title="3. 注入 RedisTemplate"></a>3. 注入 RedisTemplate</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Resourceprivate RedisTemplate redisTemplate;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="4-测试"><a href="#4-测试" class="headerlink" title="4. 测试"></a>4. 测试</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestpublic class SpringDataRedisTest {        @Resource    private RedisTemplate redisTemplate;    @Test    void testString(){        // 插入数据        redisTemplate.opsForValue().set("name","李四");        // 读取数据        Object name = redisTemplate.opsForValue().get("name");        System.out.println("name = " + name);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-SpringDataRedis-的序列化形式"><a href="#2-SpringDataRedis-的序列化形式" class="headerlink" title="2. SpringDataRedis 的序列化形式"></a>2. SpringDataRedis 的序列化形式</h3><p><code>RedisTemplate </code>可以接收任意 <code>Object </code>作为值写入 <code>Redis</code>，只不过写入前会把 <code>Object </code>序列化为 字节形式，默认是采用 <font color="red">JDK 序列化</font></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312040360.png" alt="image-20221201161846388"></p><p>缺点：</p><ul><li>可读性差</li><li>内存占用较大</li></ul><p>解决方法：<font color="red">自定义 RedisTemplate 序列化方式</font></p><ol><li>自定义 RedisTemplate</li><li>修改 RedisTemplate 的序列化器为 GenericJackson2JsonRedisSerializer</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">/**    * 自定义序列化方式    * */   @Bean   public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factoryon){       // 创建 Template       RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();       // 设置连接工厂       redisTemplate.setConnectionFactory(factoryon);       // 设置序列化工具       GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();       // key 和 hash key 采用 string 序列化       redisTemplate.setKeySerializer(RedisSerializer.string());       redisTemplate.setHashKeySerializer(RedisSerializer.string());       // value 和 hashValue 采用 JSON 序列化       redisTemplate.setValueSerializer(jsonRedisSerializer);       redisTemplate.setHashValueSerializer(jsonRedisSerializer);       return redisTemplate;   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Data@AllArgsConstructor@NoArgsConstructorpublic class User {    private String name;    private int age;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestpublic class SpringDataRedisTest {    @Autowired    private RedisTemplate redisTemplate;    @Test    void testUser(){        User user = new User("张三", 20);        //        redisTemplate.opsForValue().set("user:101", user);        //        Object object = redisTemplate.opsForValue().get("user:101");        System.out.println(object);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试效果：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312041243.png" alt="image-20221201163630093"></p><h4 id="3-2-3-StringRedisTemplate"><a href="#3-2-3-StringRedisTemplate" class="headerlink" title="3.2.3 StringRedisTemplate"></a>3.2.3 StringRedisTemplate</h4><p>上述自定义序列化方式中使用的 JSON 序列化方式，虽然可以满足需求，但仍存在一些问题：为了在反序列化时知道对象的类型，JSON 序列化器会将类的 class 类型写入 json 结果中，存入 Redis，会带来<font color="red">额外的内存开销</font></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312042279.png" alt="image-20221201164227016"></p><p>为了节省内存空间，不使用 JSON 序列化器来处理 value，而是统一使用 String 序列化器，要求只能存储 String 类型的 key 和 value。当需要存储 Java 对象时，手动完成对象的序列化和反序列化</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312042345.png" alt="image-20221201165453196"></p><p>Spring 默认提供了一个 StringRedisTemplate 类，其 key 和 value 的序列化方式默认就是 String 方式</p><p>使用步骤如下：</p><ol><li>使用 StringRedisTemplate</li><li>写入 Redis时，手动把对象序列化为 JSON</li><li>读取 Redis 时，手动把读取到的 JSON 反序列化为对象</li></ol><p>示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@SpringBootTestpublic class StringRedisTemplateTest {    @Autowired    private StringRedisTemplate stringRedisTemplate;    // JSON 工具    private static final ObjectMapper objectMapper = new ObjectMapper();    @Test    void testStringTemplate() throws JsonProcessingException {        // 准备对象        User user = new User("张三", 20);        // 手动序列化        String json = objectMapper.writeValueAsString(user);        // 写入一条数据到 redis        stringRedisTemplate.opsForValue().set("user:200", json);        // 读取数据        String value = stringRedisTemplate.opsForValue().get("user:200");        // 反序列化        User user1 = objectMapper.readValue(value, User.class);        System.out.println("user1 = " + user1);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312043076.png" alt="image-20221201171224124"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312042750.png" alt="image-20221201171209566"></p><blockquote><p> 可见内存大大减少了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/tur-study/2023/03/31/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/tur-study/2023/03/31/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="防火墙相关命令"><a href="#防火墙相关命令" class="headerlink" title="防火墙相关命令"></a>防火墙相关命令</h3><h4 id="1-查看防火墙状态"><a href="#1-查看防火墙状态" class="headerlink" title="1. 查看防火墙状态"></a>1. 查看防火墙状态</h4><pre class="line-numbers language-none"><code class="language-none">systemctl status firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>inactive(dead)：未启动</li><li>active（running）：已启动。字体呈现绿色</li></ul><h4 id="2-开启防火墙"><a href="#2-开启防火墙" class="headerlink" title="2. 开启防火墙"></a>2. 开启防火墙</h4><ul><li>开启防火墙</li></ul><pre class="line-numbers language-none"><code class="language-none">systemctl start firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>设置开机自启动</li></ul><pre class="line-numbers language-none"><code class="language-none">systemctl enable firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="3-开放或限制端口"><a href="#3-开放或限制端口" class="headerlink" title="3. 开放或限制端口"></a>3. 开放或限制端口</h4><h5 id="3-1-开放端口"><a href="#3-1-开放端口" class="headerlink" title="3.1 开放端口"></a>3.1 开放端口</h5><ol><li>开启指定端口</li></ol><pre class="line-numbers language-none"><code class="language-none">firewalld-cmd --zone=public --add-port=6379/tcp --permanent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>--permanent</code>：声明该设置永久有效。不加的话机器重启之后就失效了</p></blockquote><ol start="2"><li>重新载入防火墙设置，使设置生效</li></ol><pre class="line-numbers language-none"><code class="language-none">firewalld-cmd --reload<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>查看是否生效</li></ol><pre class="line-numbers language-none"><code class="language-none">fiewwalld-cmd --zone=publi --query-port=6379/tcp<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>输出yes：表示开启</li><li>输出no：表示未开启</li></ul><ol start="4"><li>查看当前系统打开的所有端口</li></ol><pre class="line-numbers language-none"><code class="language-none">firewalld-cmd --zone=public --list-ports<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>需要查询详细信息的的话，可以输入：<code>firewalld-cmd --list-all</code></p></blockquote><h5 id="3-2-限制端口"><a href="#3-2-限制端口" class="headerlink" title="3.2 限制端口"></a>3.2 限制端口</h5><ol><li>限制指定端口，将开放的命令的 add 更改为 remove</li></ol><pre class="line-numbers language-none"><code class="language-none">firewalld-cmd --zone=public --remove-port=6379/tcp --permanent<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>设置之后，记得重载，不然设置是没有效果的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 整合 Sa-Token 基础</title>
      <link href="/tur-study/2023/03/31/SpringBoot/Sa-Token%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/"/>
      <url>/tur-study/2023/03/31/SpringBoot/Sa-Token%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="一、SpringBoot-集成-Sa-Token-示例"><a href="#一、SpringBoot-集成-Sa-Token-示例" class="headerlink" title="一、SpringBoot 集成 Sa-Token 示例"></a>一、SpringBoot 集成 Sa-Token 示例</h2><ol><li>添加依赖</li></ol><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Sa-Token 权限认证，在线文档：https://sa-token.cc --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cn.dev33<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>sa-token-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>1.34.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>设置配置文件</li></ol><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">#=================== Sa-Token 配置 ========================sa-token:  # token名称，同时也是cookie名称  token-name: satoken  # token有效期，单位s，默认30天。-1代表永不过期  timeout: 2592000   # token临时有效期，指定时间内无操作就视为token过期，单位s  activity-timeout: -1  # 是否允许同一账号并发登录，true：允许一起登录。false：新登录挤掉旧登陆  is-concurrent: true  # 在多人登录同一账号时，是否共用一个token。true：所有登录共用一个token  is-share: true  # token风格  token-style: uuid  # 是否输出操作日志  is-log: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>创建测试 Controller</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@RestController@RequestMapping("/user/")public class UserController {    // 测试登录    @RequestMapping("doLogin")    public String doLogin(String username, String password) {        // 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对         if("zhang".equals(username) &amp;&amp; "123456".equals(password)) {            // 10001，仅代表用户id，需要以实际情况而定            StpUtil.login(10001);            return "登录成功";        }        return "登录失败";    }    // 查询登录状态    @RequestMapping("isLogin")    public String isLogin() {        return "当前会话是否登录：" + StpUtil.isLogin();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>测试：</li></ol><p>从浏览器一次访问上述测试接口：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303311524572.png"></p><hr><h2 id="二、登录认证"><a href="#二、登录认证" class="headerlink" title="二、登录认证"></a>二、登录认证</h2><h3 id="2-1-设计思路"><a href="#2-1-设计思路" class="headerlink" title="2.1 设计思路"></a>2.1 设计思路</h3><p>对于一些登陆之后才能访问的接口，如查询我的账号资料。通常的做法事增加一层接口校验</p><ul><li>如果校验通过，则：正常返回数据</li><li>若校验未通过，则：抛出异常，告知其需要先进行登录</li></ul><p>那么，判断会话是否登录的依据是什么？先来看看登录访问的流程：</p><p>登录访问的流程如下：</p><ol><li>用户提交 <code>name</code> + <code>password</code> 参数，调用登录接口</li><li>登陆成功，返回这个用户的 Token 会话凭证</li><li>用户后续的每次请求，都携带上这个 Token</li><li>服务器根据 Token 判断会话是否登陆成功</li></ol><p>所谓登录认证，指的就是服务器校验账号密码，为用户颁发Token 会凭证的过程，这个 Token 也是后续判断会话是否登录的关键所在</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303311541974.png"></p><h3 id="2-2-登录与注销"><a href="#2-2-登录与注销" class="headerlink" title="2.2 登录与注销"></a>2.2 登录与注销</h3><p>根据以上思路，Sa-Token 实现了一个会话登录函数：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 会话登录：参数填写要登录的账号id，建议数据类型：long | int | String，不可用传入复杂类型，如：User、Admin等等StpUtil.login(Object id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>基于上面这个函数，<code>Sa-Token 为要登录的账号创建了一个 Token 凭证，且通过 Cookie 上下文返回给了前端</code></p><p>Sa-Token 实现 <code>StpUtil.login(Object id)</code>，做了如下工作：</p><ol><li>检查此账号是否之前已有登录</li><li>为账号生成 <code>Token </code>凭证与 <code>Session </code>会话</li><li>通知全局侦听器，xx 账号登陆成功</li><li>将 <code>Token </code>注入到请求上下文</li><li>等等。。。</li></ol><p>基于 <code>StpUtil.login(Object id)</code>，一般登录接口代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 会话登录@RequestMapping("doLogin")public SaResult doLogin(String name, String pwd){    // 1. 比对前端提交的账号名称、密码    if("zhangsan".equals(name) &amp;&amp; "123456".equals(pwd)){        // 2. 根据账号id，进行登录        StpUtil.login(10001);        return SaResult.ok("登陆成功")；    }    return SaResult.error("登陆失败");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码实现中仅仅做了会话登录，而没有主动向前端返回 Token 信息。原因如下：<code>StpUtil.login(id)</code>利用了 Cookie 自动注入的特性，将原本需要返回的 Token 信息的代码，给省略了</p><blockquote><p>了解 Cookie 的两点基本功能：</p><ul><li>Cookie 可以从后端控制往浏览器中写入 Token 值</li><li>Cookie 会在前端每次发起请求时自动提交 Token 值</li></ul></blockquote><p>除了登录方法，Sa-Token 还实现了如下方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 当前会话注销登录StpUtil.logout();// 获取当前会话是否已经登录// true：已登录// false：未登录StpUtil.isLogin();// 校验当前会话是否已经登录，若未登录，抛出异常：NotLoginExceptionStpUtil.checkLogin();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>异常 <code>NotLoginException</code> 代表当前会话暂未登录，可能的原因有很多： 前端没有提交 Token、前端提交的 Token 是无效的、前端提交的 Token 已经过期 …… 等等</p></blockquote><h3 id="2-3-会话查询"><a href="#2-3-会话查询" class="headerlink" title="2.3 会话查询"></a>2.3 会话查询</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 获取当前会话账号id, 如果未登录，则抛出异常：`NotLoginException`StpUtil.getLoginId();// 类似查询API还有：StpUtil.getLoginIdAsString();    // 获取当前会话账号id, 并转化为`String`类型StpUtil.getLoginIdAsInt();       // 获取当前会话账号id, 并转化为`int`类型StpUtil.getLoginIdAsLong();      // 获取当前会话账号id, 并转化为`long`类型// ---------- 指定未登录情形下返回的默认值 ----------// 获取当前会话账号id, 如果未登录，则返回null StpUtil.getLoginIdDefaultNull();// 获取当前会话账号id, 如果未登录，则返回默认值 （`defaultValue`可以为任意类型）StpUtil.getLoginId(T defaultValue);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-Token-查询"><a href="#2-4-Token-查询" class="headerlink" title="2.4 Token 查询"></a>2.4 Token 查询</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 获取当前会话的token值StpUtil.getTokenValue();// 获取当前`StpLogic`的token名称StpUtil.getTokenName();// 获取指定token对应的账号id，如果未登录，则返回 nullStpUtil.getLoginIdByToken(String tokenValue);// 获取当前会话剩余有效期（单位：s，返回-1代表永久有效）StpUtil.getTokenTimeout();// 获取当前会话的token信息参数StpUtil.getTokenInfo();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">/** * 登录测试  */@RestController@RequestMapping("/acc/")public class LoginController {    // 测试登录    @RequestMapping("doLogin")    public SaResult doLogin(String name, String pwd) {        // 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对         if("zhang".equals(name) &amp;&amp; "123456".equals(pwd)) {            StpUtil.login(10001);            return SaResult.ok("登录成功");        }        return SaResult.error("登录失败");    }    // 查询登录状态    @RequestMapping("isLogin")    public SaResult isLogin() {        return SaResult.ok("是否登录：" + StpUtil.isLogin());    }    // 查询 Token 信息    @RequestMapping("tokenInfo")    public SaResult tokenInfo() {        return SaResult.data(StpUtil.getTokenInfo());    }    // 测试注销    @RequestMapping("logout")    public SaResult logout() {        StpUtil.logout();        return SaResult.ok();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、密码加密"><a href="#三、密码加密" class="headerlink" title="三、密码加密"></a>三、密码加密</h2>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Sa-token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础</title>
      <link href="/tur-study/2023/03/30/Redis/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/tur-study/2023/03/30/Redis/Redis%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="一、初识-Redis"><a href="#一、初识-Redis" class="headerlink" title="一、初识 Redis"></a>一、初识 Redis</h2><h3 id="1-1-NoSQL"><a href="#1-1-NoSQL" class="headerlink" title="1.1 NoSQL"></a>1.1 NoSQL</h3><blockquote><p>对比 SQL 与 NoSQL 的区别</p></blockquote><ul><li>SQL：关系型数据库</li><li>NoSQL：非关系型数据库</li></ul><h4 id="1-1-1-数据结构"><a href="#1-1-1-数据结构" class="headerlink" title="1. 1.1 数据结构"></a>1. 1.1 数据结构</h4><h5 id="1-SQL"><a href="#1-SQL" class="headerlink" title="1. SQL"></a>1. SQL</h5><ul><li>结构化（Structured）</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312030264.png" alt="image-20221129224752320"></p><h5 id="2-NoSQL"><a href="#2-NoSQL" class="headerlink" title="2. NoSQL"></a>2. NoSQL</h5><ul><li>非结构化</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312030531.png" alt="image-20221129225146820"></p><h4 id="1-1-2-数据关联"><a href="#1-1-2-数据关联" class="headerlink" title="1.1.2 数据关联"></a>1.1.2 数据关联</h4><h5 id="1-SQL-1"><a href="#1-SQL-1" class="headerlink" title="1. SQL"></a>1. SQL</h5><ul><li>关联的（Relational）</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312030421.png" alt="image-20221129225809198"></p><h5 id="2-NoSQL-1"><a href="#2-NoSQL-1" class="headerlink" title="2. NoSQL"></a>2. NoSQL</h5><ul><li>无关联的</li></ul><h4 id="1-1-3-查询方式"><a href="#1-1-3-查询方式" class="headerlink" title="1.1.3 查询方式"></a>1.1.3 查询方式</h4><h5 id="1-SQL-2"><a href="#1-SQL-2" class="headerlink" title="1. SQL"></a>1. SQL</h5><ul><li>SQL 查询</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312031329.png" alt="image-20221129225909052"></p><h5 id="2-NoSQL-2"><a href="#2-NoSQL-2" class="headerlink" title="2. NoSQL"></a>2. NoSQL</h5><ul><li>非 SQL</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312031303.png" alt="image-20221129225951166"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312031649.png" alt="image-20221129230007224"></p><h4 id="1-1-4-事务特性"><a href="#1-1-4-事务特性" class="headerlink" title="1.1.4 事务特性"></a>1.1.4 事务特性</h4><h5 id="1-SQL-3"><a href="#1-SQL-3" class="headerlink" title="1. SQL"></a>1. SQL</h5><ul><li>ACID</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312032750.png" alt="image-20221129230120185"></p><h5 id="2-NoSQL-3"><a href="#2-NoSQL-3" class="headerlink" title="2. NoSQL"></a>2. NoSQL</h5><ul><li>BASE</li></ul><blockquote><ul><li>键值类型（Redis）</li><li>文档类型（MongoDB）</li><li>列类型（HBase）</li><li>Graph 类型（Neo4j）</li></ul></blockquote><h3 id="1-2-Redis-简介"><a href="#1-2-Redis-简介" class="headerlink" title="1.2 Redis 简介"></a>1.2 Redis 简介</h3><p><code>Redis</code>（Remote Dictionary Server），远程词典服务器，是一个基于内存的键值型 NoSQL 数据库</p><p>特征：</p><ul><li>键值（<code>key-value</code>）型，value 支持多种不同数据结构，功能丰富</li><li>单线程，每个命令具备原子性</li><li>低延迟，速度快（基于内存、IO多路复用、良好的编码）</li><li>支持数据持久化</li><li>支持主从集群、分片集群</li><li>支持多语音客户端</li></ul><h2 id="二、Redis-常见命令"><a href="#二、Redis-常见命令" class="headerlink" title="二、Redis 常见命令"></a>二、Redis 常见命令</h2><h3 id="2-1-Redis-数据结构"><a href="#2-1-Redis-数据结构" class="headerlink" title="2.1 Redis 数据结构"></a>2.1 Redis 数据结构</h3><p><code>Redis </code>是一个<code>key-value</code>的数据库，<code>key </code>一般是 <code>String </code>类型，不过 <code>value </code>的类型多种多样</p><ul><li><p>String：如 “hello world”</p></li><li><p>Hash：{ name: “Jack”, age: 21 }</p></li><li><p>List：[ A -&gt; B -&gt; C -&gt; C ]</p></li><li><p>Set：{ A, B, C}</p></li><li><p>SortedSet：{ A: 1, B: 2, C: 3 }</p></li><li><p>GEO：{ A: (120.3, 30.5 ) }</p></li><li><p>BitMap：0110110101110101011</p></li><li><p>HyperLog：0110110101110101011</p></li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312033258.png" alt="image-20230329163417027"></p><p>Redis 将操作不同数据类型的命令做了分组，在官网（<a href="https://redis.io/commands%EF%BC%89%E5%8F%AF%E4%BB%A5%E6%9F%A5%E5%88%B0%E4%B8%8D%E5%90%8C%E5%91%BD%E4%BB%A4">https://redis.io/commands）可以查到不同命令</a></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312033087.png" alt="image-20221130095432799"></p><h3 id="2-2-Redis-通用命令"><a href="#2-2-Redis-通用命令" class="headerlink" title="2.2 Redis 通用命令"></a>2.2 Redis 通用命令</h3><p>通用指令是部分数据类型都可用使用的指令，常见的有：</p><ul><li><p><code>KEYS</code>：查看复合模板的所有 <code>key</code>，<font color="red">不建议在生产环境设备上使用</font></p></li><li><p><code>DEL</code>：删除一个指定的 <code>key</code></p></li><li><p><code>EXISTS</code>：判断 <code>key </code>是否存在</p></li><li><p><code>EXPIRE</code>：给一个 <code>key</code> 设置有效期，有效期到期时，该 <code>key </code>会被自动删除</p></li><li><p><code>TTL</code>：查看一个 <code>key </code>的剩余有效期</p></li><li></li></ul><blockquote><p>通过 <code>help [command]</code> 可以查看一个命令的具体用法</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312034035.png" alt="image-20221130101123021"></p></blockquote><h3 id="2-3-String-类型"><a href="#2-3-String-类型" class="headerlink" title="2.3 String 类型"></a>2.3 String 类型</h3><h4 id="2-3-1-String-类型的三种格式"><a href="#2-3-1-String-类型的三种格式" class="headerlink" title="2.3.1 String 类型的三种格式"></a>2.3.1 String 类型的三种格式</h4><p><code>String </code>类型，即字符串类型，是 <code>Redis </code>中最简单的存储类型，其 <code>value</code> 是字符串，不过根据字符串的格式不同，可以分为如下3类：</p><ul><li><code>string</code>：普通字符串</li><li><code>int</code>：整数类型，可以做自增、自减操作</li><li><code>float</code>：浮点类型，可以做自增、自减操作</li></ul><blockquote><p>不管是哪种格式，底层都是字节数组形式存储，只不过编码方式不同。字符串类型的最大空间不能超过 512m</p></blockquote><h4 id="2-3-2-String-类型的常见命令"><a href="#2-3-2-String-类型的常见命令" class="headerlink" title="2.3.2 String 类型的常见命令"></a>2.3.2 String 类型的常见命令</h4><p><code>String </code>的常见命令有：</p><ul><li><code>SET</code>：添加或者修改已经存在的一个 String 类型的键值对</li><li><code>GET</code>：根据 key 获取 String 类型的 value</li><li><code>MSET</code>：批量添加多个 String 类型的键值对</li><li><code>MGET</code>：根据多个 key 获取多个 String 类型的 value</li><li><code>INCR</code>：让一个整型的 key 自增1</li><li><code>INCRBY</code>：让一个整型的 key 自增并指定步长。例如：incrby num 2 让 num 值自增 2</li><li><code>INCRBYFLOAT</code>：让一个浮点类型的数字自增并指定步长</li><li><code>SETNX</code>：添加一个 String 类型的键值对，前提是这个 key 不存在，否则不执行</li><li><code>SETEX</code>：添加一个 String 类型的键值对，并且指定有效期</li></ul><h4 id="2-3-3-key的结构"><a href="#2-3-3-key的结构" class="headerlink" title="2.3.3 key的结构"></a>2.3.3 key的结构</h4><blockquote><p>问题：如何区分不同类型的 key。例如：需要存储用户、商品信息到redis，有一个用户id是1，有一个商品id恰好也是1</p></blockquote><p><code>Redis </code>的 <code>key </code>允许有多个单词形成层级结构，多个单词之间用 <code>: </code>隔开，格式如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312034365.png" alt="image-20221130150154494"></p><blockquote><p>格式并非固定，可以根据需求来删除或添加词条</p></blockquote><p>示例如下：</p><p>项目名称：hotel，有 user 和 product 两种不同类型的数据，定义 key 如下：</p><ul><li>user 相关的 key：hotel:user:1</li><li>product 相关的 key：hotel:product:1</li></ul><p>若 Value 是一个 Java 对象，如一个 User 对象，则可由将对象序列化为 JSON 字符串后存储</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312034736.png" alt="image-20221130185855534"></p><h3 id="2-4-Hash-类型"><a href="#2-4-Hash-类型" class="headerlink" title="2.4 Hash 类型"></a>2.4 Hash 类型</h3><h4 id="2-4-1-Hash-结构"><a href="#2-4-1-Hash-结构" class="headerlink" title="2.4.1 Hash 结构"></a>2.4.1 Hash 结构</h4><p>Hash 类型，也叫散列，其 value 是一个无序字典，类似于 Java 中的 HashMap 结构</p><blockquote><p>问题：String 结构是将对象序列化为 JSON 字符串后存储，当需要修改对象的某个字段时很不方便：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312035565.png" alt="image-20221130190238185"></p></blockquote><p>Hash 结构可以将对象中的的每个字段独立存储，可以针对单个字段做 CRUD</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312035131.png" alt="image-20221130191443785"></p><h4 id="2-4-2-Hash-类型常用命令"><a href="#2-4-2-Hash-类型常用命令" class="headerlink" title="2.4.2 Hash 类型常用命令"></a>2.4.2 Hash 类型常用命令</h4><p><code>Hash </code>的常见命令有：</p><ul><li><code>HSET key field value</code>：添加或者修改 hash 类型 key 的 field 的值</li><li><code>HGET key field</code>：获取一个 hash 类型 key field 的值</li><li><code>HMSET</code>：批量添加多个 hash类型 key 的 field 的值</li><li><code>HMGET</code>：批量获取多个 hash 类型 key 的 field 的值</li><li><code>HGETALL</code>：获取一个 hash 类型的 key 中的所有的 field 和 value</li><li><code>HKEYS</code>：获取一个 hash 类型的 key 中的所有的 field</li><li><code>HVALS</code>：获取一个 hash 类型的 key 中的所有的 value</li><li><code>HINCRBY</code>：让一个 hash 类型 key 的字段值自增并指定步长</li><li><code>HSETNX</code>：添加一个 hash 类型的 key 的 field 值，前提是这个 field 不存在，否则不执行</li></ul><h3 id="2-5-List-类型"><a href="#2-5-List-类型" class="headerlink" title="2.5 List 类型"></a>2.5 List 类型</h3><h4 id="2-5-1-List-类型简介"><a href="#2-5-1-List-类型简介" class="headerlink" title="2.5.1 List 类型简介"></a>2.5.1 List 类型简介</h4><p>Redis 中的 <code>List </code>类型与 Java 中的 <code>LinkedList </code>类似，可以看做是一个<font color="red">双向链表结构</font>，即支持正向检索也支持方向检索</p><p><code>List </code>类型的特征也与 <code>LinkedList </code>类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个<font color="red">有序数据</font>，例如：朋友圈点赞列表，评论列表</p><h4 id="2-5-2-List-类型的常见命令"><a href="#2-5-2-List-类型的常见命令" class="headerlink" title="2.5.2 List 类型的常见命令"></a>2.5.2 List 类型的常见命令</h4><ul><li><code>lpush key element … </code>：项列表左侧插入一个或多个元素</li><li><code>lpop key</code>：移除并返回列表左侧的第一个元素，没有则返回 nil</li><li><code>rpush key elemnt … </code>： 项列表右侧插入一个或多个元素</li><li><code>rpop key</code>：移除并返回列表右侧的第一个元素</li><li><code>lrange key star end</code>：返回一段角标范围内的所有元素</li><li><code>blpop 和 brpop</code>：与 lpop 和 rpop 类似，只不过在没有元素时等待指定时间，而不是直接返回 nil</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312036626.png" alt="image-20221130200304385"></p><blockquote><ol><li>如何利用 List 结构模拟一个栈：<ul><li>入口和出口在同一边</li></ul></li><li>如何利用 List 结构模拟一个队列：<ul><li>入口和出口不在同一边</li></ul></li><li>如何利用 List 结构模拟一个阻塞队列：<ul><li>入口和出口在不同边</li><li>出队时 <code>BLPOP </code>或 <code>BRPOP</code></li></ul></li></ol></blockquote><h3 id="2-6-Set-类型"><a href="#2-6-Set-类型" class="headerlink" title="2.6 Set 类型"></a>2.6 Set 类型</h3><h4 id="2-6-1-Set-结构"><a href="#2-6-1-Set-结构" class="headerlink" title="2.6.1 Set 结构"></a>2.6.1 Set 结构</h4><p>Redis 的 Set 结构与 Java 中的 HashSet 类似，可以看做是一个 value 为 null 的 HashMap</p><p>具备与 Hash Set 类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查找快</li><li>支持交集、并集、差集等功能</li></ul><h4 id="2-6-2-Set-的常见命令"><a href="#2-6-2-Set-的常见命令" class="headerlink" title="2.6.2 Set 的常见命令"></a>2.6.2 Set 的常见命令</h4><ul><li><code>sadd key member …</code> ： 向 set 中添加一个或多个元素</li><li><code>srem key member …</code> ：移除 set 中的指定元素</li><li><code>scard key</code>：返回 se 中元素的个数</li><li><code>sismember key member</code>：判断一个元素是否存在于 set 中</li><li><code>smembers</code>：获取 set 中的所有元素</li><li><code>sinter key1 key2 …</code> ： 求 key1 和 key2 的交集</li><li><code>sdiff key1 key2 … </code>：求 key1 和 key2 的差集</li><li><code>sunion key1 ke2 … </code>：求 key1 和 key2 的并集</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312036207.png" alt="image-20221130210806789"></p><h3 id="2-7-SortedSet-类型"><a href="#2-7-SortedSet-类型" class="headerlink" title="2.7 SortedSet 类型"></a>2.7 SortedSet 类型</h3><h4 id="2-7-1-SortedSet-类型"><a href="#2-7-1-SortedSet-类型" class="headerlink" title="2.7.1 SortedSet 类型"></a>2.7.1 SortedSet 类型</h4><p>Redis 的 SortedSet 是一个可排序的 set 集合，与 Java 中的 TreeSet 有些类似，但底层数据结构差别很大</p><p>SortedSet 中的每个元素都带有一个 score 属性，可以基于 score 属性对元素进行排序，底层的实现是一个跳表（SkipList）加 hash 表</p><p>SortedSet 具备以下特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><blockquote><p>因为 SortedSet 的可排序特性，经常被用来实现排行榜这样的功能</p></blockquote><h4 id="2-7-2-SortedSet-的常见命令"><a href="#2-7-2-SortedSet-的常见命令" class="headerlink" title="2.7.2 SortedSet 的常见命令"></a>2.7.2 SortedSet 的常见命令</h4><ul><li><code>zadd key score member</code>：添加一个或多个元素到 sorted set， 若已经存在则更新其 score 值</li><li><code>zrem key member </code>：删除 sorted set 中的一个指定元素</li><li><code>zscore key member</code>：获取 sorted set 中的指定元素的 score 值</li><li><code>zrank key member</code>：获取 sorted set 中指定元素的排名</li><li><code>zcard key</code>：获取 sorted set 的元素个数</li><li><code>zcount key min max</code>：统计 score 值在给定范围内的所有元素的个数</li><li><code>zincrby key increment member</code>：让 sorted set 中的指定元素自增，步长为指定的 increment 值</li><li><code>zrange key min max</code>：按照 score 排序后，获取指定排名范围内的元素，这是个左开右闭的区间</li><li><code>zrangebyscore key min max</code>：按照 score 排序后，获取指定 score 范围内的元素</li><li><code>zdiff、zinter、zunion</code>：求差集、交集、并集</li></ul><blockquote><p>==注意：==所有的排名都是默认升序，若需要降序则在命令的 Z 后面添加 rev 即可</p></blockquote><h2 id="三、Redis-的-Java-客户端"><a href="#三、Redis-的-Java-客户端" class="headerlink" title="三、Redis 的 Java 客户端"></a>三、Redis 的 Java 客户端</h2><p>在Redis官网中提供了各种语言的客户端，地址：<a href="https://redis.io/clients">https://redis.io/clients</a></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312037116.png" alt="image-20221201095200934"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312037112.png" alt="image-20221201095300937"></p><h3 id="3-1-Jedis"><a href="#3-1-Jedis" class="headerlink" title="3.1 Jedis"></a>3.1 Jedis</h3><blockquote><p>jedis 官网地址：<a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p></blockquote><h4 id="3-1-1-Jedis-的基本使用"><a href="#3-1-1-Jedis-的基本使用" class="headerlink" title="3.1.1 Jedis 的基本使用"></a>3.1.1 Jedis 的基本使用</h4><p>Jedis 的使用步骤如下：</p><ul><li>引入依赖</li><li>创建 Jedis 对象，建立连接</li><li>使用 Jedis，方法名与 Redis 命令一致</li><li>释放资源</li></ul><p>具体如下：</p><ol><li><p>引入依赖：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- redis 依赖 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>建立连接：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.junit.jupiter.api.BeforeEach;import redis.clients.jedis.Jedis;public class RedisTest {    private Jedis jedis;    /**     * 建立连接     * */    @BeforeEach    public void setUp(){        // 建立连接        jedis = new Jedis("127.0.0.1", 6379);        // 设置密码        jedis.auth("123456");        // 选择库        jedis.select(0);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>测试 String</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.junit.jupiter.api.Test;....public class RedisTest {    ...    /**     * 测试 String     * */    @Test    void testString(){        // 插入数据，方法名称即redis命令的名称        String result = jedis.set("name", "张三");        System.out.println("result = " + result);        // 获取数据        String name = jedis.get("name");        System.out.println("name = " + name);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>释放资源：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import org.junit.jupiter.api.AfterEach;public class RedisTest {...    /**     * 释放资源     * */    @AfterEach    public void tearDown(){        // 释放资源        if(jedis != null){            jedis.close();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img202303312038309.png" alt="image-20221201100027562"></p><h4 id="3-1-2-Jedis-连接池"><a href="#3-1-2-Jedis-连接池" class="headerlink" title="3.1.2 Jedis 连接池"></a>3.1.2 Jedis 连接池</h4><p>Jedis 本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此推荐使用 Jedis 连接池代替 Jedis 的直连方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class JedisConnectionFactory {    private static final JedisPool jedisPool;        static {        JedisPoolConfig jedisPoolConfig = new JedisPoolConfig();        // 最大连接数        jedisPoolConfig.setMaxTotal(8);        // 最大空闲连接        jedisPoolConfig.setMaxIdle(8);        // 最小空闲连接        jedisPoolConfig.setMinIdle(0);        // 设置最长等待时间，ms        jedisPoolConfig.setMaxWaitMillis(200);        jedisPool = new JedisPool(jedisPoolConfig, "127.0.0.1", 6379, 1000, "123456");    }    /**     * 获取Jedis对象     * */    public static Jedis getJedis() {        return jedisPool.getResource();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的一些使用技巧</title>
      <link href="/tur-study/2023/03/29/MySQL/MySQL%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/tur-study/2023/03/29/MySQL/MySQL%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="1-获取指定id的上一个数据或下一个数据"><a href="#1-获取指定id的上一个数据或下一个数据" class="headerlink" title="1. 获取指定id的上一个数据或下一个数据"></a>1. 获取指定id的上一个数据或下一个数据</h3><p>示例如下：</p><ul><li>获取上一个数据</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from blog_article where id &lt; 123 order by id desc limit 1                                                 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体实现思想如下：</p><p>将表中数据进行倒序排列即 <code>desc</code>，选择 <code>id </code>小于指定值的数据即 <code>id $lt; 123</code>，并指定输出数据为1即 <code>limit 1</code></p><blockquote><p><code>$lt;</code> 代表小于号<code> &lt;</code></p></blockquote><ul><li>获取上一个数据</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from blog_article where id &gt; 123 order by id asc limit 1    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>具体实现思想如下：</p><p>将表中数据进行正序排列即 <code>asc</code>，选择 <code>id </code>大于指定值的数据即 <code>id $gt; 123</code>，并指定输出数据为1即 <code>limit 1</code></p><blockquote><p><code>$gt;</code> 代表小于号 <code>&gt;</code></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interceptor 拦截器的使用</title>
      <link href="/tur-study/2023/03/28/SpringBoot/Interceptor%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/03/28/SpringBoot/Interceptor%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/mathison-tur/blog_img/raw/master/md_img/image-20221129224752320.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Validated 参数校验</title>
      <link href="/tur-study/2023/03/28/SpringBoot/Valited%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
      <url>/tur-study/2023/03/28/SpringBoot/Valited%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="常用的校验注解"><a href="#常用的校验注解" class="headerlink" title="常用的校验注解"></a>常用的校验注解</h2><ul><li><code>@Null</code>限制只能为null</li><li><code>@NotNull</code>限制必须不能为null</li><li><code>@AssertTrue</code>限制必须为true</li><li><code>@AssertFalse</code>限制必须为false</li><li><code>@Min(value)</code>限制必须为一个不小于指定值的数字</li><li><code>@Max(value)</code>限制必须为一个不大于指定值的数字</li><li><code>@DecimalMin(value)</code>被限制的元素必须是一个数字，其值必须大于等于指定的最小值</li><li><code>@DecimalMax(value)</code>被限制的元素必须是一个数字，其值必须小于等于指定的最大值</li><li><code>@Size(max,min)</code>限制字符长度必须在min到max的指定范围内</li><li><code>@Digits(integer,fraction)</code>限制必须为一个小数，且整数部分的位数不能超过integer、小数部分的位数不能超过fraction的在可接受的范围内</li><li><code>@Past</code>被限制的元素(日期类型)必须是一个过去的日期</li><li><code>@Future</code>被限制的元素(日期类型)必须是一个将来的日期</li><li><code>@Pattern(value)</code>限制必须符合指定的正则表达式</li><li><code>@Email</code>被限制的元素值为是电子邮件地址，也可以通过正则表达式和flag指定自定义的email</li><li><code>@Length</code>被限制的字符串的大小必须在指定的范围内</li><li><code>@NotEmpty</code>被限制的字符串必须非空(不为null且不为空)</li><li><code>@Range</code>被限制的元素必须在合适的范围内</li></ul><h2 id="NotNull、-NotBlank、-NotEmpty-的区别"><a href="#NotNull、-NotBlank、-NotEmpty-的区别" class="headerlink" title="@NotNull、@NotBlank、@NotEmpty 的区别"></a>@NotNull、@NotBlank、@NotEmpty 的区别</h2><h3 id="NotNull"><a href="#NotNull" class="headerlink" title="@NotNull"></a>@NotNull</h3><p>不能为 null，但可以为 empty，一般用在 Integer 类型的基本数据类型的非空校验上，而且被其标注的字段可以使用 <code>@Size</code>、<code>@Max</code>、<code>@Min</code> 对字段数值进行大小的控制</p><h3 id="NotEmpty"><a href="#NotEmpty" class="headerlink" title="@NotEmpty"></a>@NotEmpty</h3><p>不能为 null，且长度必须大于 0，一般用在集合类上或者数组上</p><h3 id="NotBlank"><a href="#NotBlank" class="headerlink" title="@NotBlank"></a>@NotBlank</h3><p>只能作用在接收的 String 类型，注意是只能，不能为 null，而且调用 <code>trim()</code> 后，长度必须大于 0。即必须要有实际字符</p><blockquote><p>==注意：==</p><ul><li>注意在使用 <code>@NotBlank</code> 等注解时，一定要和 <code>@valid </code>一起使用，否则 <code>@NotBlank</code> 不起作用。</li><li>一个 <code>BigDecimal </code>的字段使用字段校验标签应该为 <code>@NotNull</code>。</li><li>在使用 <code>@Length</code> 一般用在 String 类型上可对字段数值进行最大长度限制的控制。</li><li>在使用 <code>@Range</code> 一般用在 Integer 类型上可对字段数值进行大小范围的控制。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Filter 过滤器的使用</title>
      <link href="/tur-study/2023/03/28/SpringBoot/Filter%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/03/28/SpringBoot/Filter%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h3><p><code>SpringBoot </code>的过滤器，在 <code>web </code>开发中可以过滤指定的 <code>url</code>，如过滤掉不需要的接口请求，同时也可以修改 <code>request </code>和 <code>response </code>内容</p><p>过滤器的应用场景：</p><ul><li>过滤敏感词汇（防止sql注入）</li><li>设置字符编码</li><li>URL级别的权限访问控制</li><li>压缩相应信息</li></ul><h3 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h3><p>实现方式有以下两种：</p><ol><li>使用<code> spring boot</code> 提供的 <code>FilterRegistrationBean </code>注册 <code>Filter</code></li><li>使用原生 <code>servlet </code>注解定义 <code>Filter</code></li></ol><blockquote><p>两种方式的本质都是一样的，都是去FilterRegistrationBean 注册自定义 Filter</p></blockquote><h4 id="2-1-使用-SpringBoot-提供的-FIlterRegitrationBean-注册-Filter"><a href="#2-1-使用-SpringBoot-提供的-FIlterRegitrationBean-注册-Filter" class="headerlink" title="2.1 使用 SpringBoot 提供的 FIlterRegitrationBean 注册 Filter"></a>2.1 使用 SpringBoot 提供的 FIlterRegitrationBean 注册 Filter</h4><ol><li>定义 Filter</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">import lombok.extern.slf4j.Slf4j;import javax.servlet.*;import javax.servlet.FilterConfig;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;@Slf4jpublic class MyCorsFilter implements Filter {    // 令牌    static final String TOKEN = "1234567890";    // 内部接口    public static List&lt;String&gt; INSIDE_URLS = List.of("/web/article/list", "/web//article/condition");    // 白名单    public static List&lt;String&gt; WHITE_PATH = List.of("/white", "/login");    /**     * 核心过滤方法     * */    @Override    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {        // doFilter 方法中的 request 和 response 需要转换为对应的 HttpServletRequest 和 HttpServletResponse 方便调用某些方法        HttpServletRequest request = (HttpServletRequest) servletRequest;        HttpServletResponse response = (HttpServletResponse) servletResponse;        String ip = request.getRemoteAddr();        String requestURI = request.getRequestURI();        log.info("ip = {}, requestURI = {}", ip, requestURI);        if (INSIDE_URLS.contains(requestURI)){            // 内部接口，直接通过            filterChain.doFilter(servletRequest, servletResponse);            return;        }        if (WHITE_PATH.contains(requestURI)){            // 白名单接口，直接通过            filterChain.doFilter(servletRequest, servletResponse);            return;        }        String token = request.getHeader("token");        if (TOKEN.equals(token)){            // 令牌校验通过，允许接口通过            filterChain.doFilter(servletRequest, servletResponse);        }else {            // 令牌校验不通过，重定向到登陆界面        }    }    /**     * 初始化     * */    public void init(FilterConfig filterConfig) {}    /**     * 销毁方法     * */    public void destroy() {}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>注册自定义Filter过滤器配置类</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class FilterConfig {    /**     * 基础过滤器     * */    @Bean    public FilterRegistrationBean&lt;Filter&gt; baseFilter(){        FilterRegistrationBean&lt;Filter&gt; filterRegistrationBean = new FilterRegistrationBean&lt;&gt;();        filterRegistrationBean.setFilter(new MyCorsFilter());        filterRegistrationBean.setUrlPatterns(List.of("/*"));        filterRegistrationBean.setOrder(1);        return filterRegistrationBean;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试可以发现白名单和内部接口可以通过，而不在这两个范围内的接口若令牌token不对应，则不能通过</p><h3 id="3-跨域请求的实现"><a href="#3-跨域请求的实现" class="headerlink" title="3. 跨域请求的实现"></a>3. 跨域请求的实现</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Componentpublic class MyCorsFilter implements Filter {    public void doFilter(ServletRequest req, ServletResponse res,                         FilterChain chain) throws IOException, ServletException {        HttpServletResponse response = (HttpServletResponse) res;        response.setHeader("Access-Control-Allow-Origin", "*");        response.setHeader("Access-Control-Allow-Credentials", "true");        response.setHeader("Access-Control-Allow-Methods", "*");        response.setHeader("Access-Control-Allow-Headers", "Content-Type,Access-Token,Authorization");        response.setHeader("Access-Control-Expose-Headers", "*");        response.setHeader("Access-Control-Max-Age", "3600");        chain.doFilter(req, res);    }    public void init(FilterConfig filterConfig) {}    public void destroy() {}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在接口分组添加<code> @CrossOrigin</code>注解可以实现该接口分组的所有接口允许跨域请求</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis Plus 分页插件的使用</title>
      <link href="/tur-study/2023/03/28/MybatisPlus/Mybatis%20Plus%20%E4%B8%AD%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/03/28/MybatisPlus/Mybatis%20Plus%20%E4%B8%AD%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>官网：<a href="https://baomidou.com/">https://baomidou.com/</a></p></blockquote><p>Spring Boot 中的使用步骤如下：</p><h3 id="1-分页配置"><a href="#1-分页配置" class="headerlink" title="1. 分页配置"></a>1. 分页配置</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Configurationpublic class MybatisPlusConfig{        @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor(){        // 1. 创建 MybatisPlusInterceptor 拦截器对象        MybatisPlusInterceptor mpInterceptor = new MybatisPlusInterceptor();        // 2. 添加分页拦截器，并声明使用的数据库类型        mpInterceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));        return mpInterceptor;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-使用官方已实现的接口实现分页"><a href="#2-使用官方已实现的接口实现分页" class="headerlink" title="2 使用官方已实现的接口实现分页"></a>2 使用官方已实现的接口实现分页</h3><blockquote><p>Service CRUD 接口</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java">// 无条件分页查询IPage&lt;T&gt; page(IPage&lt;T&gt; page);// 条件分页查询IPage&lt;T&gt; page(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper);// 无条件分页查询IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page);// 条件分页查询IPage&lt;Map&lt;String, Object&gt;&gt; pageMaps(IPage&lt;T&gt; page, Wrapper&lt;T&gt; queryWrapper);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参数说明</strong></p><table><thead><tr><th align="center">类型</th><th align="center">参数名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IPage<t></t></td><td align="center">page</td><td align="center">翻页对象</td></tr><tr><td align="center">Wrapper<t></t></td><td align="center">queryWrapper</td><td align="center">实体对象封装操作类 QueryWrapper</td></tr></tbody></table><h3 id="3-自定义-mapper-method-使用分页"><a href="#3-自定义-mapper-method-使用分页" class="headerlink" title="3. 自定义 mapper # method 使用分页"></a>3. 自定义 mapper # method 使用分页</h3><p>示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">IPage&lt;UserVo&gt; selectPageVo(IPage&lt;?&gt; page, Integer state);// or (class MyPage extends Ipage&lt;UserVo&gt;{ private Integer state; })MyPage selectPageVo(MyPage page);// orList&lt;UserVo&gt; selectPageVo(IPage&lt;UserVo&gt; page, Integer state);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectPageVo<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>xxx.xxx.xxx.UserVo<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    SELECT id,name FROM user WHERE state=#{state}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><ul><li>如果返回类型是 IPage 则入参的 IPage 不能为null,因为 返回的IPage == 入参的IPage; 如果想临时不分页,可以在初始化IPage时size参数传 &lt;0 的值;</li><li>如果返回类型是 List 则入参的 IPage 可以为 null(为 null 则不分页),但需要你手动 入参的IPage.setRecords(返回的 List);</li><li>如果 xml 需要从 page 里取值,需要 <code>page.属性</code> 获取</li></ul></blockquote><h3 id="4-Page-类"><a href="#4-Page-类" class="headerlink" title="4. Page 类"></a>4. Page 类</h3><p>该类继承了 <code>IPage</code> 类，实现了 <code>简单分页模型</code> 如果要实现自己的分页模型可以继承 <code>Page</code> 类或者实现 <code>IPage</code> 类</p><table><thead><tr><th align="center">属性名</th><th align="center">类型</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">records</td><td align="center">List</td><td align="center">emptyList</td><td align="center">查询数据列表</td></tr><tr><td align="center">total</td><td align="center">Long</td><td align="center">0</td><td align="center">查询列表总记录数</td></tr><tr><td align="center">size</td><td align="center">Long</td><td align="center">10</td><td align="center">每页显示条数，默认 <code>10</code></td></tr><tr><td align="center">current</td><td align="center">Long</td><td align="center">1</td><td align="center">当前页</td></tr><tr><td align="center">orders</td><td align="center">List</td><td align="center">emptyList</td><td align="center">排序字段信息，允许前端传入的时候，注意 SQL 注入问题，可以使用 <code>SqlInjectionUtils.check(...)</code> 检查文本</td></tr><tr><td align="center">optimizeCountSql</td><td align="center">boolean</td><td align="center">true</td><td align="center">自动优化 COUNT SQL 如果遇到 <code>jSqlParser</code> 无法解析情况，设置该参数为 <code>false</code></td></tr><tr><td align="center">optimizeJoinOfCountSql</td><td align="center">boolean</td><td align="center">true</td><td align="center">自动优化 COUNT SQL 是否把 join 查询部分移除</td></tr><tr><td align="center">searchCount</td><td align="center">boolean</td><td align="center">true</td><td align="center">是否进行 count 查询，如果指向查询到列表不要查询总记录数，设置该参数为 <code>false</code></td></tr><tr><td align="center">maxLimit</td><td align="center">Long</td><td align="center"></td><td align="center">单页分页条数限制</td></tr><tr><td align="center">countId</td><td align="center">String</td><td align="center"></td><td align="center"><code>xml</code> 自定义 <code>count</code> 查询的 <code>statementId</code></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Knife4j配置与使用(OpenAPI2)</title>
      <link href="/tur-study/2023/03/27/SpringBoot/Knife4j%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/tur-study/2023/03/27/SpringBoot/Knife4j%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h3><p>maven 坐标如下</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.xiaoymin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>knife4j-openapi2-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 具体版本自行选择 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Spring Boot 版本建议在 2.4.0 ~ 3.0.0 之间</p></blockquote><h3 id="2-配置-yml-属性"><a href="#2-配置-yml-属性" class="headerlink" title="2. 配置 yml 属性"></a>2. 配置 yml 属性</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">knife4j:  enable: true  openapi:    title: 这是文档标题 # 文档标题    description: 这是简介 # 简介    email: 123456789@qq.com # 创建人邮件    concat: tur # 创建者    url: https://docs.xiaominfo.com # 项目文档地址    version: v4.0 # 版本    license: Apache 2.0 # 许可证    license-url: https://stackoverflow.com/ # 许可证地址    terms-of-service-url: https://stackoverflow.com/    group: # 分组      test1: # 组名，用以区分其他组        group-name: 分组名称 # 组别名称        api-rule: package # api扫描方式        api-rule-resources: # 指定扫描的位置          - com.knife4j.demo.new3 # 存放接口、对象的包<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>访问 Knife4j 的文档地址：<code>http://ip:sort/doc.html</code></p><h3 id="3-Java注解"><a href="#3-Java注解" class="headerlink" title="3. Java注解"></a>3. Java注解</h3><h5 id="1-Api：定义接口分组名称"><a href="#1-Api：定义接口分组名称" class="headerlink" title="1. @Api：定义接口分组名称"></a>1. <code>@Api</code>：定义接口分组名称</h5><p>参数说明：</p><ul><li><code>tags</code>:说明该类的作用，可以在 UI 界面上看到的注解</li><li><code>value</code>：一般会自动获取接口分组的名称，可以不用设置</li></ul><h5 id="2-ApiImplicitParam：单个参数注释"><a href="#2-ApiImplicitParam：单个参数注释" class="headerlink" title="2. @ApiImplicitParam：单个参数注释"></a>2. <code>@ApiImplicitParam</code>：单个参数注释</h5><p>用在 <code>@ApiImplicitParams</code> 中，指定一个请求参数的各个方面</p><ul><li><code>name</code>：参数名</li><li><code>value</code>：参数说明</li><li><code>required</code>：参数时是否必须传</li><li><code>paramType</code>：参数位置，有以下可选值<ul><li><code>header</code>：请求头 <code>@RequestHeader</code></li><li><code>query</code>：?param=value格式 <code>@RequestParam</code></li><li><code>path</code>：路径，Restful风格接口 <code>@PathVariable</code></li><li><code>body</code>：请求体</li><li><code>form</code>：以form表单的形式提交</li></ul></li><li><code>dataType</code>：参数类型，默认 String，其他值为 Integer</li><li><code>defaultValue</code>：参数的默认值</li></ul><h5 id="3-ApiImplicitParams：多个参数注释"><a href="#3-ApiImplicitParams：多个参数注释" class="headerlink" title="3. @ApiImplicitParams：多个参数注释"></a>3. <code>@ApiImplicitParams</code>：多个参数注释</h5><p>用在请求方法上，表示一组参数的说明</p><h5 id="4-ApiModel：实体类定义"><a href="#4-ApiModel：实体类定义" class="headerlink" title="4. @ApiModel：实体类定义"></a>4. <code>@ApiModel</code>：实体类定义</h5><h5 id="5-ApiModelProperty：实体属性定义"><a href="#5-ApiModelProperty：实体属性定义" class="headerlink" title="5. @ApiModelProperty：实体属性定义"></a>5. <code>@ApiModelProperty</code>：实体属性定义</h5><ul><li><code>value</code>：字段说明</li><li><code>name</code>：属性名</li><li><code>dataType</code>：属性类型</li><li><code>required</code>：是否必填</li><li><code>example</code>：举例说明</li><li><code>hidden</code>：隐藏</li></ul><h5 id="6-ApiOperation：接口定义"><a href="#6-ApiOperation：接口定义" class="headerlink" title="6. @ApiOperation：接口定义"></a>6. <code>@ApiOperation</code>：接口定义</h5><ul><li><code>value</code>：接口说明</li><li><code>httpMethod</code>：接口请求方式</li><li><code>response</code>：接口返回参数类型</li><li><code>notes</code>：接口发布说明</li></ul><h5 id="7-ApiParam：参数注释"><a href="#7-ApiParam：参数注释" class="headerlink" title="7. @ApiParam：参数注释"></a>7. <code>@ApiParam</code>：参数注释</h5><h5 id="8-ApiResponse：响应码"><a href="#8-ApiResponse：响应码" class="headerlink" title="8. @ApiResponse：响应码"></a>8. <code>@ApiResponse</code>：响应码</h5><p>用在 <code>@ApiResponses</code> 中，一般用于表达一个错误或正确的响应信息</p><ul><li><code>code</code>：响应码</li><li><code>message</code>：响应信息</li><li><code>resposne</code>：抛出异常类</li></ul><h5 id="9-ApiResponses：多个响应码"><a href="#9-ApiResponses：多个响应码" class="headerlink" title="9. @ApiResponses：多个响应码"></a>9. <code>@ApiResponses</code>：多个响应码</h5><p>用在请求的方法上，表示一组响应</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis中select传递多个参数</title>
      <link href="/tur-study/2023/03/27/MybatisPlus/Mybatis%E4%B8%ADselect%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/"/>
      <url>/tur-study/2023/03/27/MybatisPlus/Mybatis%E4%B8%ADselect%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="1-单个参数"><a href="#1-单个参数" class="headerlink" title="1. 单个参数"></a>1. 单个参数</h3><p>传递单个参数时，方法名中的参数和 sql 语句中的参数名一致</p><p>如下：方法参数为 id，sql 中的参数也为 id</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// XXMapper.javapublic List&lt;XXBean&gt; getXXBeanList(Long id);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- XXMapper.xml --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getXXXBeanList<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>java.lang.Long<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>XXBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>　　select t.* from tableName t where t.id= #{id}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-多参数"><a href="#2-多参数" class="headerlink" title="2. 多参数"></a>2. 多参数</h3><p>多参数传递时不能使用 <code>parameterType</code>，除非所有参数的类型都一致，改用<code>#{index}</code>，是第几个就用第几个的索引，索引从<code>0</code>开始</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">// XXMapper.javapublic List&lt;XXBean&gt; getXXBeanList(Long id, String name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- XXMapper.xml --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getXXXBeanList<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>XXBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>　　select * from tableName t where id=#{0} and name=#{1}  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Map封装多参数"><a href="#3-Map封装多参数" class="headerlink" title="3. Map封装多参数"></a>3. Map封装多参数</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// XXMapper.javapublic List&lt;XXBean&gt; getXXBeanList(HashMap map);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- XXMapper.xml --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getXXXBeanList<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hashmap<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>XXBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>　　select * from tableName t where id= #{id} and name=#{name}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>其中 <code>map </code>中的 <code>key </code>名即是在 <code>#{}</code> 中使用的</p><h3 id="4-List-封装-in"><a href="#4-List-封装-in" class="headerlink" title="4. List 封装 in"></a>4. List 封装 in</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">// XXMapper.javapublic List&lt;XXBean&gt; getXXBeanList(List&lt;String&gt; list);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- XXMapper.xml --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>getXXXBeanList<span class="token punctuation">"</span></span> <span class="token attr-name">parameterType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hashmap<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>XXBean<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>　　select 字段... from tableName t where id in    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>foreach</span> <span class="token attr-name">item</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span> <span class="token attr-name">index</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>index<span class="token punctuation">"</span></span> <span class="token attr-name">collection</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list<span class="token punctuation">"</span></span> <span class="token attr-name">open</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>(<span class="token punctuation">"</span></span> <span class="token attr-name">separator</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>,<span class="token punctuation">"</span></span> <span class="token attr-name">close</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>)<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>    #{item}    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>foreach</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>foreach 最后的效果是：<code>select 字段 from tableName where id in ('1', '2', '3',...)</code></p><h3 id="5-使用注解方式"><a href="#5-使用注解方式" class="headerlink" title="5. 使用注解方式"></a>5. 使用注解方式</h3><p>在方法上使用 <code>@Param</code> 注解注明参数名</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Page&lt;ArticleVO&gt; selectPreviewPage(            @Param("page") Page&lt;Object&gt; page,            @Param("publish") int publish,            @Param("categoryId") Long categoryId,            @Param("tagId") Long tagId);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>select</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>selectPreviewPage<span class="token punctuation">"</span></span> <span class="token attr-name">resultType</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.blog.model.vo.ArticleVO<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        select                                                                          a.id as id,                                                                 a.title as title,                                                           a.avatar as avatar,                                                         a.is_stick as isStick,                                                      a.create_time as createTime,                                                c.id as categoryId,                                                         c.name as categoryName                                                  from blog_article a JOIN blog_category c on a.category_id = c.id            where a.is_publish = #{publish}                                             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>categoryId != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                                                and a.category_id = #{categoryId}                                       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>                                                                       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>if</span> <span class="token attr-name">test</span> <span class="token attr-value"><span class="token punctuation attr-equals">=</span> <span class="token punctuation">"</span>tagId != null<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                                                     and a.id in (                                                                   select article_id from blog_article_tag where tag_id = #{tagId}         )                                                                       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>if</span><span class="token punctuation">&gt;</span></span>                                                                       order by a.is_stick desc, a.create_time desc                            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>select</span><span class="token punctuation">&gt;</span></span>                                                                   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Hexo Using</title>
      <link href="/tur-study/2023/03/27/Java/GIt%20Hexo%20%E6%93%8D%E4%BD%9C/"/>
      <url>/tur-study/2023/03/27/Java/GIt%20Hexo%20%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h4 id="1-Hexo-基本命令"><a href="#1-Hexo-基本命令" class="headerlink" title="1. Hexo 基本命令"></a>1. Hexo 基本命令</h4><pre class="line-numbers language-none"><code class="language-none">hexo init --新建一个网站，若没有设置folder，默认在当前文件夹建立网站hexo generate --生成个人博客所需的静态页面hexo server --启动服务器，默认访问端口：loclahost:4000hexo deploy --部署个人博客hexo clean --清除缓存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上命令都能用首字母缩写完成</p><pre class="line-numbers language-none"><code class="language-none">hexo g --generate 生成个人博客所需的静态页面hexo s --serverhexo d --deploy 部署个人博客hexo c --clean 清除缓存<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-写文章用到的命令"><a href="#2-写文章用到的命令" class="headerlink" title="2. 写文章用到的命令"></a>2. 写文章用到的命令</h4><pre class="line-numbers language-none"><code class="language-none">hexo new --path java/ "文章标题" --新建文章hexo new page "页面名" -- 新建页面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-p, –path</td><td align="left">自定义新文章的路径</td></tr><tr><td align="left">-r, –replace</td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left">-s, –slug</td><td align="left">文章的Slug，作为新文章的文件名和发布后的URL</td></tr></tbody></table><p>编辑博客时使用如下命令</p><pre class="line-numbers language-none"><code class="language-none">hexo s --debug<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后访问<a href="http://localhost:4000/%E6%9D%A5%E8%BF%9B%E5%85%A5%E8%B0%83%E8%AF%95%E6%A8%A1%E5%BC%8F%EF%BC%8C%E6%9B%B4%E6%94%B9%E4%BA%86%E9%85%8D%E7%BD%AE%E6%88%96%E6%96%87%E7%AB%A0%E5%90%8E%E9%9A%8F%E6%97%B6%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E6%9D%A5%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C%E3%80%82">http://localhost:4000/来进入调试模式，更改了配置或文章后随时刷新页面来查看效果。</a></p><h4 id="3-部署博客的步骤"><a href="#3-部署博客的步骤" class="headerlink" title="3. 部署博客的步骤"></a>3. 部署博客的步骤</h4><pre class="line-numbers language-none"><code class="language-none">hexo cleanhexo generatehexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>后两步可以简写为<code>hexo g -d</code></p><h4 id="4-目录结构说明"><a href="#4-目录结构说明" class="headerlink" title="4. 目录结构说明"></a>4. 目录结构说明</h4><pre class="line-numbers language-none"><code class="language-none">|  +-- .deploy      #hexo deploy生成的文件|  +-- node_modules  #npm组件|  +-- public        #生成的静态网页文件|  +--scaffolds      #模板|  +-- source        #博客正文和其他源文件|  |  +-- _posts    #我们自己写的文章以md结尾|  +-- themes        #主题|  +-- _config.yml  #全局配置文件|  `-- package.json  #定义了hexo所需要的各种模块<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="5-配置文件"><a href="#5-配置文件" class="headerlink" title="5. 配置文件"></a>5. 配置文件</h4><p>在文件夹跟目录下的<code>_config.yml</code>叫做<strong>站点配置文件</strong>,同样的文件名我们可以在<code>theme</code>文件夹下的主题文件夹里面也找的。而主题文件夹下的<code>_config.yml</code>叫做主题配置文件。这里说明一下站点配置文件：</p><pre class="line-numbers language-none"><code class="language-none"># Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Site #站点信息title:  #标题subtitle:  #副标题description:  #站点描述，给搜索引擎看的author:  #作者email:  #电子邮箱language: zh-CN #语言# URL #链接格式url:  #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults:# Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录# Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮enable: true #是否启用line_number: true #显示行号tab_replace:# Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map:# Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2# Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev# Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss# Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page# Disqus #Disqus评论，替换为多说disqus_shortname:# Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的- hexo-generator-feed- hexo-generator-sitemap# Deployment #部署，将 lmintlcx 改成用户名deploy:type: gitrepo: github创库地址.gitbranch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal详解</title>
      <link href="/tur-study/2023/03/27/Java/ThreadLocal%E8%AF%A6%E8%A7%A3/"/>
      <url>/tur-study/2023/03/27/Java/ThreadLocal%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ThreadLocal-简介"><a href="#一、ThreadLocal-简介" class="headerlink" title="一、ThreadLocal 简介"></a>一、ThreadLocal 简介</h2><p>ThreadLocal 叫做 <font color="red"><strong>线程变量</strong></font>，指 ThreadLocal 中<font color="red">填充的变量</font>属于<font color="red">当前线程</font>，该变量对于其他线程而言是隔离的，即该变量是当前线程独有的变量。ThreadLocal 为变量在每个线程中都创建了副本，那么每个线程都可以访问自己内部的副本变量</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/tur-study/2023/03/26/hello-world/"/>
      <url>/tur-study/2023/03/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL--InnoDB引擎</title>
      <link href="/tur-study/2023/01/05/MySQL/MySQL--InnoDB%E5%BC%95%E6%93%8E/"/>
      <url>/tur-study/2023/01/05/MySQL/MySQL--InnoDB%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="1-逻辑存储结构"><a href="#1-逻辑存储结构" class="headerlink" title="1. 逻辑存储结构"></a>1. 逻辑存储结构</h2><p>InnoDB 的逻辑存储结构如下图所示：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172155660.png" alt="image-20230517215540572"></p><p><strong>表空间：</strong></p><p>表空间是InnoDB存储引擎逻辑结构的最高层， 如果用户启用了参数 innodb_file_per_table(在 8.0版本中默认开启) ，则每张表都会有一个表空间（xxx.ibd），一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p><p><strong>段：</strong></p><p>段，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点， 索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</p><p><strong>区：</strong></p><p>区，表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</p><p><strong>页：</strong></p><p>页，是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</p><p><strong>行：</strong></p><p>行，InnoDB 存储引擎数据是按行进行存放的。</p><p>在行中，默认有两个隐藏字段：</p><ul><li><code>Trx_id</code>：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li><code>Roll_pointer</code>：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息</li></ul><h2 id="2-架构"><a href="#2-架构" class="headerlink" title="2. 架构"></a>2. 架构</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>MySQL5.5 版本开始，默认使用 InnoDB 存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。</p><p>下面是 InnoDB 架构图，左侧为内存结构，右侧为磁盘结构。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172159265.png" alt="image-20230517215958193"></p><h3 id="2-2-内存结构"><a href="#2-2-内存结构" class="headerlink" title="2.2 内存结构"></a>2.2 内存结构</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172201637.png" alt="image-20230517220124583"></p><p>在左侧的内存结构中，主要分为这么四大块儿： Buffer Pool、Change Buffer、Adaptive Hash Index、Log Buffer</p><h4 id="2-2-1-Buffer-Pool"><a href="#2-2-1-Buffer-Pool" class="headerlink" title="2.2.1 Buffer Pool"></a>2.2.1 Buffer Pool</h4><p>InnoDB存储引擎基于磁盘文件存储，访问物理硬盘和在内存中进行访问，速度相差很大，为了尽可能弥补这两者之间的I/O效率的差值，就需要把经常使用的数据加载到缓冲池中，避免每次访问都进行磁盘I/O。</p><p>在InnoDB的缓冲池中不仅缓存了索引页和数据页，还包含了undo页、插入缓存、自适应哈希索引以及InnoDB的锁信息等等。</p><p>缓冲池 Buffer Pool，是主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度。</p><p>缓冲池以Page页为单位，底层采用链表数据结构管理Page。根据状态，将Page分为三种类型：</p><ul><li>free page：空闲 page，未被使用</li><li>clean page：被使用 page，数据灭有被修改过</li><li>dirty page：脏页，被使用 page，数据被修改过，其中数据与磁盘的数据产生了不一致</li></ul><p>在专用服务器上，通常将多达80％的物理内存分配给缓冲池 。参数设置： </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show variables like 'innodb_buffer_pool_size;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172220205.png" alt="image-20230517222030132"></p><h4 id="2-2-2-Change-Buffer"><a href="#2-2-2-Change-Buffer" class="headerlink" title="2.2.2 Change Buffer"></a>2.2.2 Change Buffer</h4><p>Change Buffer，更改缓冲区（针对于非唯一二级索引页），在执行DML语句时，如果这些数据Page没有在Buffer Pool中，不会直接操作磁盘，而会将数据变更存在更改缓冲区 Change Buffer，在未来数据被读取时，再将数据合并恢复到Buffer Pool中，再将合并后的数据刷新到磁盘中。</p><p>与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页，如果每一次都操作磁盘，会造成大量的磁盘IO。有了 ChangeBuffer之后，我们可以在缓冲池中进行合并处理，减少磁盘IO</p><h4 id="2-2-3-Adaptive-Hash-Index"><a href="#2-2-3-Adaptive-Hash-Index" class="headerlink" title="2.2.3 Adaptive Hash Index"></a>2.2.3 Adaptive Hash Index</h4><p>自适应hash索引，用于优化对Buffer Pool数据的查询。MySQL的innoDB引擎中虽然没有直接支持 hash索引，但是给我们提供了一个功能就是这个自适应hash索引。hash索引在进行等值匹配时，一般性能是要高于B+树的，因为hash索引一般只需要一次IO即可，而B+树，可能需要几次匹配，所以hash索引的效率要高，但是hash索引又不适合做范围查询、模糊匹配等。InnoDB存储引擎会监控对表上各索引页的查询，如果观察到在特定的条件下hash索引可以提升速度，则建立hash索引，称之为自适应hash索引</p><p><strong>自适应哈希索引，无需人工干预，是系统根据情况自动完成</strong></p><p>参数：<code> adaptive_hash_index</code></p><h4 id="2-2-4-Log-Buffer"><a href="#2-2-4-Log-Buffer" class="headerlink" title="2.2.4 Log Buffer"></a>2.2.4 Log Buffer</h4><p>Log Buffer：日志缓冲区，用来保存要写入到磁盘中的log日志数据（redo log 、undo log），默认大小为 16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。</p><p>参数：</p><ul><li><code>innodb_log_buffer_size</code>：缓冲区大小</li><li><code>innodb_flush_log_at_trs_commit</code>：日志刷新到磁盘时机，取值主要有以下三个：<ul><li>1：日志在每次事务提交时写入并刷新到磁盘，默认值</li><li>0：每秒将日志写入并刷洗难道磁盘一次</li><li>2：日志在每次事务提交后写入，并每秒刷新到磁盘一次</li></ul></li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172223909.png" alt="image-20230517222301848"></p><h3 id="2-3-磁盘架构"><a href="#2-3-磁盘架构" class="headerlink" title="2.3 磁盘架构"></a>2.3 磁盘架构</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172223190.png" alt="image-20230517222356127"></p><h4 id="2-3-1-System-Tablespace"><a href="#2-3-1-System-Tablespace" class="headerlink" title="2.3.1 System Tablespace"></a>2.3.1 System Tablespace</h4><p>系统表空间是更改缓冲区的存储区域。如果表是在系统表空间而不是每个表文件或通用表空间中创建的，它也可能包含表和索引数据。(在MySQL5.x版本中还包含InnoDB数据字典、undolog等)<br>参数：<code>innodb_data_file_path</code></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172225096.png" alt="image-20230517222526027"></p><p>系统表空间，默认的文件名叫 ibdata1</p><h4 id="2-3-2-File-Per-Table-Tablespace"><a href="#2-3-2-File-Per-Table-Tablespace" class="headerlink" title="2.3.2 File-Per-Table Tablespace"></a>2.3.2 File-Per-Table Tablespace</h4><p>如果开启了<code>innodb_file_per_table</code>开关 ，则每个表的文件表空间包含单个InnoDB表的数据和索引 ，并存储在文件系统上的单个数据文件中。</p><p>开关参数：<code>innodb_file_per_table</code> ，该参数默认开启。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172226128.png" alt="image-20230517222640069"></p><p>也就是说，每创建一个表都会产生一个表空间文件，如图：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172227844.png" alt="image-20230517222718772"></p><h4 id="2-3-3-General-Tablespace"><a href="#2-3-3-General-Tablespace" class="headerlink" title="2.3.3 General Tablespace"></a>2.3.3 General Tablespace</h4><p>通用表空间，需要通过 <code>CREATE TABLESPACE </code>语法创建通用表空间，在创建表时，可以指定该表空间</p><ul><li><p>创建表空间</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLESPACE ts_name ADD DATAFILE 'file_name' ENGINE = engine_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172229121.png" alt="image-20230517222910021"></p></li><li><p>创建表时指定表空间</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE xxx ... TABLESPACE ts_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172230708.png" alt="image-20230517223000656"></p></li></ul><h4 id="2-3-4-Undo-Tablespaces"><a href="#2-3-4-Undo-Tablespaces" class="headerlink" title="2.3.4 Undo Tablespaces"></a>2.3.4 Undo Tablespaces</h4><p>撤销表空间，MySQL实例在初始化时会自动创建两个默认的undo表空间（初始大小16M），用于存储 undo log日志。</p><h4 id="2-3-5-Temporary-Tablespaces"><a href="#2-3-5-Temporary-Tablespaces" class="headerlink" title="2.3.5 Temporary Tablespaces"></a>2.3.5 Temporary Tablespaces</h4><p>InnoDB 使用会话临时表空间和全局临时表空间。存储用户创建的临时表等数据。</p><h4 id="2-3-6-Doublewrite-Buffer-Files"><a href="#2-3-6-Doublewrite-Buffer-Files" class="headerlink" title="2.3.6 Doublewrite Buffer Files"></a>2.3.6 Doublewrite Buffer Files</h4><p>双写缓冲区，innoDB引擎将数据页从Buffer Pool刷新到磁盘前，先将数据页写入双写缓冲区文件中，便于系统异常时恢复数据。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172231621.png" alt="image-20230517223133561"></p><h4 id="2-3-7-Redo-Log"><a href="#2-3-7-Redo-Log" class="headerlink" title="2.3.7 Redo Log"></a>2.3.7 Redo Log</h4><p>重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中, 用于在刷新脏页到磁盘时,发生错误时, 进行数据恢复使用。</p><p>以循环方式写入重做日志文件，涉及两个文件：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172232583.png" alt="image-20230517223222540"></p><p>内存中所更新的数据，又是如何到磁盘中的呢？ 此时，就涉及到一组后台线程</p><h3 id="2-4-后台线程"><a href="#2-4-后台线程" class="headerlink" title="2.4 后台线程"></a>2.4 后台线程</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172233807.png" alt="image-20230517223334737"></p><p>在InnoDB的后台线程中，分为4类，分别是：<code>Master Thread</code> 、<code>IO Thread</code>、<code>Purge Thread</code>、<code>Page Cleaner Thread</code></p><h4 id="2-4-1-Master-Thread"><a href="#2-4-1-Master-Thread" class="headerlink" title="2.4.1 Master Thread"></a>2.4.1 Master Thread</h4><p>核心后台线程，负责调度其他线程，还负责将缓冲池中的数据异步刷新到磁盘中, 保持数据的一致性，还包括脏页的刷新、合并插入缓存、undo页的回收 </p><h4 id="2-4-2-IO-Thread"><a href="#2-4-2-IO-Thread" class="headerlink" title="2.4.2 IO Thread"></a>2.4.2 IO Thread</h4><p>在InnoDB存储引擎中大量使用了AIO来处理IO请求, 这样可以极大地提高数据库的性能，而IO Thread主要负责这些IO请求的回调</p><table><thead><tr><th>线程类型</th><th>默认个数</th><th>职责</th></tr></thead><tbody><tr><td>Read Thread</td><td>4</td><td>负责读操作</td></tr><tr><td>Write Thread</td><td>4</td><td>负责写操作</td></tr><tr><td>Log Thread</td><td>1</td><td>负责将日志缓冲区刷新到磁盘</td></tr><tr><td>Insert Buffer Thread</td><td>1</td><td>负责将写缓冲区内容刷新到磁盘</td></tr></tbody></table><p>可以通过以下的这条指令，查看到InnoDB的状态信息，其中就包含IO Thread信息：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show engine innodb status \G;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172314725.png" alt="image-20230517231438505"></p><h4 id="2-4-3-Purge-Thread"><a href="#2-4-3-Purge-Thread" class="headerlink" title="2.4.3 Purge Thread"></a>2.4.3 Purge Thread</h4><p>主要用于回收事务已经提交了的undo log，在事务提交之后，undo log可能不用了，就用它来回收。</p><h4 id="2-4-4-Page-Cleaner-Thread"><a href="#2-4-4-Page-Cleaner-Thread" class="headerlink" title="2.4.4 Page Cleaner Thread"></a>2.4.4 Page Cleaner Thread</h4><p>协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。</p><h2 id="3-事务原理"><a href="#3-事务原理" class="headerlink" title="3. 事务原理"></a>3. 事务原理</h2><h3 id="3-2-事务基础"><a href="#3-2-事务基础" class="headerlink" title="3.2 事务基础"></a>3.2 事务基础</h3><h4 id="3-2-1-事务"><a href="#3-2-1-事务" class="headerlink" title="3.2.1 事务"></a>3.2.1 事务</h4><p>事务 是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><h4 id="3-2-2-特性"><a href="#3-2-2-特性" class="headerlink" title="3.2.2 特性"></a>3.2.2 特性</h4><ul><li>原子性（Atomicity）：事务是不可分隔的最小操作单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><p>研究事务的原理，就是研究MySQL的InnoDB引擎是如何保证事务的这四大特性的。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172321655.png" alt="image-20230517232151602"></p><p>而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由InnoDB中的两份日志来保证的，一份是redo log日志，一份是undo log日志。 而隔离性是通过数据库的锁，加上MVCC来保证的。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172322476.png" alt="image-20230517232223415"></p><h3 id="3-2-redo-log"><a href="#3-2-redo-log" class="headerlink" title="3.2 redo log"></a>3.2 redo log</h3><p>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p>该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo logfile）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中, 用于在刷新脏页到磁盘,发生错误时, 进行数据恢复使用。</p><p>如果没有 redo log，可能会存在什么问题的？</p><p>在InnoDB引擎中的内存结构中，主要的内存区域就是缓冲池，在缓冲池中缓存了很多的数据页。 当我们在一个事务中，执行多个增删改的操作时，InnoDB引擎会先操作缓冲池中的数据，如果缓冲区没有对应的数据，会通过后台线程将磁盘中的数据加载出来，存放在缓冲区中，然后将缓冲池中的数据修改，修改后的数据页我们称为脏页。 而脏页则会在一定的时机，通过后台线程刷新到磁盘中，从而保证缓冲区与磁盘的数据一致。 而缓冲区的脏页数据并不是实时刷新的，而是一段时间之后将缓冲区的数据刷新到磁盘中，假如刷新到磁盘的过程出错了，而提示给用户事务提交成功，而数据却<br>没有持久化下来，这就出现问题了，没有保证事务的持久性</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172325281.png" alt="image-20230517232543227"></p><p>那么，如何解决上述的问题呢？ 在InnoDB中提供了一份日志 redo log，那么 redolog 如何解决这个问题？</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172326652.png" alt="image-20230517232649574"></p><p>有了redolog之后，当对缓冲区的数据进行增删改之后，会首先将操作的数据页的变化，记录在redolog buffer中。在事务提交时，会将redo log buffer中的数据刷新到redo log磁盘文件中。过一段时间之后，如果刷新缓冲区的脏页到磁盘时，发生错误，此时就可以借助于redo log进行数据恢复，这样就保证了事务的持久性。 而如果脏页成功刷新到磁盘 或 或者涉及到的数据已经落盘，此时redolog就没有作用了，就可以删除了，所以存在的两个redolog文件是循环写的</p><p>那为什么每一次提交事务，要刷新redo log 到磁盘中呢，而不是直接将buffer pool中的脏页刷新到磁盘呢 ?</p><p>因为在业务操作中，我们操作数据一般都是随机读写磁盘的，而不是顺序读写磁盘。 而redo log在往磁盘文件中写入数据，由于是日志文件，所以都是顺序写的。顺序写的效率，要远大于随机写。 这种先写日志的方式，称之为 WAL（Write-Ahead Logging）。</p><h3 id="3-3-undo-log"><a href="#3-3-undo-log" class="headerlink" title="3.3 undo log"></a>3.3 undo log</h3><p>回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC(多版本并发控制) 。</p><p>undo log 和 redo log 记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时，undo log 中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的 update 记录。当执行 rollback 时，就可以从undo log 中的逻辑记录读取到相应的内容并进行回滚。</p><ul><li>Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</li><li>Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的 rollback segment回滚段中，内部包含1024个 undo log segment</li></ul><h2 id="4-MVCC"><a href="#4-MVCC" class="headerlink" title="4. MVCC"></a>4. MVCC</h2><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><h4 id="4-1-1-当前读"><a href="#4-1-1-当前读" class="headerlink" title="4.1.1 当前读"></a>4.1.1 当前读</h4><p>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p><p>对于我们日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读。</p><p>测试：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172334048.png" alt="image-20230517233442792"></p><p>在测试中可以看到，即使是在默认的RR隔离级别下，事务A中依然可以读取到事务B最新提交的内容，因为在查询语句后面加上了 lock in share mode 共享锁，此时是当前读操作。当然，当加排他锁的时候，也是当前读操作。</p><h4 id="4-1-2-快照读"><a href="#4-1-2-快照读" class="headerlink" title="4.1.2 快照读"></a>4.1.2 快照读</h4><p>简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><ul><li>Read Committed：每次 select，都生成一个快照读</li><li>Repeatable Read：开启事务后第一个 select 语句才是快照读的地方</li><li>Serializable：快照读会退化为当前读</li></ul><p>测试：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172340409.png" alt="image-20230517234008174"></p><p>在测试中,我们看到即使事务B提交了数据,事务A中也查询不到。 原因就是因为普通的select是快照读，而在当前默认的RR隔离级别下，开启事务后第一个select语句才是快照读的地方，后面执行相同的select语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读</p><h4 id="4-1-3-MVCC"><a href="#4-1-3-MVCC" class="headerlink" title="4.1.3 MVCC"></a>4.1.3 MVCC</h4><p>全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView</p><h3 id="4-2-隐藏字段"><a href="#4-2-隐藏字段" class="headerlink" title="4.2 隐藏字段"></a>4.2 隐藏字段</h3><h4 id="4-2-1-介绍"><a href="#4-2-1-介绍" class="headerlink" title="4.2.1 介绍"></a>4.2.1 介绍</h4><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180805765.png" alt="image-20230518080552692"></p><p>当我们创建了上面的这张表，我们在查看表结构的时候，就可以显式的看到这三个字段。 实际上除了<br>三个字段以外，InnoDB还会自动的给我们添加三个隐藏字段及其含义分别是：</p><table><thead><tr><th>隐藏字段</th><th>含义</th></tr></thead><tbody><tr><td>DB_TRX_ID</td><td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID</td></tr><tr><td>DB_ROLL_PTR</td><td>回滚指针，指向这条记录的上一个版本，用于配合 undo log，指向上一个版本</td></tr><tr><td>DB_ROW_ID</td><td>隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段</td></tr></tbody></table><p>而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段</p><h4 id="4-2-2-测试"><a href="#4-2-2-测试" class="headerlink" title="4.2.2 测试"></a>4.2.2 测试</h4><p><strong>查看有主键的表 stu：</strong></p><p>进入服务器中的 /var/lib/mysql/itcast/ , 查看stu的表结构信息, 通过如下指令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ibd2sdi stu.bdi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看到的表结构信息中，有一栏 columns，在其中我们会看到处理我们建表时指定的字段以外，还有额外的两个字段 分别是：DB_TRX_ID 、 DB_ROLL_PTR ，因为该表有主键，所以没有 DB_ROW_ID 隐藏字段。</p><p>而对于没有主键的表，字段中除了 DB_TRX_ID、DB_ROLL_PTR，还有 DB_ROW_ID</p><h3 id="4-3-undo-log"><a href="#4-3-undo-log" class="headerlink" title="4.3 undo log"></a>4.3 undo log</h3><p>回滚日志，在insert、update、delete的时候产生的便于数据回滚的日志。</p><ul><li>当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</li><li>而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除</li></ul><h4 id="4-3-2-版本链"><a href="#4-3-2-版本链" class="headerlink" title="4.3.2 版本链"></a>4.3.2 版本链</h4><p>有一张表原始数据为：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180814352.png" alt="image-20230518081459296"></p><blockquote><ul><li>DB_TRX_ID : 代表最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID，是自增的。</li><li>DB_ROLL_PTR ： 由于这条数据是才插入的，没有被更新过，所以该字段值为null。</li></ul></blockquote><p>然后，有四个并发事务同时在访问这张表。</p><p>第一步：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180815303.png" alt="image-20230518081555238"></p><p>当事务2执行第一条修改语句时，会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180816565.png" alt="image-20230518081635491"></p><p>第二步：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180817417.png" alt="image-20230518081705286"></p><p>当事务3执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180820029.png" alt="image-20230518082031946"></p><p>第三步：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180820498.png" alt="image-20230518082056402"></p><p>当事务4执行第一条修改语句时，也会记录undo log日志，记录数据变更之前的样子; 然后更新记录，并且记录本次操作的事务ID，回滚指针，回滚指针用来指定如果发生回滚，回滚到哪一个版本。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180821565.png" alt="image-20230518082124486"></p><p>最终可以发现，不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><h3 id="4-4-readview"><a href="#4-4-readview" class="headerlink" title="4.4 readview"></a>4.4 readview</h3><p>ReadView（读视图）是快照读 SQL 执行时 MVCC 提取数据的依据，记录并维护系统当前活跃的事务（未提交的）id</p><p>ReadView 中包含四个核心字段：</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>m_ids</td><td>当前活跃的事务 ID 集合</td></tr><tr><td>min_trx_id</td><td>最小活跃事务 ID</td></tr><tr><td>max_trx_id</td><td>预分配事务 ID，当前最大事务 ID+1（因为事务ID是自增的）</td></tr><tr><td>creator_trx_id</td><td>ReadView 创建者的事务 ID</td></tr></tbody></table><p>而在 ReadView 中规定了版本链数据的访问规则：trx_id 代表当前 undo log 版本链对应事务 ID</p><table><thead><tr><th>条件</th><th>是否可以访问</th><th>范围</th></tr></thead><tbody><tr><td>trx_id == creator_trx_id</td><td>可以访问该版本</td><td>成立，说明数据时当前这个事务更改的</td></tr><tr><td>trx_id &lt; min_trx_id</td><td>可以访问该版本</td><td>成立，说明数据已经提交了</td></tr><tr><td>trx_id &gt; max_trx_id</td><td>不可以访问该版本</td><td>成立，说明该事务是在 ReadView 生成后才开启</td></tr><tr><td>min_trx_id &lt;= trx_id &lt;= max_trx_id</td><td>如果 trx_id 不在 m_ids 中，是可以访问该版本的</td><td>成立，说明事务已经提交</td></tr></tbody></table><p>不同的隔离级别，生成 ReadView 的时机不同：</p><ul><li>READ COMMITTED：在事务中每一次执行快照读时生成 ReadView</li><li>REPEATABLE READ：仅在事务中第一次执行快照读时生成 ReadView，后续复用该 ReadView</li></ul><h3 id="4-5-原理分析"><a href="#4-5-原理分析" class="headerlink" title="4.5 原理分析"></a>4.5 原理分析</h3><h4 id="4-5-1-RC-隔离级别"><a href="#4-5-1-RC-隔离级别" class="headerlink" title="4.5.1 RC 隔离级别"></a>4.5.1 RC 隔离级别</h4><p>RC隔离级别下，在事务中每一次执行快照读时生成ReadView。</p><p>分析上述中的事务5，两次快照读读取数据，是如何获取数据的?</p><p>在事务5中，查询了两次id为30的记录，由于隔离级别为Read Committed，所以每一次进行快照读都会生成一个ReadView，那么两次生成的ReadView如下。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180834908.png" alt="image-20230518083451812"></p><p>那么这两次快照读在获取数据时，就需要根据所生成的 ReadView 以及 ReadView 的版本链访问规则，到 undolog 版本链中匹配数据，最终决定此次快照读返回的数据</p><p><strong>第一次快照读的具体读取过程：</strong></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180835912.png" alt="image-20230518083558828"></p><p>在进行匹配时，会从undo log的版本链，从上到下进行挨个匹配：</p><p>先匹配：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180836119.png" alt="image-20230518083644068"></p><p>这条记录，这条记录对应的 trx_id 为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配 undo log版本链的下一条。</p><p>再匹配第二条：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180837736.png" alt="image-20230518083747682"></p><p>这条记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配undo log版本链的下一条。</p><p>再匹配第三条：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180838034.png" alt="image-20230518083823983"></p><p>这条记录对应的trx_id为2，也就是将2带入右侧的匹配规则中。①不满足 ②满足 终止匹配，此次快照读，返回的数据就是版本链中记录的这条数据。</p><p><strong>第二次快照读的具体读取过程：</strong></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180839391.png" alt="image-20230518083936317"></p><p>先匹配：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180836119.png" alt="image-20230518083644068"></p><p>这条记录，这条记录对应的 trx_id 为4，也就是将4带入右侧的匹配规则中。 ①不满足 ②不满足 ③不满足 ④也不满足 ，都不满足，则继续匹配 undo log版本链的下一条。</p><p>再匹配第二条：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180837736.png" alt="image-20230518083747682"></p><p>这条记录对应的trx_id为3，也就是将3带入右侧的匹配规则中。①不满足 ②满足 。终止匹配，此次快照读，返回的数据就是版本链中记录的这条数据</p><h4 id="4-5-3-RR-隔离级别"><a href="#4-5-3-RR-隔离级别" class="headerlink" title="4.5.3 RR 隔离级别"></a>4.5.3 RR 隔离级别</h4><p>RR隔离级别下，仅在事务中第一次执行快照读时生成ReadView，后续复用该ReadView。 而RR 是可重复读，在一个事务中，执行两次相同的select语句，查询到的结果是一样的。</p><p>那MySQL是如何做到可重复读的呢? 分析如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180841430.png" alt="image-20230518084147337"></p><p>在RR隔离级别下，只是在事务中第一次快照读时生成ReadView，后续都是复用该ReadView，那么既然ReadView都一样， ReadView的版本链匹配规则也一样， 那么最终快照读返回的结果也是一样的。</p><p>所以呢，MVCC的实现原理就是通过 InnoDB表的隐藏字段、UndoLog 版本链、ReadView来实现的。而MVCC + 锁，则实现了事务的隔离性。 而一致性则是由redolog 与 undolog保证。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305180843549.png" alt="image-20230518084311454"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL管理</title>
      <link href="/tur-study/2023/01/05/MySQL/MySQL%E7%AE%A1%E7%90%86/"/>
      <url>/tur-study/2023/01/05/MySQL/MySQL%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-系统数据库"><a href="#1-系统数据库" class="headerlink" title="1. 系统数据库"></a>1. 系统数据库</h2><p>MySQL 数据库安装完成后，自带了四个数据库，具体作用如下：</p><table><thead><tr><th>数据库</th><th>含义</th></tr></thead><tbody><tr><td>mysql</td><td>存储 MySQL 服务器正常运行所需要的各种信息（时区、主从、用户、权限等）</td></tr><tr><td>information_schema</td><td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型和访问权限等</td></tr><tr><td>performance_schema</td><td>为 MySQL 服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数</td></tr><tr><td>sys</td><td>包含了一系列方便 DBA 和开发人员利用 performance_schema 性能数据库进行性能调优和诊断的视图</td></tr></tbody></table><h2 id="2-常用工具"><a href="#2-常用工具" class="headerlink" title="2. 常用工具"></a>2. 常用工具</h2><h3 id="2-1-mysql"><a href="#2-1-mysql" class="headerlink" title="2.1 mysql"></a>2.1 mysql</h3><blockquote><p>该 mysql 指的是 MySQL 的客户端工具</p></blockquote><p>语法：<code>mysql [options] [database]</code><br>选项：</p><ul><li>-u，–user=name：指定用户</li><li>-p，–pasword[=name] 指定密码</li><li>-h，–host=name 指定服务器 IP 或域名</li><li>-P，–port=port 指定连接端口</li><li>-e，–execute=name 执行 SQL 语句并退出</li></ul><p>-e 选项可以在Mysql客户端执行SQL语句，而不用连接到MySQL数据库再执行，对于一些批处理脚本，这种方式尤其方便。</p><h3 id="2-2-mysqladmin"><a href="#2-2-mysqladmin" class="headerlink" title="2.2 mysqladmin"></a>2.2 mysqladmin</h3><p>mysqladmin 是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p><blockquote><p>通过帮助文档查看选项：mysqladmin –help</p></blockquote><p>语法: <code>mysqladmin [options] command ...</code></p><p>选项:</p><ul><li>-u, –user=name #指定用户名</li><li>-p, –password[=name] #指定密码</li><li>-h, –host=name #指定服务器IP或域名</li><li>-P, –port=port #指定连接端口</li></ul><h3 id="2-3-mysqlbinlog"><a href="#2-3-mysqlbinlog" class="headerlink" title="2.3 mysqlbinlog"></a>2.3 mysqlbinlog</h3><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">语法 ：mysqlbinlog [options] log-files1 log-files2 ...选项 ：-d, --database=name 指定数据库名称，只列出指定的数据库相关操作。-o, --offset=# 忽略掉日志中的前n行命令。-r,--result-file=name 将输出的文本格式日志输出到指定文件。-s, --short-form 显示简单格式， 省略掉一些信息。--start-datatime=date1 --stop-datetime=date2 指定日期间隔内的所有日志。--start-position=pos1 --stop-position=pos2 指定位置间隔内的所有日志。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-mysqlshow"><a href="#2-4-mysqlshow" class="headerlink" title="2.4 mysqlshow"></a>2.4 mysqlshow</h3><p>mysqlshow 客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p><p>语法 ：<code>mysqlshow [options] [db_name [table_name [col_name]]]</code></p><p>选项 ：</p><ul><li>–count 显示数据库及表的统计信息（数据库，表 均可以不指定）</li><li>-i 显示指定数据库或者指定表的状态信息</li></ul><h3 id="2-5-mysqldump"><a href="#2-5-mysqldump" class="headerlink" title="2.5 mysqldump"></a>2.5 mysqldump</h3><p>mysqldump 客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句</p><p>语法 ：</p><ul><li>mysqldump [options] db_name [tables]</li><li>mysqldump [options] –database/-B db1 [db2 db3…]</li><li>mysqldump [options] –all-databases/-A</li></ul><p>连接选项 ：</p><ul><li>-u, –user=name 指定用户名</li><li>-p, –password[=name] 指定密码</li><li>-h, –host=name 指定服务器ip或域名</li><li>-P, –port=# 指定连接端口</li></ul><p>输出选项：</p><ul><li>–add-drop-database 在每个数据库创建语句前加上 drop database 语句</li><li>–add-drop-table 在每个表创建语句前加上 drop table 语句 , 默认开启 ; 不开启 (–skip-add-drop-table)</li><li>-n, –no-create-db 不包含数据库的创建语句</li><li>-t, –no-create-info 不包含数据表的创建语句</li><li>-d –no-data 不包含数据</li><li>-T, –tab=name 自动生成两个文件：一个.sql文件，创建表结构的语句；一个.txt文件，数据文件</li></ul><p>备份出来的数据包含：</p><ul><li>删除表的语句</li><li>创建表的语句</li><li>数据插入语句</li></ul><p>如果我们在数据备份时，不需要创建表，或者不需要备份数据，只需要备份表结构，都可以通过对应的参数来实现。</p><h3 id="2-6-mysqlimport-x2F-source"><a href="#2-6-mysqlimport-x2F-source" class="headerlink" title="2.6 mysqlimport/source"></a>2.6 mysqlimport/source</h3><h4 id="2-6-1-mysqlimport"><a href="#2-6-1-mysqlimport" class="headerlink" title="2.6.1 mysqlimport"></a>2.6.1 mysqlimport</h4><p>mysqlimport 是客户端数据导入工具，用来导入mysqldump 加 -T 参数后导出的文本文件。</p><p>语法 ：<code>mysqlimport [options] db_name textfile1 [textfile2...]</code></p><p>示例 ：<code>mysqlimport -uroot -p2143 test /tmp/city.txt</code></p><h4 id="2-6-2-source"><a href="#2-6-2-source" class="headerlink" title="2.6.2 source"></a>2.6.2 source</h4><p>如果需要导入sql文件,可以使用mysql中的source 指令 :</p><p>语法 ：<code>source /root/xxxxx.sql</code></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL--视图-存储过程-触发器</title>
      <link href="/tur-study/2023/01/04/MySQL/MySQL--%E8%A7%86%E5%9B%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/tur-study/2023/01/04/MySQL/MySQL--%E8%A7%86%E5%9B%BE-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-视图"><a href="#1-视图" class="headerlink" title="1. 视图"></a>1. 视图</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p><p>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p><h3 id="1-2-语法"><a href="#1-2-语法" class="headerlink" title="1.2 语法"></a>1.2 语法</h3><p><strong>创建：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED | LOCAL] CHECK OPTION ]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查询：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 查看创建视图的语句SHOW CREATE VIEW 视图名称;-- 查看视图数据SELECt * FROM 视图名称 ....;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修改：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 方式一CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED | LOCAL] CHECK OPTION ]-- 方式二ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED | LOCAL] CHECK OPTION ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP VIEW [IF EXISTS] 视图名称 [, 视图名称] ...<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>示例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 创建视图create or replace view stu_v_1 as select id,name from student where id &lt;= 10;-- 查询视图show create view stu_v_1;select * from stu_v_1;select * from stu_v_1 where id &lt; 3;-- 修改视图create or replace view stu_v_1 as select id,name,no from student where id &lt;= 10;alter view stu_v_1 as select id,name from student where id &lt;= 10;-- 删除视图drop view if exists stu_v_1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过视图还可以来插入、更新数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create or replace view stu_v_1 as select id,name from student where id &lt;= 10 ;select * from stu_v_1;insert into stu_v_1 values(6,'Tom');insert into stu_v_1 values(17,'Tom22');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>执行上述的SQL，我们会发现，id为6和17的数据都是可以成功插入的。 但是我们执行查询，查询出来的数据，却没有id为17的记录。这是因为我们在创建视图的时候，指定的条件为 id&lt;=10, id为17的数据，是不符合条件的，所以没有查询出来，但是这条数据确实是已经成功的插入到了基表中。</p><p>如果我们定义视图时，如果指定了条件，然后我们在插入、修改、删除数据时，是否可以做到必须满足条件才能操作，否则不能够操作呢？ 答案是可以的，这就需要借助于视图的检查选项了。</p><h3 id="1-3-检查选项"><a href="#1-3-检查选项" class="headerlink" title="1.3 检查选项"></a>1.3 检查选项</h3><p>当使用 <code>WITH CHECK OPTION</code> 子句创建视图时，MySQL 会通过视图检查正在更改的每个行，如插入、更新、伤处，以使其符合视图的定义。</p><p>MySQL 允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。</p><p>为了确定检查的范围，MySQL 提供了两个选项：</p><ul><li>CASCADED（级联，默认）</li><li>LOCAL</li></ul><h4 id="1-3-1-CASCADED"><a href="#1-3-1-CASCADED" class="headerlink" title="1.3.1 CASCADED"></a>1.3.1 CASCADED</h4><p>级联。比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 cascaded，但是v1视图创建时未指定检查选项。 则在执行检查时，不仅会检查v2，还会级联检查v2的关联视图v1。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305181247063.png" alt="image-20230518124704983"></p><h4 id="1-3-2-LOCAL"><a href="#1-3-2-LOCAL" class="headerlink" title="1.3.2 LOCAL"></a>1.3.2 LOCAL</h4><p>本地。比如，v2视图是基于v1视图的，如果在v2视图创建的时候指定了检查选项为 local ，但是v1视图创建时未指定检查选项。 则在执行检查时，知会检查v2，不会检查v2的关联视图v1。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305181247377.png" alt="image-20230518124741319"></p><h3 id="1-4-视图的更新"><a href="#1-4-视图的更新" class="headerlink" title="1.4 视图的更新"></a>1.4 视图的更新</h3><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一关系，如果视图包含以下任意一项，则该视图不可更新：</p><ul><li>聚合函数或窗口函数（SUM、MIN、MAX、COUNT 等）</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>UNION 或者 UNION ALL</li></ul><p>示例：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305181252709.png" alt="image-20230518125203657"></p><h3 id="1-5-视图的作用"><a href="#1-5-视图的作用" class="headerlink" title="1.5 视图的作用"></a>1.5 视图的作用</h3><p><strong>简单：</strong></p><p>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。</p><p><strong>安全：</strong></p><p>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</p><p><strong>数据独立：</strong></p><p>视图可帮助用户屏蔽真实表结构变化带来的影响。</p><h2 id="2-存储过程"><a href="#2-存储过程" class="headerlink" title="2. 存储过程"></a>2. 存储过程</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</p><p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305181434246.png" alt="image-20230518143429178"></p><ul><li><p>封装，复用 —— 可以把某一个业务 SQL 封装在存储过程，需要用到时直接调用即可</p></li><li><p>可以接收参数，也可以返回数据 —— 在存储过程中，可以传递参数，也可以接收返回值</p></li><li><p>减少网络交互，效率提升 —— 如果设计到多条 SQL，每次执行一次都是一次网络传输，而如果分装在存储过程中，就只需要一次网络交互可能就可以了</p></li></ul><h3 id="2-2-基本语法"><a href="#2-2-基本语法" class="headerlink" title="2.2 基本语法"></a>2.2 基本语法</h3><p><strong>创建：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE PROCEDURE 存储过程名称 ([ 参数列表 ])BEGIN-- SQL 语句END;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>调用：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CALL 名称 ([ 参数 ]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 查询指定数据库的存储过程及状态信息SELECT * FROm information_schema.ROUTINES WHERE ROUTINE_SCHEMA = 'xxx';-- 查询某个存储过程的定义SHOW CREATE PROCEDURE 存储过程名称;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP PROCEDURE [ IF EXISTS ] 存储过程名称;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>==注意：==</p><p>在命令行中执行创建存储过程的 SQL 时，需要通过关键字 <code>delimiter </code>指定 SQL语句的结束符</p></blockquote><p>示例：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 存储过程基本语法-- 创建create procedure p1()beginselect count(*) from stu;end;-- 调用call p1();-- 查看select * from information_schema.ROUTINES where ROUTINE_SCHEMA = 'itcast';show create procedure p1;-- 删除drop procedure if exists p1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-变量"><a href="#2-3-变量" class="headerlink" title="2.3 变量"></a>2.3 变量</h3><p>在 MySQL 中变量分为三种类型：系统变量、用户定义变量、局部变量</p><h4 id="2-3-1-系统变量"><a href="#2-3-1-系统变量" class="headerlink" title="2.3.1 系统变量"></a>2.3.1 系统变量</h4><p>系统变量 是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）。</p><p><strong>查看系统变量：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 查看所有系统变量SHOW [ SESSION | GLOBAL ] VARIABLES;-- 通过 LIKE 模糊匹配方式查找变量SHOW [ SESSION | GLOBAL ] VARIABLES LIKE '......';-- 查看指定变量的值SELECt @@[SESSION | GLOBAL] 系统变量名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>设置系统变量：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SET [ SESSION | GLOBAL ] 系统变量名 = 值;SET @@[SESSION | GLOBAL ] 系统变量名 = 值;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>==注意:==</p><ul><li>如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量。</li><li>mysql 服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在<code>/etc/my.cnf</code>中配置。</li><li>全局变量(GLOBAL): 全局变量针对于所有的会话。</li><li>会话变量(SESSION): 会话变量针对于单个会话，在另外一个会话窗口就不生效了</li></ul></blockquote><h4 id="2-3-2-用户定义变量"><a href="#2-3-2-用户定义变量" class="headerlink" title="2.3.2 用户定义变量"></a>2.3.2 用户定义变量</h4><p>用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用 “@变量名” 使用就可以。其作用域为当前连接。</p><p><strong>赋值：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 方式一-- 赋值时，可以使用 = ，也可以使用 := SET @var_name = expr [, @var_name = expr] ... ;SET @var_name := expr [, @var_name := expr] ... ;-- 方式二SELECT @var_name := expr [, @var_name := expr] ... ;SELECT 字段名 INTO @var_name FROM 表名;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT @var_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>注意: 用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL。</p></blockquote><h4 id="2-3-3-局部变量"><a href="#2-3-3-局部变量" class="headerlink" title="2.3.3 局部变量"></a>2.3.3 局部变量</h4><p>局部变量 是根据需要定义的在局部生效的变量，访问之前，需要<code>DECLARE</code>声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的<code>BEGIN ... END</code>块</p><p><strong>声明：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DECLARE 变量名 变量类型 [DEFAULT ... ] ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</p><p><strong>赋值：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SET 变量名 = 值 ;SET 变量名 := 值 ;SELECT 字段名 INTO 变量名 FROM 表名 ... ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-4-if"><a href="#2-4-if" class="headerlink" title="2.4 if"></a>2.4 if</h3><h4 id="2-4-1-介绍"><a href="#2-4-1-介绍" class="headerlink" title="2.4.1 介绍"></a>2.4.1 介绍</h4><p>if 用于做条件判断，具体的语法结构为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">IF 条件1 THEN.....ELSEIF 条件2 THEN -- 可选.....ELSE -- 可选.....END IF;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在if条件判断的结构中，ELSE IF 结构可以有多个，也可以没有。 ELSE结构可以有，也可以没有</p><h4 id="2-4-2-案例"><a href="#2-4-2-案例" class="headerlink" title="2.4.2 案例"></a>2.4.2 案例</h4><p>根据定义的分数score变量，判定当前分数对应的分数等级。</p><ul><li>score &gt;= 85分，等级为优秀。</li><li>score &gt;= 60分 且 score &lt; 85分，等级为及格。</li><li>score &lt; 60分，等级为不及格。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create procedure p3()begindeclare score int default 58;declare result varchar(10);if score &gt;= 85 thenset result := '优秀';elseif score &gt;= 60 thenset result := '及格';elseset result := '不及格';end if;select result;end;call p3();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述的需求我们虽然已经实现了，但是也存在一些问题，比如：score 分数我们是在存储过程中定义死的，而且最终计算出来的分数等级，我们也仅仅是最终查询展示出来而已。那么我们能不能，把score分数动态的传递进来，计算出来的分数等级是否可以作为返回值返回呢？答案是肯定的，我们可以通过下面的 <strong>参数</strong> 来解决上述的问题。</p><h3 id="2-5-参数"><a href="#2-5-参数" class="headerlink" title="2.5 参数"></a>2.5 参数</h3><h4 id="2-5-1-介绍"><a href="#2-5-1-介绍" class="headerlink" title="2.5.1 介绍"></a>2.5.1 介绍</h4><p>参数的类型主要分为以下三种：IN、OUT、INOUT。具体含义如下：</p><table><thead><tr><th>类型</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>IN</td><td>该类参数作为输入，也就是需要调用时的传入值</td><td>默认</td></tr><tr><td>OUT</td><td>该类参数作为输出，也就是该参数可以作为返回值</td><td></td></tr><tr><td>INOUT</td><td>即可以作为输入参数，也可以作为输出参数</td><td></td></tr></tbody></table><p>用法：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE PROCEDURE 存储过程名称 ([ IN/OUT/INOUT 参数名 参数类型 ])BEGIN-- SQL语句END ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-2-案例一"><a href="#2-5-2-案例一" class="headerlink" title="2.5.2 案例一"></a>2.5.2 案例一</h4><p>根据传入参数score，判定当前分数对应的分数等级，并返回。</p><ul><li>score &gt;= 85分，等级为优秀。</li><li>score &gt;= 60分 且 score &lt; 85分，等级为及格。</li><li>score &lt; 60分，等级为不及格。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create procedure p4(in score int, out result varchar(10))beginif score &gt;= 85 thenset result := '优秀';elseif score &gt;= 60 thenset result := '及格';else set result := '不及格';end if;end;-- 定义用户变量 @result 来接收返回的数据，用户变量可以不用声明call p4(18, @result);select @result;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-3-案例二"><a href="#2-5-3-案例二" class="headerlink" title="2.5.3 案例二"></a>2.5.3 案例二</h4><p>将传入的200分制的分数，进行换算，换算成百分制，然后返回。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create procedure p5(inout score double)beginset score := score * 0.5;end;set @score = 198;call p5(@score);select @score<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-case"><a href="#2-6-case" class="headerlink" title="2.6 case"></a>2.6 case</h3><h4 id="2-6-1-介绍"><a href="#2-6-1-介绍" class="headerlink" title="2.6.1 介绍"></a>2.6.1 介绍</h4><p>case 结构及作用和流程控制函数很类似，有两种语法格式：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 语法1-- 含义： 当case_value的值为 when_value1时，执行statement_list1，当值为 when_value2时，执行statement_list2， 否则就执行 statement_listCASE case_valueWHEN when_value1 THEN statement_list1[ WHEN when_value2 THEN statement_list2] ...[ ELSE statement_list ]END CASE;-- 语法2-- 含义： 当条件search_condition1成立时，执行statement_list1，当条件search_condition2成立时，执行statement_list2， 否则就执行 statement_listCASEWHEN search_condition1 THEN statement_list1[WHEN search_condition2 THEN statement_list2] ...[ELSE statement_list]END CASE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-6-2-案例"><a href="#2-6-2-案例" class="headerlink" title="2.6.2 案例"></a>2.6.2 案例</h4><p>根据传入的月份，判定月份所属的季节（要求采用case结构）。</p><ul><li>1-3月份，为第一季度</li><li>4-6月份，为第二季度</li><li>7-9月份，为第三季度</li><li>10-12月份，为第四季度</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create procedure p6(in month int)begindeclare result varchar(10);casewhen month &gt;= 1 and month &lt;= 3 thenset result := '第一季度';when month &gt;= 4 and month &lt;= 6 thenset result := '第二季度';when month &gt;= 7 and month &lt;= 9 thenset result := '第三季度';when month &gt;= 10 and month &lt;= 12 thenset result := '第四季度';elseset result := '非法参数';end case ;select concat('您输入的月份为: ',month, ', 所属的季度为: ',result);end;call p6(16);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注：如果判定条件有多个，多个条件之间，可以使用 and 或 or 进行连接。</p></blockquote><h3 id="2-7-while"><a href="#2-7-while" class="headerlink" title="2.7 while"></a>2.7 while</h3><h4 id="2-7-1-介绍"><a href="#2-7-1-介绍" class="headerlink" title="2.7.1 介绍"></a>2.7.1 介绍</h4><p>while 循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑WHILE 条件 DOSQL逻辑...END WHILE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-7-2-案例"><a href="#2-7-2-案例" class="headerlink" title="2.7.2 案例"></a>2.7.2 案例</h4><p>计算从1累加到n的值，n为传入的参数值。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create procedure p7(in n int)begindeclare total int default 0;while n&gt;0 doset total := total + n;set n := n - 1;end while;select total;end;call p7(100);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-8-repeat"><a href="#2-8-repeat" class="headerlink" title="2.8 repeat"></a>2.8 repeat</h3><h4 id="2-8-1-介绍"><a href="#2-8-1-介绍" class="headerlink" title="2.8.1 介绍"></a>2.8.1 介绍</h4><p>repeat是有条件的循环控制语句, 当满足until声明的条件的时候，则退出循环 。具体语法为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 先执行一次逻辑，然后判定UNTIL条件是否满足，如果满足，则退出。如果不满足，则继续下一次循环REPEATSQL逻辑...UNTIL 条件END REPEAT;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-8-2-案例"><a href="#2-8-2-案例" class="headerlink" title="2.8.2 案例"></a>2.8.2 案例</h4><p>计算从1累加到n的值，n为传入的参数值。(使用repeat实现)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- A. 定义局部变量, 记录累加之后的值;-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环create procedure p8(in n int)begindeclare total int default 0;repeatset total := total + n;set n := n - 1;until n &lt;= 0end repeat;select total;end;call p8(10);call p8(100);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-9-loop"><a href="#2-9-loop" class="headerlink" title="2.9 loop"></a>2.9 loop</h3><h4 id="2-9-1-介绍"><a href="#2-9-1-介绍" class="headerlink" title="2.9.1 介绍"></a>2.9.1 介绍</h4><p>LOOP 实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。LOOP可以配合一下两个语句使用：</p><ul><li><code>LEAVE </code>：配合循环使用，退出循环。</li><li><code>ITERATE</code>：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">[begin_label:] LOOPSQL逻辑...END LOOP [end_label];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">LEAVE label; -- 退出指定标记的循环体ITERATE label; -- 直接进入下一次循环<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>上述语法中出现的 begin_label，end_label，label 指的都是我们所自定义的标记。</p></blockquote><h4 id="2-9-2-案例一"><a href="#2-9-2-案例一" class="headerlink" title="2.9.2 案例一"></a>2.9.2 案例一</h4><p>计算从1累加到n的值，n为传入的参数值。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- A. 定义局部变量, 记录累加之后的值;-- B. 每循环一次, 就会对n进行-1 , 如果n减到0, 则退出循环 ----&gt; leave xxcreate procedure p9(in n int)begindeclare total int default 0;sum:loopif n&lt;=0 thenleave sum;end if;set total := total + n;set n := n - 1;end loop sum;select total;end;call p9(100);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-9-3-案例三"><a href="#2-9-3-案例三" class="headerlink" title="2.9.3 案例三"></a>2.9.3 案例三</h4><p>计算从1到n之间的偶数累加的值，n为传入的参数值。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create procedure p10(in n int)begindeclare total int default 0;sum:loopif n&lt;=0 thenleave sum;end if;if n%2 = 1 thenset n := n - 1;iterate sum;end if;set total := total + n;set n := n - 1;end loop sum;select total;end;call p9(100);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-10-游标"><a href="#2-10-游标" class="headerlink" title="2.10 游标"></a>2.10 游标</h3><h4 id="2-10-1-介绍"><a href="#2-10-1-介绍" class="headerlink" title="2.10.1 介绍"></a>2.10.1 介绍</h4><p>游标（CURSOR）是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用游标对结果集进<br>行循环的处理。游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 声明游标DECLARE 游标名称 CURSOR FOR 查询语句;-- 打开游标OPEN 游标名称;-- 获取游标记录FETCH 游标名称 INTO 变量 [, 变量 ];-- 关闭游标CLOSE 游标名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-10-2-案例"><a href="#2-10-2-案例" class="headerlink" title="2.10.2 案例"></a>2.10.2 案例</h4><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。</p><p>逻辑：</p><p>逻辑:</p><ol><li>声明游标, 存储查询结果集</li><li>准备: 创建表结构</li><li>开启游标</li><li>获取游标中的记录</li><li>插入数据到新表中</li><li>关闭游标</li></ol><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create procedure p11(in uage int)begindeclare uname varchar(100);declare upro varchar(100);declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;drop table if exists tb_user_pro;create table if not exists tb_user_pro(id int primary key auto_increment,name varchar(100),profession varchar(100));open u_cursor;while true dofetch u_cursor into uname,upro;insert into tb_user_pro values (null, uname, upro);end while;close u_cursor;end;call p11(30);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述的存储过程在调用过程中会报错，是因为 while 循环中并没有退出条件，当游标的数据集获取完毕之后，再次获取数据，就会报错，从而终止了程序的执行，但是此时，tb_user_pro表结构及其数据都已经插入成功了，我们可以直接刷新表结构，检查表结构中的数据</p><p>上述的功能，虽然我们实现了，但是逻辑并不完善，而且程序执行完毕，获取不到数据，数据库还报错。要想解决这个问题，就需要通过MySQL中提供的 条件处理程序 Handler 来解决。</p><h3 id="2-11-条件处理程序"><a href="#2-11-条件处理程序" class="headerlink" title="2.11 条件处理程序"></a>2.11 条件处理程序</h3><h4 id="2-11-1-介绍"><a href="#2-11-1-介绍" class="headerlink" title="2.11.1 介绍"></a>2.11.1 介绍</h4><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DECLARE handler_action HANDLER FOR condition_value [, condition_value] ... statement ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>handler_action 的取值：<ul><li>CONTINUE: 继续执行当前程序</li><li>EXIT: 终止执行当前程序</li></ul></li><li>condition_value 的取值：<ul><li>SQLSTATE sqlstate_value：状态码，如 02000</li><li>SQLWARNING：所有以01开头的SQLSTATE代码的简写</li><li>NOT FOUND： 所有以02开头的SQLSTATE代码的简写</li><li>SQLEXCEPTION：所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写</li></ul></li></ul><h4 id="2-11-2-案例"><a href="#2-11-2-案例" class="headerlink" title="2.11.2 案例"></a>2.11.2 案例</h4><p>根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名（name）和专业（profession），并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中。</p><p>通过 SQLSTATE 指定具体的状态码：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create procedure p11(in uage int)begindeclare uname varchar(100);declare upro varchar(100);declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出declare exit handler for SQLSTATE '02000' close u_cursor;drop table if exists tb_user_pro;create table if not exists tb_user_pro(id int primary key auto_increment,name varchar(100),profession varchar(100));open u_cursor;while true dofetch u_cursor into uname,upro;insert into tb_user_pro values (null, uname, upro);end while;close u_cursor;end;call p11(30);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 SQLSTATE 的代码简写方式 NOT FOUND 02 开头的状态码，代码简写为 NOT FOUND</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create procedure p11(in uage int)begindeclare uname varchar(100);declare upro varchar(100);declare u_cursor cursor for select name,profession from tb_user where age &lt;= uage;-- 声明条件处理程序 ： 当SQL语句执行抛出的状态码为02000时，将关闭游标u_cursor，并退出declare exit handler for not found close u_cursor;drop table if exists tb_user_pro;create table if not exists tb_user_pro(id int primary key auto_increment,name varchar(100),profession varchar(100));open u_cursor;while true dofetch u_cursor into uname,upro;insert into tb_user_pro values (null, uname, upro);end while;close u_cursor;end;call p11(30);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>具体的错误状态码，可以参考官方文档：<br><a href="https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html">https://dev.mysql.com/doc/refman/8.0/en/declare-handler.html</a><br><a href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html</a></p></blockquote><h2 id="3-存储函数"><a href="#3-存储函数" class="headerlink" title="3. 存储函数"></a>3. 存储函数</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。具体语法如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE FUNCTION 存储函数名称 ([ 参数列表 ])RETURNS type [characteristic ...]BEGIN-- SQL语句RETURN ...;END ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>characteristic说明：</p><ul><li>DETERMINISTIC：相同的输入参数总是产生相同的结果</li><li>NO SQL ：不包含 SQL 语句。</li><li>READS SQL DATA：包含读取数据的语句，但不包含写入数据的语句</li></ul><h3 id="3-2-案例"><a href="#3-2-案例" class="headerlink" title="3.2 案例"></a>3.2 案例</h3><p>计算从1累加到n的值，n为传入的参数值。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create function fun1(n int)returns int deterministicbegindeclare total int default 0;while n&gt;0 doset total := total + n;set n := n - 1;end while;return total;end;select fun1(50);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>在mysql8.0版本中binlog默认是开启的，一旦开启了，mysql就要求在定义存储过程时，需要指定 characteristic特性，否则就会报错</p></blockquote><h2 id="4-触发器"><a href="#4-触发器" class="headerlink" title="4. 触发器"></a>4. 触发器</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p>触发器是与表有关的数据库对象，指在<code>insert/update/delete</code>之前(<code>BEFORE</code>)或之后(<code>AFTER</code>)，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性, 日志记录 , 数据校验等操作 。</p><p>使用别名<code>OLD</code>和<code>NEW</code>来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><table><thead><tr><th>触发器类型</th><th>NEW 和 OLD</th></tr></thead><tbody><tr><td>INSERT 型</td><td>NEW 白哦是将要或者已经新增的数据</td></tr><tr><td>UPDATE 型</td><td>OLD 表示修改之前的数据，NEW 白哦是将要或已经修改后的数据</td></tr><tr><td>DELETE 型</td><td>OLD 表示将要或已经删除的数据</td></tr></tbody></table><h3 id="4-2-语法"><a href="#4-2-语法" class="headerlink" title="4.2 语法"></a>4.2 语法</h3><p><strong>创建：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TRIGGER trigger_nameBEFORE/AFTER INSERT/UPDATE/DELETEON tbl_name FOR EACH ROW -- 行级触发器BEGINtrigger_name;END;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SHOW TRIGGERS;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP TRIGGER [schema_name.]trigger_name; --如果没有指定 schema_name，默认当前数据库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL--锁</title>
      <link href="/tur-study/2023/01/04/MySQL/MySQL--%E9%94%81/"/>
      <url>/tur-study/2023/01/04/MySQL/MySQL--%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>MySQL 中的锁按照锁的粒度，分为以下三类：</p><ul><li>全局锁：锁定数据库中的所有表</li><li>表级锁：每次操作锁住整张表</li><li>行级锁：每次操作锁住对应的行数据</li></ul><h2 id="2-全局锁"><a href="#2-全局锁" class="headerlink" title="2. 全局锁"></a>2. 全局锁</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的 DML 的写语句、DDL 语句、以及更新操作的事务提交语句都将被阻塞</p><p>典型的使用场景是做全库的逻辑备份，对所有表进行锁定，从而获取一致性视图，保证数据的完整性</p><p>为什么全局逻辑备份需要加全局锁？</p><p>示例演示：全局逻辑备份不加全局锁</p><p>假设在数据库中存在这样三张表: tb_stock 库存表，tb_order 订单表，tb_orderlog 订单日志表</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171926074.png" alt="image-20230517192559900"></p><ol><li>在进行数据备份时，先备份了tb_stock库存表。</li><li>然后接下来，在业务系统中，执行了下单操作，扣减库存，生成订单（更新tb_stock表，插入tb_order表）。</li><li>然后再执行备份 tb_order表的逻辑。</li><li>业务中执行插入订单日志操作。</li><li>最后，又备份了tb_orderlog表。</li></ol><p>此时备份出来的数据，是存在问题的。因为备份出来的数据，tb_stock表与tb_order表的数据不一致(有最新操作的订单信息,但是库存数没减)。</p><p>为了避免上述问题，需要借助 MySQL 的全局锁。加了全局锁之后：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171927971.png" alt="image-20230517192727914"></p><p>对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的DDL、 DML全部都处于阻塞状态，但是可以执行DQL语句，也就是处于只读状态，而数据备份就是查询操作。那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。</p><h3 id="2-2-语法"><a href="#2-2-语法" class="headerlink" title="2.2 语法"></a>2.2 语法</h3><p><strong>加全局锁：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">flush tables with read lock;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>数据备份：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqldump -uroot -p1234 test &gt; test.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>释放锁：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">unlock tables;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="2-3-特点"><a href="#2-3-特点" class="headerlink" title="2.3 特点"></a>2.3 特点</h3><p>数据库中加全局锁，是一个比较重的操作，存在以下问题：</p><ul><li>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。</li><li>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟</li></ul><p>在 InnoDB 引擎中，我们可以在备份时加上参数 <code>--single-transaction</code> 参数来完成不加锁的一致性数据备份</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqldump --single-transaction -uroot -p1234 test &gt; test.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-表级锁"><a href="#3-表级锁" class="headerlink" title="3. 表级锁"></a>3. 表级锁</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>表级锁，每次操作锁住整张表，锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在 MyISAM、InnoDB、BDB 等存储引擎中</p><p>对于表级锁，主要分为以下三类：</p><ul><li>表锁</li><li>元数据锁（meta data lock，MDL）</li><li>意向锁</li></ul><h3 id="3-2-表锁"><a href="#3-2-表锁" class="headerlink" title="3.2 表锁"></a>3.2 表锁</h3><p>对于表锁，分为两类：</p><ul><li>表共享读锁（read lock）</li><li>表独占写锁（write lock）</li></ul><p>语法：</p><ul><li>加锁：<code>lock tables 表名... read/write;</code></li><li>释放锁：<code>unlock tables / 客户端断开连接</code></li></ul><h4 id="3-2-1-读锁"><a href="#3-2-1-读锁" class="headerlink" title="3.2.1 读锁"></a>3.2.1 读锁</h4><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171938646.png" alt="image-20230517193853579"></p><p>左侧为客户端一，对指定表加了读锁，不会影响右侧客户端二的读，但是会阻塞右侧客户端的写</p><p>测试：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171939215.png" alt="image-20230517193932911"></p><h4 id="3-2-2-写锁"><a href="#3-2-2-写锁" class="headerlink" title="3.2.2 写锁"></a>3.2.2 写锁</h4><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171940036.png" alt="image-20230517194002960"></p><p>左侧为客户端一，对指定表加了写锁，会阻塞右侧客户端的读和写。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171940447.png" alt="image-20230517194032254"></p><p>结论：</p><ul><li>读锁不会阻塞其他客户端的读，但会阻塞全部客户端的锁，即自己客户端也不能写，只能读</li><li>写锁会阻塞其他客户端的读写，自己客户端可以读写</li></ul><h3 id="3-3-元数据锁"><a href="#3-3-元数据锁" class="headerlink" title="3.3 元数据锁"></a>3.3 元数据锁</h3><p>元数据锁（meta data lock，简写 MDL）</p><p>MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<strong>为了避免DML与DDL冲突，保证读写的正确性</strong></p><p>这里的元数据，可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的</p><p>在 MySQL5.5 中引入了 MDL，当对一张表进行增删改查的时候，加 MDL 读锁(共享)；当对表结构进行变更操作的时候，加MDL 写锁(排他)</p><table><thead><tr><th>对应 SQL</th><th>锁类型</th><th>说明</th></tr></thead><tbody><tr><td>lock tables xxx read / write</td><td>SHARED_READ_ONLY / SHARED_NO_READ_WRITE</td><td></td></tr><tr><td>select、select … lock in share mode</td><td>SHARED_READ</td><td>与 SHARED_READ、SHARED_WRITE  兼容，与 EXCLUSIVE 互斥</td></tr><tr><td>insert、update、delete、select … for update</td><td>SHARED_WRITE</td><td>与 SHARED_READ、SHARED_WRITE  兼容，与 EXCLUSIVE 互斥</td></tr><tr><td>alter table …</td><td>EXCLUSIVE</td><td>与其他的 MDL 互斥</td></tr></tbody></table><p>演示：</p><p>当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ / SHARED_WRITE），之间是兼容的</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172009513.png" alt="image-20230517200932241"></p><p>当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁（EXCLUSIVE），之间是互斥的</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172010935.png" alt="image-20230517201006703"></p><p>可以通过下面的SQL，来查看数据库中的元数据锁的情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select object_type,object_schema,object_name,lock_type,lock_duration from performance_schema.metadata_locks ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们在操作过程中，可以通过上述的SQL语句，来查看元数据锁的加锁情况。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172011549.png" alt="image-20230517201122424"></p><h3 id="3-4-意向锁"><a href="#3-4-意向锁" class="headerlink" title="3.4 意向锁"></a>3.4 意向锁</h3><h4 id="3-4-1-介绍"><a href="#3-4-1-介绍" class="headerlink" title="3.4.1 介绍"></a>3.4.1 介绍</h4><p>为了避免 DML 在执行时，加的行锁与表锁冲突，在 InnoDB 中引入意向锁，是的表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查</p><p>演示：</p><p>假如没有意向锁，客户端一对表加了行锁后，客户端二如何给表加表锁呢，来通过示意图简单分析一下：</p><ol><li><p>首先客户端一，开启一个事务，然后执行DML操作，在执行DML语句时，会对涉及到的行加行锁。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172014656.png" alt="image-20230517201429553"></p></li><li><p>当客户端二，想对这张表加表锁时，会检查当前表是否有对应的行锁，如果没有，则添加表锁，此时就会从第一行数据，检查到最后一行数据，效率较低</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172014069.png" alt="image-20230517201456998"></p></li></ol><p>有了意向锁之后 :</p><ol><li><p>客户端一，在执行DML操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172015680.png" alt="image-20230517201533591"></p></li><li><p>而其他客户端，在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172016169.png" alt="image-20230517201601094"></p></li></ol><h4 id="3-4-2-分类"><a href="#3-4-2-分类" class="headerlink" title="3.4.2 分类"></a>3.4.2 分类</h4><ul><li>意向共享锁（IS）：由语句 <code>select … lock in share mode</code> 添加。与表锁共享锁（read）兼容，与表锁排他锁（write）互斥</li><li>意向排他锁（IX）：由 <code>insert、update、delete、select … for update</code> 添加，与表锁共享锁（read）及排他锁（write）互斥，意向锁之间不会互斥</li></ul><blockquote><p>一旦事务提交了，意向共享锁、意向排他锁都会自动释放</p></blockquote><p>可以通过以下 SQL，查看意向锁及行锁的加锁情况</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>演示：</p><ul><li><p>意向共享锁与表读锁是兼容的</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172024610.png" alt="image-20230517202443341"></p></li><li><p>意向排他锁与表读锁、写锁都是互斥的</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172025488.png" alt="image-20230517202530766"></p></li></ul><h2 id="4-行级锁"><a href="#4-行级锁" class="headerlink" title="4. 行级锁"></a>4. 行级锁</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p>行级锁，每次操作锁住对应的行数据，锁定粒度最小，发生所冲突的概率最低，并发度最高，应用在 InnoDB 存储引擎中</p><p>InnoDB 的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加锁。</p><p>对于行级锁，主要分为以下三类：</p><ul><li><p>行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此进行 update、delete。在 RC、RR 隔离级别下都支持</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172032232.png" alt="image-20230517203204176"></p></li><li><p>间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行 insert，产生幻读。在 RR 隔离级别下都支持</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172033848.png" alt="image-20230517203323798"></p></li><li><p>临键锁（Next-Key Lock）：行锁和间隙锁的组合，同时锁住数据，并锁住数据前面的间隙 Gap。在 RR 隔离级别下支持</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172034128.png" alt="image-20230517203425074"></p></li></ul><blockquote><p>幻读：指当事务不是独立执行时发生的一种现象</p><p><strong>基本概念</strong></p><p>事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。</p><p>幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。</p><p>在数据库定义的四种<a href="https://baike.baidu.com/item/%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB?fromModule=lemma_inlink">隔离级别</a>中，最高隔离级别SERIALIZABLE_READ可以保证不出现幻读的问题。</p><p>Repeatable Read (RR) 针对当前读，RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)，不存在幻读现象。</p></blockquote><h3 id="4-2-行锁"><a href="#4-2-行锁" class="headerlink" title="4.2 行锁"></a>4.2 行锁</h3><h4 id="4-2-1-介绍"><a href="#4-2-1-介绍" class="headerlink" title="4.2.1 介绍"></a>4.2.1 介绍</h4><p>InnoDB 实现了以下两种类型的行锁：</p><ul><li>共享锁（S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁</li><li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共线锁和排他锁</li></ul><p>两种行锁的兼容情况如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172038461.png" alt="image-20230517203804392"></p><p>常见的 SQL 语句，在执行时所加的行锁如下：</p><table><thead><tr><th>SQL</th><th>行锁类型</th><th>说明</th></tr></thead><tbody><tr><td>INSERT ….</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>UPDATE …</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>DELETE ….</td><td>排他锁</td><td>自动加锁</td></tr><tr><td>SELECT(正常)</td><td>不加人和所</td><td></td></tr><tr><td>SELECT … LOCK  IN SHARE MODE</td><td>共享锁</td><td>需要手动在 SELECT 之后加 LOCK IN SHARE MODE</td></tr><tr><td>SELECt … FOR UPDATE</td><td>排他锁</td><td>需要手动在 SELECT 之后加 FOR UPDATE</td></tr></tbody></table><h4 id="4-2-2-演示"><a href="#4-2-2-演示" class="headerlink" title="4.2.2 演示"></a>4.2.2 演示</h4><p>默认情况下，InnoDB 在 REPEATABLE READ （RR）事务隔离级别运行时，使用 next-key 锁进行搜索和索引扫描，以防止幻读</p><ul><li>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁</li><li>InnoDB 的行锁是针对于索引加的锁，不用做索引条件检索数据，那么 InnoDB 将对表中的所有数据加锁，此时就会升级为表锁</li></ul><p>可以通过以下SQL，查看意向锁及行锁的加锁情况：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>实例演示：</strong></p><p>数据准备：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE `stu` (`id` int NOT NULL PRIMARY KEY AUTO_INCREMENT,`name` varchar(255) DEFAULT NULL,`age` int NOT NULL) ENGINE = InnoDB CHARACTER SET = utf8mb4;INSERT INTO `stu` VALUES (1, 'tom', 1);INSERT INTO `stu` VALUES (3, 'cat', 3);INSERT INTO `stu` VALUES (8, 'rose', 8);INSERT INTO `stu` VALUES (11, 'jetty', 11);INSERT INTO `stu` VALUES (19, 'lily', 19);INSERT INTO `stu` VALUES (25, 'luci', 25);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>普通的 select 语句执行时不会加锁：</strong></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172107029.png" alt="image-20230517210700766"></p><p><strong>共享锁之间兼容：</strong></p><p><code>select...lock in share mode</code>，加共享锁，共享锁与共享锁之间兼容</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172111186.png" alt="image-20230517211158897"></p><p><strong>共享锁与排他锁之间互斥：</strong></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172114347.png" alt="image-20230517211402003"></p><p>客户端一获取的是id为1这行的共享锁，客户端二是可以获取id为3这行的排它锁的，因为不是同一行数据。 而如果客户端二想获取id为1这行的排他锁，会处于阻塞状态，因为共享锁与排他锁之间互斥</p><p><strong>排他锁与排他锁之间互斥：</strong></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172115089.png" alt="image-20230517211532947"></p><p>当客户端一，执行update语句，会为id为1的记录加排他锁； 客户端二，如果也执行update语句更新id为1的数据，也要为id为1的数据加排他锁，但是客户端二会处于阻塞状态，因为排他锁之间是互斥的。 直到客户端一，把事务提交了，才会把这一行的行锁释放，此时客户端二，解除阻塞</p><p><strong>无索引行锁升级为表锁：</strong></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172116815.png" alt="image-20230517211641570"></p><p>在客户端一中，开启事务，并执行update语句，更新name为Lily的数据，也就是id为19的记录 。然后在客户端二中更新id为3的记录，却不能直接执行，会处于阻塞状态，为什么呢？</p><p>原因就是因为此时客户端一根据name字段进行更新时，name字段是没有索引的，如果没有索引，此时行锁会升级为表锁（因为行锁是对索引项加的锁，而name没有索引）</p><p>针对name字段建立索引后：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172119385.png" alt="image-20230517211915107"></p><p>此时我们可以看到，客户端一，开启事务，然后依然是根据name进行更新。而客户端二，在更新id为3的数据时，更新成功，并未进入阻塞状态。 这样就说明，我们根据索引字段进行更新操作，就可以避免行锁升级为表锁的情况</p><h3 id="4-3-间隙锁-amp-临键锁"><a href="#4-3-间隙锁-amp-临键锁" class="headerlink" title="4.3 间隙锁 &amp; 临键锁"></a>4.3 间隙锁 &amp; 临键锁</h3><p>默认情况下，InnoDB 在 <code>REPEATABLE READ</code>事务隔离级别运行，InnoDB使用 <code>next-key</code> 锁进行搜索和索引扫描，以防止幻读。</p><ul><li>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁 。</li><li>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，<code>next-key lock </code>退化为间隙锁。</li><li>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止。</li></ul><blockquote><p>==注意：==间隙锁唯一目的是防止其他事务插入间隙，间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一个间隙上采用间隙锁</p></blockquote><p><strong>示例演示：</strong></p><p>索引上的等值查询(唯一索引)，给不存在的记录加锁时, 优化为间隙锁：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172147928.png" alt="image-20230517214732573"></p><p>索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁</p><blockquote><p>介绍分析一下：我们知道InnoDB的B+树索引，叶子节点是有序的双向链表。 假如，我们要根据这个二级索引查询值为18的数据，并加上共享锁，我们是只锁定18这一行就可以了吗？ 并不是，因为是非唯一索引，这个结构中可能有多个18的存在，所以，在加锁时会继续往后找，找到一个不满足条件的值（当前案例中也就是29）。此时会对18加临键锁，并对29之前的间隙加锁。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172149582.png" alt="image-20230517214943499"></p></blockquote><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172150066.png" alt="image-20230517215010750"></p><p>索引上的范围查询(唯一索引)–会访问到不满足条件的第一个值为止：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305172151284.png" alt="image-20230517215123055"></p><p>查询的条件为id&gt;=19，并添加共享锁。 此时我们可以根据数据库表中现有的数据，将数据分为三个部<br>分：[19]、(19,25]、(25,+∞]。所以数据库数据在加锁是，就是将19加了行锁，25的临键锁（包含25及25之前的间隙），正无穷的临键锁(正无穷及之前的间隙)</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL--SQL 优化</title>
      <link href="/tur-study/2023/01/03/MySQL/MySQL--SQL-%E4%BC%98%E5%8C%96/"/>
      <url>/tur-study/2023/01/03/MySQL/MySQL--SQL-%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1. 插入数据"></a>1. 插入数据</h2><h3 id="1-1-insert"><a href="#1-1-insert" class="headerlink" title="1.1 insert"></a>1.1 insert</h3><p>一次性往数据库表中插入多条数据时，可从以下三个方面优化：</p><p><strong>批量插入数据：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">INSERT INTO tb_test values(1, 'Tome'), (2, 'Cat'), (3, 'Jerry');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>手动控制事务：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">start transaction;insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');insert into tb_test values(4,'Tom'),(5,'Cat'),(6,'Jerry');insert into tb_test values(7,'Tom'),(8,'Cat'),(9,'Jerry');commit;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>主键顺序插入</strong></p><p>主键顺序插入的性能要高于乱序插入</p><pre class="line-numbers language-none"><code class="language-none">主键乱序插入 : 8 1 9 21 88 2 4 15 89 5 7 3主键顺序插入 : 1 2 3 4 5 7 8 9 15 21 88 89<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-2-大批量插入数据"><a href="#1-2-大批量插入数据" class="headerlink" title="1.2 大批量插入数据"></a>1.2 大批量插入数据</h3><p>如果一次性需要插入大批量数据(比如: 几百万的记录)，使用 insert 语句插入性能较低，此时可以使用MySQL数据库提供的 <code>load </code>指令进行插入。操作如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171448093.png" alt="image-20230517144854966"></p><p>可以执行如下指令，将数据脚本文件中的数据加载到表结构中：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 客户端连接服务端时，加上参数 --local-infile 开启允许本地加载数据mysql --local-infile -uroot -p-- 设置全局参数 local-infile 为1，开启从本地加载文件导入数据开关set global local_infile = 1;-- 执行 load 命令将准备好的数据加载到表结构load data local infile '/root/sql1.log' into table tb_user fields terminated by ',' lines terminated by '\n';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>本地数据文件中的数据建议是主键顺序的，提高插入性能</p></blockquote><h2 id="2-主键优化"><a href="#2-主键优化" class="headerlink" title="2. 主键优化"></a>2. 主键优化</h2><h3 id="2-1-数据组织结构"><a href="#2-1-数据组织结构" class="headerlink" title="2.1 数据组织结构"></a>2.1 数据组织结构</h3><p>在 InnoDB 存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表成为索引组织表</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171517306.png" alt="image-20230517151727248"></p><p>行数据，都是存储在聚集索引的叶子节点上的，而 InnoDB 的逻辑结构图：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171518444.png" alt="image-20230517151830383"></p><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接</p><h3 id="3-2-页分裂"><a href="#3-2-页分裂" class="headerlink" title="3.2 页分裂"></a>3.2 页分裂</h3><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列</p><h4 id="3-2-1-主键顺序插入效果"><a href="#3-2-1-主键顺序插入效果" class="headerlink" title="3.2.1 主键顺序插入效果"></a>3.2.1 主键顺序插入效果</h4><ol><li><p>从磁盘中申请页，主键顺序插入</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171547203.png" alt="image-20230517154757040"></p></li><li><p>第一个页没有满，继续往第一页插入</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171548279.png" alt="image-20230517154819223"></p></li><li><p>当第一个也写满之后，再写入第二个页，页与页之间会通过指针连接</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171548052.png" alt="image-20230517154846003"></p></li><li><p>当第二页写满了，再往第三页写入</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171549346.png" alt="image-20230517154913298"></p></li></ol><h4 id="3-2-2-主键乱序插入效果"><a href="#3-2-2-主键乱序插入效果" class="headerlink" title="3.2.2 主键乱序插入效果"></a>3.2.2 主键乱序插入效果</h4><ol><li><p>加入1#,2#页都已经写满了，存放了如图所示的数据</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171549009.png" alt="image-20230517154954945"></p></li><li><p>此时再插入id为50的记录，不会再次开启一个页，将数据写入新的页中，因为索引结构的叶子节点是由顺序的，50 应该存储在 47 之后，而 47 所在的 #1 页已经写满，此时会开辟新的页 #3， 将 #1 页后一半的数据移动到 #3 页，再在 #3 页中插入 50</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171552666.png" alt="image-20230517155241574"></p></li><li><p>移动数据，并插入id为50的数据之后，那么此时，这三个页之间的数据顺序是有问题的。 1#的下一个页，应该是3#， 3#的下一个页是2#。 所以，此时，需要重新设置链表指针</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171553841.png" alt="image-20230517155311786"></p></li></ol><p>上述的这种现象，称之为 “<strong>页分裂</strong>“，是比较耗费性能的操作。</p><h4 id="3-2-3-页合并"><a href="#3-2-3-页合并" class="headerlink" title="3.2.3 页合并"></a>3.2.3 页合并</h4><p>示例演示如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171619018.png" alt="image-20230517161901782"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171619172.png" alt="image-20230517161917100"></p><blockquote><p>知识小贴士：<code>MERGE_THRESHOLD</code>：合并页的阈值，可以自己设置，在创建表或者创建索引时指定</p></blockquote><h4 id="3-2-4-索引设计原则"><a href="#3-2-4-索引设计原则" class="headerlink" title="3.2.4 索引设计原则"></a>3.2.4 索引设计原则</h4><ul><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用<code>AUTO_INCREMENT</code>自增主键。</li><li>尽量不要使用<code>UUID</code>做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改</li></ul><h2 id="3-order-by-优化"><a href="#3-order-by-优化" class="headerlink" title="3. order by 优化"></a>3. order by 优化</h2><p>MySQL 的排序由以下两种方式：</p><ul><li><code>Using filesort</code>：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 <code>sort buffer </code>中完成排序操作，所有不是通过索引直接返回排序结构的排序豆角 <code>FileSort </code>排序</li><li><code>Using index</code>：通过有序索引扫描直接返回有序数据，不需要额外排序，操作效率高</li></ul><p>对于以上的两种排序方式，<code>Using index</code>的性能高，而<code>Using filesort</code>的性能低，我们在优化排序操作时，尽量要优化为 <code>Using index</code></p><p>实例演示：</p><p>tb_user 表中字段无索引，此时进行排序：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171627747.png"></p><p><strong>升序排序：</strong></p><p>为 age、phone 字段创建索引：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 创建索引create index idx_user_age_phone_aa on tb_user(age,phone);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再次根据 age、phone 进行排序：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171629783.png" alt="image-20230517162906691"></p><p>建立索引之后，再次进行排序查询，就由原来的Using filesort， 变为了 Using index，性能就是比较高的了</p><p><strong>降序排序：</strong></p><p>创建索引后，根据age, phone进行降序排序：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171629254.png" alt="image-20230517162940167"></p><p>也出现 Using index， 但是此时Extra中出现了 Backward index scan，这个代表反向扫描索引，因为在MySQL中我们创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan。 在 MySQL8版本中，支持降序索引，我们也可以创建降序索引。</p><p><strong>遵循最左前缀法则：</strong></p><p>根据phone，age进行升序排序，phone在前，age在后：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171630617.png" alt="image-20230517163025524"></p><p>排序时,也需要满足<strong>最左前缀法则</strong>,否则也会出现 filesort。因为在创建索引的时候， age是第一个字段，phone是第二个字段，所以排序时，也就该按照这个顺序来，否则就会出现 Using filesort</p><p><strong>联合索引字段排序方式不同：</strong></p><p>根据age, phone进行降序一个升序，一个降序：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171633724.png" alt="image-20230517163306611"></p><p>因为创建索引时，如果未指定顺序，默认都是按照升序排序的，而查询时，一个升序，一个降序，此时就会出现Using filesort</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171633792.png" alt="image-20230517163326698"></p><p>为了解决上述的问题，可以创建一个索引，这个联合索引中 age 升序排序，phone 倒序排序。</p><p><strong>自定义排序方式的联合索引：</strong></p><p>创建联合索引(age 升序排序，phone 倒序排序)</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create index idx_user_age_phone_ad on tb_user(age asc ,phone desc);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171634935.png" alt="image-20230517163427836"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171634031.png" alt="image-20230517163438951"></p><p>升序/降序联合索引结构图示:</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171635610.png" alt="image-20230517163531562"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171635162.png" alt="image-20230517163509074"></p><p>由上述的测试,可以得出order by优化原则:</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li><li>尽量使用覆盖索引。</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)</li></ul><h2 id="4-group-by-优化"><a href="#4-group-by-优化" class="headerlink" title="4. group by 优化"></a>4. group by 优化</h2><p>在分组操作中，主要通过以下两点进行优化，以提升性能：</p><ul><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>实例演示：在 tb_user 表中基于 profession、age、status 进行分组</p><ul><li>当 profession 、age、status 没有联合索引时</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171643200.png" alt="image-20230517164311118"></p><ul><li>为 profession、age、status 建立索引后：</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171643072.png" alt="image-20230517164350976"></p><ul><li>最左前缀法则的演示</li></ul><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171644568.png" alt="image-20230517164421422"></p><p>如果仅仅根据age分组，就会出现 Using temporary ；而如果是 根据 profession,age两个字段同时分组，则不会出现 Using temporary。原因是因为对于分组操作，在联合索引中，也是符合最左前缀法则的</p><h2 id="5-limit-优化"><a href="#5-limit-优化" class="headerlink" title="5. limit 优化"></a>5. limit 优化</h2><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低</p><p>limit 分页查询存在的问题：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171656115.png" alt="image-20230517165603008"></p><p>通过测试可以看到，越往后，分页查询效率越低，这就是分页查询的问题所在。<br>因为，当在进行分页查询时，如果执行 limit 2000000,10 ，此时需要MySQL排序前2000010 记录，仅仅返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大</p><p><strong>优化思路：</strong>一般分页查询时，通过创建<font color="red">覆盖索引</font>能够比较好的提高性能，可以通过<font color="red">覆盖索引加子查询</font>的形式进行优化</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_sku t, (select id from tb_sku order by id limit 2000000, 10) a where t.id = a.id;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-count-优化"><a href="#6-count-优化" class="headerlink" title="6. count 优化"></a>6. count 优化</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>在数据量很大时，执行 count 操作时非常耗时的，如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171803942.png" alt="image-20230517180304888"></p><p>上述演示是在 InnoDB 存储引擎下的。<code>InnoDB </code>执行 <code>count(*)</code> 时是将数据一行一行的从引擎里读取出来，然后累计计数。</p><blockquote><p>知识小贴士：MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行<code>count(*)</code>的时候会直接返回这个数，效率很高； 但是如果是带条件的 count，MyISAM也慢。</p></blockquote><p>如果说要大幅度提升InnoDB表的count效率，主要的优化思路：自己计数(可以借助于redis这样的数据库进行,但是如果是带条件的count又比较麻烦了)。</p><h3 id="6-2-count-用法"><a href="#6-2-count-用法" class="headerlink" title="6.2 count 用法"></a>6.2 count 用法</h3><p>count 是一个聚合函数，对于返回的结果集一行行的判断。如果 count 函数的参数不是 NULL，累计值就加1，否则不加，最后返回累计值</p><p>用法：<code>count(*)、count(主键)、count(字段)、count(数字)</code></p><table><thead><tr><th>count 用法</th><th>含义</th></tr></thead><tbody><tr><td>count(主键)</td><td>InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)</td></tr><tr><td>count(字段)</td><td>1. 没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。<br>2. 有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</td></tr><tr><td>count(数字)</td><td>InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字 “1” 进去，直接按行进行累加。</td></tr><tr><td>count(*)</td><td>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</td></tr></tbody></table><blockquote><p>按照效率排序：<code>count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</code>，所以尽量使用 <code>count(*)</code></p></blockquote><h2 id="7-update-优化"><a href="#7-update-优化" class="headerlink" title="7. update 优化"></a>7. update 优化</h2><p>主要需要注意一下update语句执行时的注意事项。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">update course set name = 'javaEE' where id = 1 ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当我们在执行删除的SQL语句时，会锁定id为1这一行的数据，然后事务提交之后，行锁释放。</p><p>但是当我们在执行如下SQL时。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">update course set name = 'SpringBoot' where name = 'PHP' ;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>当我们开启多个事务，在执行上述的SQL时，我们发现行锁升级为了表锁。 导致该update语句的性能大大降低。</p><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL--索引</title>
      <link href="/tur-study/2023/01/02/MySQL/MySQL--%E7%B4%A2%E5%BC%95/"/>
      <url>/tur-study/2023/01/02/MySQL/MySQL--%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-索引概述"><a href="#1-索引概述" class="headerlink" title="1. 索引概述"></a>1. 索引概述</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>索引（index）是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161612378.png" alt="image-20230516161240293"></p><h3 id="1-2-演示"><a href="#1-2-演示" class="headerlink" title="1.2 演示"></a>1.2 演示</h3><p>表结构机器数据如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161613176.png" alt="image-20230516161330137"></p><p>假如我们要执行的SQL语句为 ： <code>select * from user where age = 45;</code></p><h4 id="1-2-1-无索引情况"><a href="#1-2-1-无索引情况" class="headerlink" title="1.2.1 无索引情况"></a>1.2.1 无索引情况</h4><p>在无索引情况下，就需要从第一行开始扫描，一直扫描到最后一行，称之为 <strong>全表扫描</strong>，性能很低。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161614985.png" alt="image-20230516161456931"></p><h4 id="1-2-2-有索引情况"><a href="#1-2-2-有索引情况" class="headerlink" title="1.2.2 有索引情况"></a>1.2.2 有索引情况</h4><p>如果我们针对于这张表建立了索引，假设索引结构就是二叉树（但实际上不会用二叉树，而是B+树，这里只为演示索引的作用），那么也就意味着，会对 age 这个字段建立一个二叉树的索引结构</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161617528.png" alt="image-20230516161752462"></p><p>此时我们在进行查询时，只需要扫描三次就可以找到数据了，极大的提高的查询的效率。</p><h3 id="1-3-特点"><a href="#1-3-特点" class="headerlink" title="1.3 特点"></a>1.3 特点</h3><table><thead><tr><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>提高数据检索的效率，降低数据库的IO成本</td><td>索引列也是要占用空间的</td></tr><tr><td>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</td><td>索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时，效率降低</td></tr></tbody></table><h2 id="2-索引结构"><a href="#2-索引结构" class="headerlink" title="2. 索引结构"></a>2. 索引结构</h2><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>MySQL 的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：</p><table><thead><tr><th>索引结构</th><th>描述</th></tr></thead><tbody><tr><td>B+Tree</td><td>最常见的索引类型，大部分引擎都支持 B+ 树索引</td></tr><tr><td>Hash</td><td>底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询</td></tr><tr><td>R-tree（空间索引）</td><td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-text（全文索引）</td><td>是一种通过建立<strong>倒排索引</strong>，快速匹配文档的方式。类似于Lucene,Solr,ES</td></tr></tbody></table><p>不同的存储引擎对于索引结构的支持情况如下：</p><table><thead><tr><th>索引</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash</td><td>不支持</td><td>不支持</td><td>支持</td></tr><tr><td>R-tree</td><td>不支持</td><td>支持</td><td>不支持</td></tr><tr><td>Full-text</td><td>5.6 之后支持</td><td>支持</td><td>不支持</td></tr></tbody></table><blockquote><p>若无特别说明，索引一般指 B+Tree 索引</p></blockquote><h3 id="2-2-二叉树"><a href="#2-2-二叉树" class="headerlink" title="2.2 二叉树"></a>2.2 二叉树</h3><p>假如说MySQL的索引结构采用二叉树的数据结构，比较理想的结构如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161629458.png"></p><p>但如果主键是顺序插入的，就会形成单向链表，：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161629701.png"></p><p>所以，如果选择二叉树作为索引结构，会存在以下缺点：</p><ul><li>顺序插入时，会形成一个链表，查询性能大大降低。</li><li>大数据量情况下，层级较深，检索速度慢。</li></ul><p>此时可能有人会想到，我们可以选择红黑树，红黑树是一颗自平衡二叉树，那这样即使是顺序插入数据，最终形成的数据结构也是一颗平衡的二叉树,结构如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161631594.png" alt="image-20230516163106543"></p><p>但是，即使如此，由于红黑树也是一颗二叉树，所以也会存在一个缺点：大数据量情况下，层级较深，检索速度慢。<br>所以，在 MySQL 的索引结构中，并没有选择二叉树或者红黑树，而选择的是<code>B+Tree</code></p><p>介绍 B+Tree 前先了解一下 B-Tree</p><h3 id="2-3-B-Tree"><a href="#2-3-B-Tree" class="headerlink" title="2.3 B-Tree"></a>2.3 B-Tree</h3><p><code>B-Tree</code>，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。<br>以一颗最大度数（max-degree）为 5(5阶) 的 b-tree 为例，那这个 B 树每个节点最多存储 4 个 key，5个指针：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161634326.png" alt="image-20230516163418261"></p><blockquote><p>知识小贴士: 树的度数指的是一个节点的子节点个数。</p></blockquote><p>数据结构可视化网站演示：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161640752.png" alt="image-20230516164035675"></p><p>特点：</p><ul><li>5阶的B树，每一个节点最多存储4个key，对应5个指针。</li><li>一旦节点存储的key数量到达5，就会裂变，中间元素向上分裂。</li><li>在B树中，非叶子节点和叶子节点都会存放数据。</li></ul><h3 id="2-4-B-Tree"><a href="#2-4-B-Tree" class="headerlink" title="2.4 B+Tree"></a>2.4 B+Tree</h3><p>B+Tree是B-Tree的变种</p><p>以一颗最大度数（max-degree）为4（4阶）的b+tree为例，来看一下其结构示意图：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161642858.png" alt="image-20230516164256800"></p><ul><li>绿色框框起来的部分，是索引部分，仅仅起到索引数据的作用，不存储数据。</li><li>红色框框起来的部分，是数据存储部分，在其叶子节点中要存储具体的数据。</li></ul><p>数据结构可视化网站演示：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161647034.png" alt="image-20230516164748971"></p><p>B+Tree 与 B-Tree相比，主要有以下三点区别：</p><ul><li>所有的数据都会出现在叶子节点。</li><li>叶子节点形成一个单向链表。</li><li>非叶子节点仅仅起到索引数据作用，具体的数据都是在叶子节点存放的。</li></ul><p>上述是标准的 B+Tree 数据结构，而 MySQL 中对 B+Tree 进行了优化</p><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能，利于排序。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161649894.png" alt="image-20230516164957832"></p><h3 id="2-5-Hash"><a href="#2-5-Hash" class="headerlink" title="2.5 Hash"></a>2.5 Hash</h3><p>MySQL中除了支持B+Tree索引，还支持一种索引类型—Hash索引。</p><h4 id="2-5-1-结构"><a href="#2-5-1-结构" class="headerlink" title="2.5.1 结构"></a>2.5.1 结构</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在 hash 表中</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161703543.png" alt="image-20230516170330471"></p><p>如果两个(或多个)键值，映射到一个相同的槽位上，他们就产生了<strong>hash冲突</strong>（也称为hash碰撞），可以通过<strong>链表</strong>来解决</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161704869.png" alt="image-20230516170427793"></p><h4 id="2-5-2-特点"><a href="#2-5-2-特点" class="headerlink" title="2.5.2 特点"></a>2.5.2 特点</h4><ul><li><p>Hash 索引只能用于对等比较（<code>=，in</code>），不支持范围查询（<code>between，&gt;，&lt;，…</code>）</p></li><li><p>无法利用索引完成排序操作</p></li><li><p>查询效率高，通常（不存在 hash 冲突时）只需要一次检索就可以完成，效率通常要高于 B+Tree 索引</p></li></ul><h4 id="2-5-3-存储引擎支持"><a href="#2-5-3-存储引擎支持" class="headerlink" title="2.5.3 存储引擎支持"></a>2.5.3 存储引擎支持</h4><p>在 MySQL 中，支持 hash 索引的是 Memory 存储引擎。 而 InnoDB 中具有自适应hash功能，hash 索引是 InnoDB 存储引擎根据 B+Tree 索引在指定条件下自动构建的。</p><blockquote><p>为什么 InnoDB 选择使用 B+Tree 索引？</p><ul><li>相对于二叉树，层级更少，搜索效率高；</li><li>对于 B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；</li><li>相对 Hash 索引，B+tree 支持范围匹配及排序操作</li></ul></blockquote><h2 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3. 索引分类"></a>3. 索引分类</h2><h3 id="3-1-索引分类"><a href="#3-1-索引分类" class="headerlink" title="3.1 索引分类"></a>3.1 索引分类</h3><p>MySQL 中将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th><th>关键字</th></tr></thead><tbody><tr><td>主键索引</td><td>针对于表中主键创建的索引</td><td>默认自动创建，且只能由一个</td><td>PRIMARY</td></tr><tr><td>唯一索引</td><td>避免同一个表中某数据列中的值重复</td><td>可以有多个</td><td>UNIQUE</td></tr><tr><td>常规索引</td><td>快速定位特定数据</td><td>可以有多个</td><td></td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td>可以有多个</td><td>FULLTEXT</td></tr></tbody></table><h3 id="3-2-聚集索引-amp-二级索引"><a href="#3-2-聚集索引-amp-二级索引" class="headerlink" title="3.2 聚集索引 &amp; 二级索引"></a>3.2 聚集索引 &amp; 二级索引</h3><p>在 InnoDB 中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th>分类</th><th>含义</th><th>特点</th></tr></thead><tbody><tr><td>聚集索引</td><td>将数据存储与索引放到一块，索引结构的叶子结构保存行数据</td><td>必须有，且只能有一个</td></tr><tr><td>二级索引</td><td>将数据与索引分类存储，索引结构的叶子结点关联的是对应的主键</td><td>可以存在多个</td></tr></tbody></table><p>聚集索引的选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。</li><li>如果表没有主键，或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索<br>引</li></ul><p>聚集索引和二级索引的具体结构如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161719501.png" alt="image-20230516171905416"></p><ul><li>聚集索引的叶子节点下挂的是这一行的数据 。</li><li>二级索引的叶子节点下挂的是该字段值对应的主键值。</li></ul><p>结合实际执行 SQL 语句，具体的查找过程如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161720636.png" alt="image-20230516172046560"></p><p>具体过程如下：</p><ol><li>由于是根据 name 字段进行查询，所以先根据 name=’Arm’ 到 name 字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li><li>由于查询返回的数据是 <code>* </code>，所以此时，还需要根据主键值 10，到聚集索引中查找 10 对应的记录，最终找到 10 对应的行 row。</li><li>最终拿到这一行的数据，直接返回即可。</li></ol><blockquote><p>回表查询： 这种先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。</p></blockquote><blockquote><p>思考：以下两条SQL语句，那个执行效率高? 为什么?</p><ul><li>A. select * from user where id = 10 ;</li><li>B. select * from user where name = ‘Arm’ ;</li></ul><p>备注: id为主键，name字段创建的有索引</p><p>解释：A 语句的执行性能要高于B 语句。因为A语句直接走聚集索引，直接返回数据。 而B语句需要先查询name字段的二级索引，然后再查询聚集索引，也就是需要进行回表查询。</p></blockquote><blockquote><p>思考：InnoDB主键索引的B+tree高度为多高呢?</p><p>假设：一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。<br>高度为2：n * 8 + (n + 1) * 6 = 16 * 1024 , 算出n约为 1170。1171 * 16 = 18736。也就是说，如果树的高度为2，则可以存储 18000 多条记录。<br>高度为3：1171 * 1171 * 16 = 21939856。也就是说，如果树的高度为3，则可以存储 2200w 左右的记录。</p></blockquote><h2 id="4-索引语法"><a href="#4-索引语法" class="headerlink" title="4. 索引语法"></a>4. 索引语法</h2><p><strong>创建索引</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name,...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看索引</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SHOW INDEX FROM table_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除索引</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">DROP INDEX index_name ON table_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-SQL-性能分析"><a href="#5-SQL-性能分析" class="headerlink" title="5. SQL 性能分析"></a>5. SQL 性能分析</h2><h3 id="5-1-SQL-执行频率"><a href="#5-1-SQL-执行频率" class="headerlink" title="5.1 SQL 执行频率"></a>5.1 SQL 执行频率</h3><p>MySQL 客户端连接成功后，通过 <code>show [session|global] status</code> 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的<code>INSERT、UPDATE、DELETE、SELECT</code>的访问频次：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 查询 CRUD 的操作-- session 是查看当前会话-- global 是查询全局数据-- Com_______ 中下划线7个，匹配 insert、update、delete、selectSHOW GLOABL STATUS LIKE 'Com_______';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305162128819.png" alt="image-20230516212840747"></p><ul><li>Com_delete：删除次数</li><li>Com_insert：插入次数</li><li>Com_select：查询次数</li><li>Com_update：更新次数</li></ul><blockquote><p>通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，我们可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了</p></blockquote><p>如果数据库时以查询为主，该如何定位针对于那些查询语句进行优化？对于次数可以借助于慢查询日志</p><h3 id="5-2-慢查询日志"><a href="#5-2-慢查询日志" class="headerlink" title="5.2 慢查询日志"></a>5.2 慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL语句的日志。</p><p>MySQL的慢查询日志默认没有开启，可以查看一下系统变量 <code>slow_query_log</code></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show varilables like 'slow_query_log';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305162213922.png" alt="image-20230516221319824"></p><p>如果要开启慢查询日志，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息：</p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"># 开启 MySQL 慢查询日志开关slow_query_log=1# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志long_query_time=2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息<code> /var/lib/mysql/localhost-slow.log</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart mysqld<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305162215735.png" alt="image-20230516221554666"></p><p><strong>测试：</strong></p><p>执行如下 SQL 语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from tb_user; -- 这条SQL执行效率比较高, 执行耗时 0.00secselect count(*) from tb_sku; -- 由于tb_sku表中, 预先存入了1000w的记录, count一次,耗时13.35sec<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305162217976.png" alt="image-20230516221718900"></p><p>检查慢查询日志：在慢查询日志中，只会记录执行时间超多我们预设时间（2s）的SQL，执行较快的SQL是不会记录的</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305162218322.png" alt="image-20230516221817224"></p><p>这样，通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化</p><h3 id="5-3-profile-详情"><a href="#5-3-profile-详情" class="headerlink" title="5.3 profile 详情"></a>5.3 profile 详情</h3><p><code>show profiles</code> 可以显示 SQL 语句的耗时时间，帮助我们更好的做 SQL 优化。通过  <code>have_profiling</code> 参数，能够看到当前 MySQL 是否支持 <code>profile </code>操作</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 查询是否支持 profile 操作select @@have_profiles;-- 查询 profile 操作的开关状态select @@profiling;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305162226957.png" alt="image-20230516222622905"></p><p>可以看到，当前 MySQL 是支持 profile操作的，但是开关是关闭的。可以通过set 语句在 session/global 级别开启 profiling：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SET profiling = 1;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在执行一系列的业务 SQL 的操作后，通过如下指令查看 SQL 语句的执行耗时：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 查看每一条 SQL 的耗时基本情况show profiles;-- 查看指定 query_id 的 SQL 语句各个阶段的耗时情况show profile for query query_id;-- 查看指定 query_id 的 SQL 语句 CPU 的使用情况show profile cpu for query query_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305162233066.png" alt="image-20230516223350009"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305162234739.png" alt="image-20230516223414686"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305162234957.png" alt="image-20230516223426899"></p><h3 id="5-4-explain"><a href="#5-4-explain" class="headerlink" title="5.4 explain"></a>5.4 explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括 SELECT 语句执行过程中表如何连接和连接的顺序</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 直接在 select 语句前加上关键字 explain / descEXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305162237122.png" alt="image-20230516223741067"></p><p>Explain 执行计划中各个字段的含义:</p><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。</td></tr><tr><td>select_type</td><td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等</td></tr><tr><td>type</td><td>表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。</td></tr><tr><td>possible_key</td><td>显示可能应用在这张表上的索引，一个或多个。</td></tr><tr><td>key</td><td>实际使用的索引，如果为NULL，则没有使用索引。</td></tr><tr><td>key_len</td><td>表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好</td></tr><tr><td>rows</td><td>MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的</td></tr><tr><td>filtered</td><td>表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好</td></tr></tbody></table><h2 id="六、索引使用"><a href="#六、索引使用" class="headerlink" title="六、索引使用"></a>六、索引使用</h2><h3 id="6-1-验证索引效率"><a href="#6-1-验证索引效率" class="headerlink" title="6.1 验证索引效率"></a>6.1 验证索引效率</h3><h4 id="6-1-1-数据准备"><a href="#6-1-1-数据准备" class="headerlink" title="6.1.1 数据准备"></a>6.1.1 数据准备</h4><p>环境：表：tb_sku，数据量：1000w</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305170907707.png" alt="image-20230517090717587"></p><p>表结构：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE `tb_sku` (  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '商品id',  `sn` varchar(100) NOT NULL COMMENT '商品条码',  `name` varchar(200) NOT NULL COMMENT 'SKU名称',  `price` int(20) NOT NULL COMMENT '价格（分）',  `num` int(10) NOT NULL COMMENT '库存数量',  `alert_num` int(11) DEFAULT NULL COMMENT '库存预警数量',  `image` varchar(200) DEFAULT NULL COMMENT '商品图片',  `images` varchar(2000) DEFAULT NULL COMMENT '商品图片列表',  `weight` int(11) DEFAULT NULL COMMENT '重量（克）',  `create_time` datetime DEFAULT NULL COMMENT '创建时间',  `update_time` datetime DEFAULT NULL COMMENT '更新时间',  `category_name` varchar(200) DEFAULT NULL COMMENT '类目名称',  `brand_name` varchar(100) DEFAULT NULL COMMENT '品牌名称',  `spec` varchar(200) DEFAULT NULL COMMENT '规格',  `sale_num` int(11) DEFAULT '0' COMMENT '销量',  `comment_num` int(11) DEFAULT '0' COMMENT '评论数',  `status` char(1) DEFAULT '1' COMMENT '商品状态 1-正常，2-下架，3-删除',  PRIMARY KEY (`id`) USING BTREE) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品表';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>导入本地数据：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">load data local infile 'C:\\Users\\18517\\Desktop\\mysql-data\\tb_sku1.sql' into table `tb_sku` fields terminated by ',' lines terminated by '\n';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p><code>C:\\Users\\18517\\Desktop\\mysql-data\\tb_sku1.sql</code> 为本地数据的地址</p></blockquote><p>导入本地数据时可能会遇到如下错误：Loading local data is disabled； this must be enabled on both the client and server sides</p><p>这是因为<code>local_infile</code>服务器变量指示能否使用<code>load data local infile</code>命令。该变量为OFF时，禁用客户端的load data local infile命令，只要我们将该变量设置为ON时， 报错才会消失。</p><p>输入 <code>show global vartables like 'local_infile';</code> 查看local_infile服务器的变量是off还是on</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305170911291.png" alt="image-20230517091129229"></p><p>修改 local_infile 可以在当前命令行中修改，命令为 <code>set gloabl localinfile=1;</code>。但这是一次性的，关闭命令行后就会失效。要想永久性的修改，需要修改 mysql 目录下的 mysql.ini 文件：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305170914314.png" alt="image-20230517091423254"></p><p>在 mysql.ini 文件中<strong>在有[mysqld]，[mysql]字样的下一行加上local_infile=ON命令</strong></p><pre class="line-numbers language-ini" data-language="ini"><code class="language-ini">[mysqld]local_infile=ON[mysql]local_infile=ON <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>修改完后重启 MySQL 服务即可</p><p>数据全部导入后，tb_sku 表中有 1000w 条数据：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305170918391.png" alt="image-20230517091811334"></p><h4 id="6-1-2-索引效率验证"><a href="#6-1-2-索引效率验证" class="headerlink" title="6.1.2 索引效率验证"></a>6.1.2 索引效率验证</h4><p><strong>主键索引</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from tb_sku where id = 10000000;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305170922297.png" alt="image-20230517092257239"></p><p>可以看到即使有1000w的数据，根据id进行数据查询，性能依然很快，因为主键id是有索引的</p><p><strong>二级索引</strong></p><p>根据 sn 字段进行查询，执行如下 SQL：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SELECT * FROM tb_sku WHERE sn = '100000003145001';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171248769.png" alt="image-20230517124104070"></p><p>可以看到根据sn字段进行查询，查询返回了一条数据，结果耗时18.421s，就是因为 sn 没有索引，而造成查询效率很低。</p><p>那么我们可以针对于 sn 字段，建立一个索引，建立了索引之后，我们再次根据 sn 进行查询，再来看一下查询耗时情况。</p><p>创建索引：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE INDEX idx_sku_sn on tb_sku(sn);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171248745.png" alt="image-20230517124414850"></p><p>再次执行相同的 SQL 语句：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171248758.png" alt="image-20230517124441794"></p><p>可以看到， sn 字段建立索引之后，查询耗时仅仅需要 0.002s，相比 18.421s，查询性能大大提升</p><h3 id="6-2-最左前缀法则"><a href="#6-2-最左前缀法则" class="headerlink" title="6.2 最左前缀法则"></a>6.2 最左前缀法则</h3><p>如果索引了多列（联合索引），要遵循最左前缀法则。</p><p>最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列，如果跳跃某一列，索引将会部分失效（后面的字段索引失效）</p><p>以 tb_user 表为例，tb_user 表所创建的索引如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171249149.png" alt="image-20230517124945962"></p><p>在 tb_user 表中，有一个联合索引，这个联合索引涉及到三个字段，顺序分别为：profession，age，status</p><p>对于最左前缀法则指的是，查询时，最左变的列，也就是profession必须存在，否则索引全部失效。而且中间不能跳过某一列，否则该列后面的字段索引将失效。</p><p>示例演示如下：</p><p><strong>最左前缀法则验证：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user where profession = '软件工程' and age = 31 and status = '0';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171251723.png" alt="image-20230517125115595"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user where profession = '软件工程' and age = 31;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171251339.png" alt="image-20230517125154212"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user where profession = '软件工程';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171252730.png" alt="image-20230517125219607"></p><p>以上的这三组测试中，我们发现只要联合索引最左边的字段 profession存在，索引就会生效，只不过索引的长度不同。 而且由以上三组测试，我们也可以推测出 profession 字段索引长度为47、age 字段索引长度为2、status字段索引长度为5</p><p><strong>最左前缀法则失效：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user where age = 31 and status = '0';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171253307.png" alt="image-20230517125308208"></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user where status = '0';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171253841.png" alt="image-20230517125334724"></p><p>而通过上面的这两组测试，我们也可以看到索引并未生效，原因是因为不满足最左前缀法则，联合索引最左边的列profession不存在</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user where profession = '软件工程' and status = '0';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171254417.png" alt="image-20230517125413300"></p><p>上述的SQL查询时，存在profession字段，最左边的列是存在的，索引满足最左前缀法则的基本条件。但是查询时，跳过了age这个列，所以后面的列索引是不会使用的，也就是索引部分生效，所以索引的长度就是47</p><p><strong>SQL 语句的字段顺序的影响：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user where age = 31 and status = '0' and profession = '软件工程'；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171255063.png" alt="image-20230517125515940"></p><p>可以看到，当 SQL 语句的字段顺序与索引的字段不一致时没有影响，依旧是完全满足最左前缀法则的，索引长度54，联合索引是生效的。</p><blockquote><p>注意 ： 最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。</p></blockquote><h3 id="6-3-范围查询"><a href="#6-3-范围查询" class="headerlink" title="6.3 范围查询"></a>6.3 范围查询</h3><p>联合索引中，出现范围查询<code>(&gt;,&lt;)</code>，范围查询右侧的列索引失效。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user where profession = '软件工程' and age &gt; 30 and status = '0';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171300231.png" alt="image-20230517130055148"></p><p>当范围查询使用<code>&gt; </code>或 <code>&lt; </code>时，走联合索引了，但是索引的长度为49，就说明范围查询右边的 status 字段是没有走索引的</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user where profession = '软件工程' and age &gt;= 30 and status = '0';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171301473.png" alt="image-20230517130141375"></p><p>当范围查询使用<code>&gt;= </code>或 <code>&lt;= </code>时，走联合索引了，但是索引的长度为54，就说明所有的字段都是走索引的。</p><p>所以，在业务允许的情况下，尽可能的使用类似于 <code>&gt;= 或 &lt;= </code>这类的范围查询，而避免使用<code> &gt; 或 &lt;</code>。</p><h3 id="6-4-索引失效情况"><a href="#6-4-索引失效情况" class="headerlink" title="6.4 索引失效情况"></a>6.4 索引失效情况</h3><h4 id="6-4-1-索引列运算"><a href="#6-4-1-索引列运算" class="headerlink" title="6.4.1 索引列运算"></a>6.4.1 索引列运算</h4><p>不要在索引列上进行运算操作， 索引将失效。</p><p>示例如下：</p><p>在tb_user表中，除了前面介绍的联合索引之外，还有一个索引，是phone字段的单列索引。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171303896.png" alt="image-20230517130341751"></p><ul><li><p>当根据 phone 字段进行等值匹配查询时, 索引生效</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171304897.png" alt="image-20230517130419790"></p></li><li><p>当根据phone字段进行函数运算操作之后，索引失效。</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171304008.png" alt="image-20230517130447902"></p></li></ul><h4 id="6-4-2-字符串不加引号"><a href="#6-4-2-字符串不加引号" class="headerlink" title="6.4.2 字符串不加引号"></a>6.4.2 字符串不加引号</h4><p>字符串类型字段使用时，不加引号，索引将失效。</p><p>示例如下：</p><p><strong>联合索引：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 加单引号explain select * from tb_user where profession = '软件工程' and age = 31 and status= '0';-- 不加单引号explain select * from tb_user where profession = '软件工程' and age = 31 and status= 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171308669.png" alt="image-20230517130825480"></p><p><strong>单列索引：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 加单引号explain select * from tb_user where phone = '17799990015';-- 不加单引号explain select * from tb_user where phone = 17799990015;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171309661.png" alt="image-20230517130916503"></p><p>经过上面两组示例，可以发现，如果字符串不加单引号，对于查询结果，没什么影响，但是数<br>据库存在隐式类型转换，索引将失效。</p><h4 id="6-4-3-模糊查询"><a href="#6-4-3-模糊查询" class="headerlink" title="6.4.3 模糊查询"></a>6.4.3 模糊查询</h4><p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p><p>示例如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user where profession like '软件%';explain select * from tb_user where profession like '%工程';explain select * from tb_user where profession like '%工%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171343520.png" alt="image-20230517134351321"></p><p>经过上述的测试，可以发现，在like模糊查询中，在关键字后面加%，索引可以生效。而如果在关键字前面加了%，索引将会失效。</p><h4 id="6-4-4-or-连接条件"><a href="#6-4-4-or-连接条件" class="headerlink" title="6.4.4 or 连接条件"></a>6.4.4 or 连接条件</h4><p>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user where id = 10 or age = 23;explain select * from tb_user where phone = '17799990017' or age = 23;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171345587.png" alt="image-20230517134514424"></p><p>由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引</p><p>对 age 字段建立索引后，再次执行上述的 SQL 语句，可以看到索引生效</p><h4 id="6-4-5-数据分布影响"><a href="#6-4-5-数据分布影响" class="headerlink" title="6.4.5 数据分布影响"></a>6.4.5 数据分布影响</h4><p>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select * from tb_user where phone &gt;= '17799990005';select * from tb_user where phone &gt;= '17799990015';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171347107.png" alt="image-20230517134718913"></p><p>经过测试可以发现，相同的SQL语句，只是传入的字段值不同，最终的执行计划也完全不一样</p><p>这是因为 MySQL 在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。</p><p>示例：<code> is null</code> 与<code>is not null</code>操作是否走索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user where profession is null;explain select * from tb_user where profession is not null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171350442.png" alt="image-20230517135013217"></p><p>若是将 profession 字段值全部更新为 null：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171350282.png" alt="image-20230517135059205"></p><p>再次执行上述的两条SQL，查看SQL语句的执行计划：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171351905.png" alt="image-20230517135120757"></p><p>最终可以看到，一模一样的SQL语句，先后执行了两次，结果查询计划是不一样的，这是和数据库的数据分布有关系。查询时MySQL会评估，走索引快，还是全表扫描快，如果全表扫描更快，则放弃索引走全表扫描。 因此，is null 、is not null是否走索引，得具体情况具体分析，并不是固定的。</p><h3 id="6-5-SQL-提示"><a href="#6-5-SQL-提示" class="headerlink" title="6.5 SQL 提示"></a>6.5 SQL 提示</h3><p>在 tb_user 表中， profession 字段有联合索引，若此时给改字段添加一个单列索引，查询时索引会使用哪一个？</p><p>对于一个既有联合索引又有单列索引的字段，MySQL 会自动选择一个，若是想自己指定使用哪个索引，就需要借助 MySQL 的 SQL 提示来完成</p><p>SQL 提示，是优化数据库的一种重要手段，简单来说就是在 SQL 语句中加入一些人为的提示来达到优化操作的目的</p><p>相关的操作命令如下：</p><ul><li><p><code>use index</code>：建议 MySQL 使用哪一个索引来完成此次查询（仅仅是建议，MySQL 内部还会再次进行评估）</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user use index(idx_user_pro) where profession = '软件工程';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>ignore index</code>：忽略指定索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user ignore index(idx_user_pro) where profession = '软件工程';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>force index：强制使用索引</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select * from tb_user force index(idx_user_pro) where profession = '软件工程';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="6-6-覆盖索引"><a href="#6-6-覆盖索引" class="headerlink" title="6.6 覆盖索引"></a>6.6 覆盖索引</h3><p>尽量使用<font color="red">覆盖索引</font>，减少 <code>select *</code></p><p>覆盖索引是指查询使用了索引，并且需要返回的列在该索引中已经全部找到</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">explain select id, profession from tb_user where profession = '软件工程' and age =31 and status = '0' ;explain select id,profession,age, status from tb_user where profession = '软件工程'and age = 31 and status = '0' ;explain select id,profession,age, status, name from tb_user where profession = '软件工程' and age = 31 and status = '0' ;explain select * from tb_user where profession = '软件工程' and age = 31 and status= '0';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171403329.png" alt="image-20230517140340049"></p><p>从上述的执行计划可以看到，这四条SQL语句的执行计划前面所有的指标都是一样的，看不出来差异。但是此时，我们主要关注的是后面的Extra，前面两天SQL的结果为 <code>Using where; UsingIndex ;</code> 而后面两条SQL的结果为: <code>Using index condition </code></p><table><thead><tr><th>Extra</th><th>含义</th></tr></thead><tbody><tr><td>Using where; Using Index</td><td>查找使用了索引，但是需要的数据都在索引列中都能找到，索引不需要回表查询数据</td></tr><tr><td>Using index condition</td><td>查找使用了索引，但是需要回表查询数据</td></tr></tbody></table><p>因为，在tb_user表中有一个联合索引 idx_user_pro_age_sta，该索引关联了三个字段 profession、age、status，而这个索引也是一个二级索引，所以叶子节点下面挂的是这一行的主键id。 所以当我们查询返回的数据在 id、profession、age、status 之中，则直接走二级索引<br>直接返回数据了。 如果超出这个范围，就需要拿到主键id，再去扫描聚集索引，再获取额外的数据了，这个过程就是回表。 而我们如果一直使用<code>select * </code>查询返回所有字段值，很容易就会造成回表查询（除非是根据主键查询，此时只会扫描聚集索引）。</p><p>演示示例如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171412830.png" alt="image-20230517141243674"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171413111.png" alt="image-20230517141259974"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171413406.png" alt="image-20230517141326305"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171413255.png" alt="image-20230517141351128"></p><p>那么在应用中，如何针对 SQL 语句进行优化？—— 使用覆盖索引：</p><p>一张表, 有四个字段<code>(id, username, password, status)</code>, 由于数据量大, 需要对以下SQL语句进行优化, 该如何进行才是最优方案：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select id,username,password from tb_user where username = 'itcast';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>答案: 针对于 <code>username, password</code> 建立联合索引, sql 为: </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create index idx_user_name_pass on tb_user(username,password); <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这样可以避免上述的SQL语句，在查询的过程中，出现回表查询。</p><h3 id="6-7-前缀索引"><a href="#6-7-前缀索引" class="headerlink" title="6.7 前缀索引"></a>6.7 前缀索引</h3><p>当字段类型为字符串（<code>varchar，text，longtext</code>等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率</p><p><strong>语法：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create idnex idx_xxxx on table_name(column(n));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>前缀长度：</strong></p><p>可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高， 唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">select count(distinct email) / count(*) from tb_user ;select count(distinct substring(email,1,5)) / count(*) from tb_user ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>前缀索引的查询流程：</strong></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171423566.png" alt="image-20230517142307460"></p><h3 id="6-8-单列索引和联合索引"><a href="#6-8-单列索引和联合索引" class="headerlink" title="6.8 单列索引和联合索引"></a>6.8 单列索引和联合索引</h3><ul><li>单列索引：即一个索引只包含单个列。</li><li>联合索引：即一个索引包含了多个列。</li></ul><p>在 SQL 语句中有 and 连接两个都有单列索引的字段时，MySQL 只会选择一个索引，即只能走一个字段的索引，此时会回表查询的，这时则需要对这两个字段建立联合索引</p><blockquote><p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p></blockquote><p>示例如下：</p><p>字段 phone、name 都有单列索引：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171430401.png" alt="image-20230517143004249"></p><p>字段 phone、name 建立联合索引后：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171431539.png" alt="image-20230517143143402"></p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305171432223.png" alt="image-20230517143242120"></p><h2 id="七、索引设计原则"><a href="#七、索引设计原则" class="headerlink" title="七、索引设计原则"></a>七、索引设计原则</h2><ul><li>针对于数据量较大，且查询比较频繁的表建立索引。</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省储空间，避免回表，提高查询效率。</li><li>要控制索引的数量，索引并不是多多，索引越多，维护索引结构的代价也就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL--存储引擎</title>
      <link href="/tur-study/2023/01/01/MySQL/MySQL--%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
      <url>/tur-study/2023/01/01/MySQL/MySQL--%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="1-MySQL-体系结构"><a href="#1-MySQL-体系结构" class="headerlink" title="1. MySQL 体系结构"></a>1. MySQL 体系结构</h2><p>MySQL 体系的结构如下：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161429172.png" alt="MySQL 体系结构"></p><h3 id="1-1-连接层"><a href="#1-1-连接层" class="headerlink" title="1.1 连接层"></a>1.1 连接层</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161433710.png" alt="image-20230516143324644"></p><p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p><h3 id="1-2-服务层"><a href="#1-2-服务层" class="headerlink" title="1.2 服务层"></a>1.2 服务层</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161434032.png" alt="image-20230516143430975"></p><p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等，最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能</p><h3 id="1-3-引擎层"><a href="#1-3-引擎层" class="headerlink" title="1.3 引擎层"></a>1.3 引擎层</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161435267.png" alt="image-20230516143506213"></p><p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。数据库中的索引是在存储引擎层实现的。</p><h3 id="1-4-存储层"><a href="#1-4-存储层" class="headerlink" title="1.4 存储层"></a>1.4 存储层</h3><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161435460.png" alt="image-20230516143535415"></p><p>数据存储层， 主要是将数据(如: redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等)存储在文件系统之上，并完成与存储引擎的交互。</p><blockquote><p>和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p></blockquote><h2 id="2-存储引擎介绍"><a href="#2-存储引擎介绍" class="headerlink" title="2. 存储引擎介绍"></a>2. 存储引擎介绍</h2><blockquote><p>存储引擎是 MySQL 数据库的核心，需要在合适的场景选择合适的存储引擎</p></blockquote><p>存储引擎就是存储数据，建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表的，而不是基于库的，所以存储引擎也称为表类型。可以在创建表时指定存储引擎，如果没有指定将自动选择默认的存储引擎</p><ul><li><p>建表时指定存储引擎</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TABLE 表名 (    字段 字段类型 [ COMMENT 字段注释 ]) ENGINE = InnoDB [ COMMENT 表注释 ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>查询当前数据库支持的存储引擎</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show engines;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><p><strong>示例</strong></p><ul><li><p>查询建表语句 —— 默认存储引擎：InnoDB</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show create table account;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161528283.png" alt="image-20230516152858217"></p></li><li><p>查询当前数据库支持的存储引擎</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show engines;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161530604.png" alt="image-20230516153050564"></p><p>可以看到默认引擎是 InnoDB</p></li><li><p>创建表时指定引擎</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table my_myisam(id int,name varchar(10)) engine = MyISAM ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="3-存储引擎特点"><a href="#3-存储引擎特点" class="headerlink" title="3. 存储引擎特点"></a>3. 存储引擎特点</h2><blockquote><p>MySQL 支持的存储引擎中 <code>InnoDB</code>、<code>MyISAM</code>、<code>Memory </code> 最为常用</p></blockquote><h3 id="3-1-InnoDB"><a href="#3-1-InnoDB" class="headerlink" title="3.1 InnoDB"></a>3.1 InnoDB</h3><h4 id="3-1-1-介绍"><a href="#3-1-1-介绍" class="headerlink" title="3.1.1 介绍"></a>3.1.1 介绍</h4><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的存储引擎</p><h4 id="3-1-2-特点"><a href="#3-1-2-特点" class="headerlink" title="3.1.2 特点"></a>3.1.2 特点</h4><ul><li>DML 操作遵循 ACID 模型，支持事务</li><li>行级锁，提高并发访问性能</li><li>支持外键 FOREIGN KEY 约束，保证是数据的完整性和正确性</li></ul><h4 id="3-1-3-文件"><a href="#3-1-3-文件" class="headerlink" title="3.1.3 文件"></a>3.1.3 文件</h4><p><code>xxx.ibd</code>：xxx 代表的是表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表结构、数据、索引。</p><p>查询是否开启每张表对应一个 ibd 文件的的语句为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">show variables like 'innodb_file_per_table';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>打开 MySQL 的数据存放目录：<code>C:\ProgramData\MySQL\MySQL Server 8.0\Data</code>，目录下的文件夹代表数据库，数据库里面的文件便是 idb 文件：</p><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161542229.png" alt="image-20230516154235174"></p><p>idb 文件存放表结构、数据、索引。文件是基于二进制存储的，不能直接基于记事本打开，可以使用 MySQL 提供的 <code>ibd2sdi</code> 指令从 ibd 文件中提取 sdi 信息，而 sdi 数据字典信息中就包含该表的表结构</p><p>具体的指令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ibd2sdi xxx.ibd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161555714.png" alt="image-20230516155549649"></p><blockquote><p>==注：==可以会出现 <code>‘ibd2sdi ‘找不到应用程序或可执行文件</code>，需要将 MySQL 的安装目录的 bin 目录添加到环境变量 Path 里面</p></blockquote><h4 id="3-1-4-逻辑存储结构"><a href="#3-1-4-逻辑存储结构" class="headerlink" title="3.1.4 逻辑存储结构"></a>3.1.4 逻辑存储结构</h4><p><img src="https://tur-mg-img.oss-cn-guangzhou.aliyuncs.com/md-img/202305161559990.png" alt="InnoDB 逻辑存储结构"></p><ul><li>表空间 : InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是表空间文件，在表空间中可以包含多个Segment段。</li><li>段 : 表空间是由各个段组成的， 常见的段有数据段、索引段、回滚段等。InnoDB中对于段的管理，都是引擎自身完成，不需要人为对其控制，一个段中包含多个区。</li><li>区 : 区是表空间的单元结构，每个区的大小为1M。 默认情况下， InnoDB存储引擎页大小为16K， 即一个区中一共有64个连续的页。</li><li>页 : 页是组成区的最小单元，页也是InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。</li><li>行 : InnoDB 存储引擎是面向行的，也就是说数据是按行进行存放的，在每一行中除了定义表时所指定的字段以外，还包含两个隐藏字段</li></ul><h3 id="3-2-MyISAM"><a href="#3-2-MyISAM" class="headerlink" title="3.2 MyISAM"></a>3.2 MyISAM</h3><p><strong>介绍</strong></p><p>MyISAM 是 MySQL 早期的默认存储引擎</p><p><strong>特点</strong></p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p><strong>文件</strong></p><p><code>xxx.sdi</code>：存储表结构信息<br><code>xxx.MYD</code>: 存储数据<br><code>xxx.MYI</code>: 存储索引</p><h3 id="3-3-Memory"><a href="#3-3-Memory" class="headerlink" title="3.3 Memory"></a>3.3 Memory</h3><p><strong>介绍</strong></p><p>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为<br>临时表或缓存使用</p><p><strong>特点</strong></p><ul><li>内存存放</li><li>hash 索引（默认）</li></ul><p><strong>文件</strong></p><p><code>xxx.sdi</code>：存储表结构信息</p><h3 id="3-4-区别及特点"><a href="#3-4-区别及特点" class="headerlink" title="3.4 区别及特点"></a>3.4 区别及特点</h3><table><thead><tr><th>特点</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>存储限制</td><td>64TB</td><td>有</td><td>有</td></tr><tr><td>事务安全</td><td>支持</td><td>-</td><td>-</td></tr><tr><td>锁机制</td><td>行锁</td><td>表锁</td><td>表锁</td></tr><tr><td>B+Tree索引</td><td>支持</td><td>支持</td><td>支持</td></tr><tr><td>Hash 索引</td><td>-</td><td>-</td><td>支持</td></tr><tr><td>全文索引</td><td>支持（5.6之后）</td><td>支持</td><td>-</td></tr><tr><td>空间使用</td><td>搞</td><td>低</td><td>N/A</td></tr><tr><td>内存使用</td><td>高</td><td>低</td><td>中等</td></tr><tr><td>批量插入速度</td><td>低</td><td>高</td><td>高</td></tr><tr><td>支持外键</td><td>支持</td><td>-</td><td>-</td></tr></tbody></table><blockquote><p>面试题：InnoDB引擎与MyISAM引擎的区别 ?</p><ul><li>InnoDB 引擎支持事务, 而 MyISAM 不支持。</li><li>InnoDB 引擎支持行锁和表锁, 而 MyISAM 仅支持表锁, 不支持行锁。</li><li>InnoDB 引擎支持外键, 而 MyISAM 是不支持的。</li><li>主要是上述三点区别，当然也可以从索引结构、存储限制等方面</li></ul></blockquote><h3 id="3-5-存储引擎的选择"><a href="#3-5-存储引擎的选择" class="headerlink" title="3.5 存储引擎的选择"></a>3.5 存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据<br>实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要<br>求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操<br>作，那么InnoDB存储引擎是比较合适的选择。</li><li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完<br>整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li><li>MEMORY：将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是<br>对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
